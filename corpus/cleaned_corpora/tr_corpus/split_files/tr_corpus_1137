-15 -14 -13 -12 -11 -10 -9 -8 1349.9 1346.9 1343.8 1340.8 1337.7 1334.6 1331.5 1328.4 1325.3 1322.1 1319 23 24 25 26 27 28 29 30 31 32 33 1213.3 1209.6 1205.9 1202.1 1198.3 1194.4 1190.6 1186.7 1182.8 1178.8 1174.9 64 65 66 67 68 69 70 71 72 73 74 1030.9 1025.3 1019.6 1013.8 1008 1002 995.9 989.7 983.4 977 970.4 -89 -88 -87 -86 -85 -84 -83 -82 -81 -80 -79 -78 -77 -76 -75 -74 -73 -72 -71 -70 -69 -68 -67 -66 -65 -64 -63 -62 -61 -60 1550.4 1547.6 1544.9 1542.1 1539.4 1536.7 1533.9 1531.2 1528.5 1525.7 1523 1520.2 1517.5 1514.8 1512 1509.3 1506.5 1503.8 1501 1498.3 1495.5 1492.8 1490 1487.3 1484.5 1481.8 1479 1476.3 1473.5 1470.7 -48 -47 -46 -45 -44 -43 -42 -41 -40 -39 -38 -37 -36 -35 -34 -33 -32 -31 -30 -29 -28 -27 -26 -25 -24 -23 -22 -21 -20 -19 1437.3 1434.5 1431.6 1428.8 1426 1423.2 1420.3 1417.5 1414.6 1411.8 1408.9 1406 1403.1 1400.2 1397.4 1394.5 1391.5 1388.6 1385.7 1382.8 1379.8 1376.9 1373.9 1371 1368 1365 1362 1359 1356 1353 1315.8 1312.6 1309.4 1306.2 1303 1299.8 1296.5 1293.3 1290 1286.7 1283.4 1280.1 1276.7 1273.4 1270 1266.6 1263.2 1259.8 1256.3 1252.9 1249.4 1245.9 1242.3 1238.8 1235.2 1231.6 1228 1224.4 1220.7 1217 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 1170.8 1166.8 1162.7 1158.6 1154.5 1150.3 1146.1 1141.9 1137.6 1133.3 1128.9 1124.5 1120 1115.6 1111 1106.4 1101.8 1097.1 1092.4 1087.6 1082.8 1077.9 1072.9 1067.9 1062.8 1057.7 1052.5 1047.2 1041.8 1036.4 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 101.08 963.7 956.9 949.9 942.7 935.4 927.8 920.1 912.1 903.9 895.5 886.7 877.6 868.2 858.4 848.1 837.3 826 814 801.1 787.4 772.3 755.8 737.1 715.4 688.6 651.4 566.4 511.8544781 çözüm seti -100. 1578.2165827046 -99. 1575.6316577780 -98. 1573.0433953946 -97. 1570.4517536061 -96. 1567.8566898712 -95. 1565.2581610449 -94. 1562.6561233671 -93. 1560.0505324507 -92. 1557.4413432699 -91. 1554.8285101479 -90. 1552.2119867440 -89. 1549.5917260413 -88. 1546.9676803332 -87. 1544.3398012100 -86. 1541.7080395452 -85. 1539.0723454810 -84. 1536.4326684140 -83. 1533.7889569805 -82. 1531.1411590409 -81. 1528.4892216640 -80. 1525.8330911115 -79. 1523.1727128208 -78. 1520.5080313887 -77. 1517.8389905537 -76. 1515.1655331784 -75. 1512.4876012310 -71. -70. -69. -68. -67. -66. -65. -64. -63. -62. -61. -60. -59. -58. -57. -56. -55. -54. -53. -52. -51. -50. -49. -48. -47. -46. -45. -44. -43. -42. -41. -40. -39. -38. -37. -36. -35. -34. -33. -32. -31. 1501.7299347279 1499.0287268081 1496.3226762626 1493.6117182465 1490.8957868557 1488.1748151038 1485.4487348986 1482.7174770169 1479.9809710797 1477.2391455262 1474.4919275872 1471.7392432573 1468.9810172669 1466.2171730535 1463.4476327309 1460.6723170592 1457.8911454130 1455.1040357480 1452.3109045686 1449.5116668921 1446.7062362137 1443.8945244694 1441.0764419982 1438.2518975032 1435.4207980106 1432.5830488290 1429.7385535059 1426.8872137835 1424.0289295534 1421.1635988090 1418.2911175969 1415.4113799668 1412.5242779197 1409.6297013536 1406.7275380087 1403.8176734097 1400.8999908070 1397.9743711146 1395.0406928475 1392.0988320559 1389.1486622569 -27. -26. -25. -24. -23. -22. -21. -20. -19. -18. -17. -16. -15. -14. -13. -12. -11. -10. -9. -8. -7. -6. -5. -4. -3. -2. -1. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 1377.2622706812 1374.2685648970 1371.2657339058 1368.2536313807 1365.2321078238 1362.2010104729 1359.1601832038 1356.1094664300 1353.0486969980 1349.9777080786 1346.8963290542 1343.8043854011 1340.7016985676 1337.5880858475 1334.4633602479 1331.3273303515 1328.1798001743 1325.0205690163 1321.8494313062 1318.6661764403 1315.4705886135 1312.2624466439 1309.0415237890 1305.8075875549 1302.5603994958 1299.2997150058 1296.0252831006 1292.7368461894 1289.4341398364 1286.1168925114 1282.7848253285 1279.4376517725 1276.0750774123 1272.6967996005 1269.3025071581 1265.8918800441 1262.4645890083 1259.0202952267 1255.5586499184 1252.0792939427 1248.5818573756 17. 18. 19. 20. 21. 22. 23. 24. 25. 26. 27. 28. 29. 30. 31. 32. 33. 34. 35. 36. 37. 38. 39. 40. 41. 42. 43. 44. 45. 46. 47. 48. 49. 50. 51. 52. 53. 54. 55. 56. 57. 1234.4035036263 1230.8097052146 1227.1953534784 1223.5599890727 1219.9031375392 1216.2243086195 1212.5229955273 1208.7986741779 1205.0508023717 1201.2788189269 1197.4821427598 1193.6601719070 1189.8122824856 1185.9378275871 1182.0361360980 1178.1065114440 1174.1482302487 1170.1605409015 1166.1426620266 1162.0937808445 1158.0130514173 1153.8995927659 1149.7524868504 1145.5707763987 1141.3534625709 1137.0995024429 1132.8078062932 1128.4772346732 1124.1065952386 1119.6946393206 1115.2400582064 1110.7414791030 1106.1974607465 1101.6064886222 1096.9669697491 1092.2772269828 1087.5354927791 1082.7399023564 1077.8884861845 1072.9791617161 1068.0097242686 61. 1047.4818802714 62. 1042.1737623283 63. 1036.7890891627 64. 1031.3244464559 65. 1025.7761766140 66. 1020.1403542152 67. 1014.4127582035 68. 1008.5888402882 69. 1002.6636888991 70. 996.6319879133 71. 990.4879692009 76. 957.8418743543 77. 950.8693290442 78. 943.7254580358 79. 936.3978754687 80. 928.8727091594 81. 921.1343422374 82. 913.1650944916 83. 904.9448253848 84. 896.4504339617 85. 887.6552210907 86. 878.5280649497 87. 869.0323386222 88. 859.1244643913 89. 848.7519445048 90. 837.8506177163 91. 826.3407360630 92. 814.1211798647 93. 801.0606100850 94. 786.9833237755 95. 771.6453646423 96. 754.6912462091 97. 735.5679238476 98. 713.3300508506 99. 686.1025628037 100. 648.9650044718 101. 566.7273283809 101.08 513.6836557615 -74. 1509.8051357671 -73. 1507.1180769099 -72. 1504.4263638304 -30. 1386.1900543648 -29. 1383.2228766182 -28. 1380.2469945043 14. 1245.0659590632 15. 1241.5312061522 16. 1237.9771935947 58. 1062.9778369448 59. 1057.8810194680 60. 1052.7166357857 Çıktı 6.3-1 Genel en küçük kareler metodu ile eğri uydurma, grafik çıktısı detay görünümü Burada gerçek veri ile çözülen gerçek bir en küçük kareler program uygulaması görülmektedir. Eğrinin uyma miktarlarını görebilmek için veriler aynı noktalarda uydurduğumuz eğriden elde edilen değerler ve orijinal veri de listelenmiştir. Bir verinin ne kadar iyi uyduğu kullanıcının gereksinmelerine bağlıdır. Gerçek verilerle yapılan herhangi bir eğri uydurma formülü kabul edilmeden önce detaylı incelenmesi gerekir. m f ( x0 , x1 ,...,xn1 , xn )   a (j m ) j ( x0 , x1 ,...,xn1 , xn ) j inci derece polinomu verilmiş olsun. Bu polinoma x0, x1, x2,…, j 0 xn ,fi, i=0...n verisini uydurmak istiyoruz. Bu veri seti için en uygun aj(m) değerlerini bulmak istiyoruz. Bunun için 2   k  0,.....,m Bu durumda temel denklem   k  0,..,m şeklini alır. Örnek genel fonksiyon olarak iki boyutlu 4üncü derecen polinom denklemini alalım f(x,y) = a0 + a1x + a2y + a3x2 + a4y2 + a5xy + a6x3 + a7y3 + a8x2y + a9xy2 + a10x4 + a11y4 + a12 x2y2 + k  0,..,m a13x3y + a14xy2 Program 6.4-1 Genel en küçük kareler metodu ile ikinci derece polinom eğri uydurma İmport java.io. * import java.util. * import javax.swing. * import java.awt.event. * import visad. if((Math.abs(X[i]/max) > 0) && (Math.abs(X[i]/max) < 1.0e-100)) X[i]=0 Text.printT(X) return X } public static double funcEKKgenel(double e[],double x[]) { // tek bir nokta için çok boyutlu eğri değeri hesaplar fa f=new fa() int n=e.length double ff=0 if(n.=0.0) { for(int i=n-1 i>=0 i--) {ff+=e[i]*f.func(x,i) } } return ff } public static double[] funcEKKgenel(double e[],double xi[][]) { // tek bir nokta için çok boyutlu eğri değeri hesaplar fa f=new fa() int n=e.length double ff[]=new double[xi.length] for(int k=0 k<xi.length k++) { if(n.=0.0) { for(int i=n-1 i>=0 i--) {ff[k]+=e[i]*f.func(xi[k],i) } } } return ff } public static double[][] cikti(double c[][],int polinomkatsayisi,int aradegersayisi) { int n1=c.length int n2=c[0].length-1 double xi[][]=new double[n1][n2] double yi[]=new double[n1] for(int i=0 i<n1 i++){for(int j=0 j<n2 j++){xi[i][j]=c[i][j] } yi[i]=c[i][n2] } return cikti(xi,yi,polinomkatsayisi,aradegersayisi) } // tek bir nokta için iki boyutlu eğri değeri hesaplar double xx[]=new double[2] xx[0]=x xx[1]=y return funcEKKgenel(e,xx) } public static double hata(double c[][],double e[]) {int n1=c.length int n2=c[0].length-1 System.out.println( n1= +n1+ n2= +n2) double xi[][]=new double[n1][n2] double yi[]=new double[n1] for(int i=0 i<n1 i++){for(int j=0 j<n2 j++){xi[i][j]=c[i][j] } yi[i]=c[i][n2] } return hata(xi,yi,e) } public static double hata(double x[][],double y[],double e[]) { //calculates absolute square root error of a least square approach double n=x.length int k double total=0 for(k=0 k<n k++) { total+=(y[k]-funcEKKgenel(e,x[k]))*(y[k]-funcEKKgenel(e,x[k])) } total=Math.sqrt(total) return total } public static void main(String[] args) throws RemoteException, VisADException { String s1=JOptionPane.showInputDialog( dosya adı ) double c[][]=Text.readDouble(s1) Text.print(c) double b[]=EKKgenel(c,10) double xi[][]=cikti(c,10,5) System.out.println( cikti \n +Matrix.toString(xi)) System.out.println( hata \n +Matrix.toString(hata(c,b))) } } 1 1.624 2.952 5.368 9.256 15 22.984 33.592 47.208 64.216 1.624 2.536 4.28 7.24 11.8 18.344 27.256 38.92 53.72 72.04 2.952 4.28 6.568 10.2 15.56 23.032 33 45.848 61.96 81.72 5.368 7.24 10.2 14.632 20.92 29.448 40.6 54.76 72.312 93.64 9.256 11.8 15.56 20.92 28.264 37.976 50.44 66.04 85.16 108.184 15 18.344 23.032 29.448 37.976 49 62.904 80.072 100.888 125.736 22.984 27.256 33 40.6 50.44 62.904 78.376 97.24 119.88 146.68 33.592 38.92 45.848 54.76 66.04 80.072 97.24 117.928 142.52 171.4 47.208 53.72 61.96 72.312 85.16 100.888 119.88 142.52 169.192 200.28 64.216 72.04 81.72 93.64 108.184 125.736 146.68 171.4 200.28 233.704 85 94.264 105.512 119.128 135.496 155 178.024 204.952 236.168 272.056 Örnek verimiz katsayılar matrisi 1 olacak şekilde oluşturulmuştur. Bu veriye eğri uydurduğumuzda Çıktı 6.4-1 (Program 6.4-1) Genel en küçük kareler metodu ile ikinci derece polinom eğri uydurma Çözüm katsayılar vektörü Çıktı 6.4-1 (Program 6.4-1) Genel en küçük kareler metodu ile ikinci derece polinom eğri uydurma Çözüm katsayılar vektörü kulanılarak uydurulmuş eğri 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.066666666666667 0.133333333333333 0.200000000000000 0.266666666666667 0.333333333333333 0.400000000000000 0.466666666666667 0.533333333333333 0.600000000000000 0.666666666666667 0.733333333333333 0.800000000000000 0.866666666666667 0.933333333333333 1.000000000000000 1.066666666666667 1.133333333333333 1.200000000000000 1.266666666666667 1.333333333333333 1.400000000000000 1.466666666666667 1.533333333333333 1.600000000000000 1.666666666666667 1.733333333333333 1.800000000000000 1.866666666666667 1.933333333333333 2.000000000000000 2.066666666666666 2.133333333333333 2.199999999999999 2.266666666666666 2.333333333333332 2.400000000000000 2.466666666666667 2.533333333333333 2.600000000000000 2.666666666666666 2.733333333333332 2.800000000000000 2.866666666666667 2.933333333333334 3.000000000000000 0.999999999994438 1.071407407401890 1.153481481475994 1.247999999994529 1.356740740735274 1.481481481476007 1.623999999994506 1.786074074068551 1.969481481475919 2.175999999994390 2.407407407401740 2.665481481475751 2.951999999994199 3.268740740734862 3.617481481475521 3.999999999993952 4.418074074067935 4.873481481475248 5.367999999993669 5.903407407400978 6.481481481474952 7.103999999993371 7.772740740734011 8.489481481474654 9.255999999993078 10.074074074067056 10.945481481474370 11.871999999992802 12.855407407400127 13.897481481474122 14.999999999992570 16.164740740733244 17.393481481473923 18.687999999992390 20.050074074066416 21.481481481473786 22.983999999992310 24.559407407399710 26.209481481473784 27.935999999992312 29.740740740733070 31.625481481473848 33.591999999992440 35.642074074066590 37.777481481474100 39.999999999992730 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 0.066666666666667 0.133333333333333 0.200000000000000 0.266666666666667 0.333333333333333 0.400000000000000 0.400000000000000 0.400000000000000 0.400000000000000 0.400000000000000 0.400000000000000 0.400000000000000 0.400000000000000 0.400000000000000 0.400000000000000 0.400000000000000 0.400000000000000 0.400000000000000 0.400000000000000 0.400000000000000 0.400000000000000 0.400000000000000 0.400000000000000 0.400000000000000 0.400000000000000 0.400000000000000 0.400000000000000 0.400000000000000 0.400000000000000 0.400000000000000 0.400000000000000 0.400000000000000 0.400000000000000 0.400000000000000 0.400000000000000 0.400000000000000 0.400000000000000 0.400000000000000 0.400000000000000 0.400000000000000 0.400000000000000 0.400000000000000 0.400000000000000 0.400000000000000 0.400000000000000 0.400000000000000 0.400000000000000 0.400000000000000 0.400000000000000 4.000000000000000 4.000000000000000 4.000000000000000 4.000000000000000 4.000000000000000 4.000000000000000 4.000000000000000 4.000000000000000 4.000000000000000 4.000000000000000 4.000000000000000 4.000000000000000 4.000000000000000 4.000000000000000 4.000000000000000 4.000000000000000 4.000000000000000 4.000000000000000 3.066666666666667 3.133333333333334 3.200000000000000 3.266666666666667 3.333333333333333 3.400000000000000 3.466666666666666 3.533333333333332 3.600000000000000 3.000000000000000 2.400000000000000 1.800000000000000 1.200000000000000 0.600000000000000 0.000000000000000 0.066666666666667 0.133333333333333 0.200000000000000 0.266666666666667 0.333333333333333 0.400000000000000 0.466666666666667 0.533333333333333 0.600000000000000 0.666666666666667 0.733333333333333 0.800000000000000 0.866666666666667 0.933333333333333 1.000000000000000 1.066666666666667 1.133333333333333 1.200000000000000 1.266666666666667 1.333333333333333 1.400000000000000 1.466666666666667 1.533333333333333 1.600000000000000 1.666666666666667 1.733333333333333 1.800000000000000 1.866666666666667 1.933333333333333 2.000000000000000 2.066666666666666 2.133333333333333 2.199999999999999 2.266666666666666 2.333333333333332 2.400000000000000 2.466666666666667 2.533333333333333 2.600000000000000 2.666666666666666 2.733333333333332 2.800000000000000 2.866666666666667 2.400000000000000 2.466666666666667 2.533333333333333 2.600000000000000 2.666666666666666 2.733333333333332 2.800000000000000 2.866666666666667 2.933333333333334 3.000000000000000 3.066666666666667 3.133333333333334 3.200000000000000 3.266666666666667 3.333333333333333 3.400000000000000 3.466666666666666 3.533333333333332 42.311407407400260 44.713481481474480 47.207999999993150 49.796740740734050 52.481481481474980 55.263999999993715 58.146074074068025 61.129481481475680 64.215999999994550 40.884740740736510 24.268148148146093 13.200000000000534 6.514074074077106 3.044148148153063 1.624000000005665 1.734518518524260 1.859259259265062 2.000000000005850 2.158518518524403 2.336592592598499 2.536000000005916 2.758518518524433 3.005925925931828 3.280000000005880 3.582518518524367 3.915259259265068 4.280000000005763 4.678518518524228 5.112592592598241 5.584000000005583 6.094518518524030 6.645925925931362 7.240000000005360 7.878518518523796 8.563259259264454 9.296000000005112 10.078518518523543 10.912592592597536 11.800000000004860 12.742518518523298 13.741925925930627 14.800000000004625 15.918518518523072 17.099259259263746 18.344000000004428 19.654518518522885 21.032592592596906 22.480000000004267 23.998518518522744 25.589925925930118 27.256000000004207 28.998518518522722 30.819259259263460 32.720000000004210 34.702518518522744 36.768592592596846 38.920000000004336 41.158518518522930 178.023999999995600 182.230518518514030 186.547259259254700 190.975999999995340 195.518518518513800 200.176592592587750 204.951999999995170 209.846518518513650 214.861925925921070 219.999999999995100 225.262518518513670 230.651259259254370 236.167999999995100 241.814518518513580 247.592592592587700 253.503999999995070 259.550518518513600 265.733925925921000 4.000000000000000 3.600000000000000 272.055999999995300 n+1 veri noktasından geçen Newton interpolasyon(aradeğer) formülünü fn(x)=b0+b1(x-x0)+….+bn(x-x0) (x-x1)… (x-xn) formülünden elde edebiliriz. Katsayıları b0=f(x0) b1=f[x1,x0] b2= f[x2,x1,x0] … bn= f[xn,xn-1,….,x0] şeklinde yazabiliriz. Burada xi  x j benzer biçimde n. Dereceden sonlu bölünmüş fark da şeklinde yazılabilir. Bu denklem Newton'un bölünmüş fark interpolasyon polinomu olarak adlandırılır. Bir örnek problem verelim A ilinin nüfüs dağılımı aşağıdaki gibi verilmiştir. Newton interpolasyon metodu ile 1945 yılının nüfusunu hesaplamak istiyelim. yıl 1940 1950 1960 1970 1980 1990 nüfus 132165 151336 179323 203302 226542 249633 Newton fark tablosu xi yi f[xi,xj] f[xi,xj,xk] f[xi,xj,xk,xl] f[xi,xj,xk,xl,xn] f[xi,xj,xk,xl,xn,xm] 1940 132165 1917.1 44.08 2.137333333 0.067054167 -0.001564333 1950 151336 2798.7 -20.04 0.544833333 -0.0111625 1960 179323 2397.9 -3.695 0.098333333 1970 203302 2324 -0.745 1980 226542 2309.1 1990 249633 Şeklinde oluşacaktır. Buradan derecesini arttırarak çözümlere ulaşırsak 141750.5 140648.5 139847 139218.4 138705.1 Şeklinde çözümleri hesaplayabiliriz. Newton interpolasyon formülünün en önemliavantajı polinom katsayısını arttırmak için son polinom terimini hesaplayarak bir önceki dereceden polinom için hesaplanan değere ekleyebilme olasılığımızın olmasıdır. Şimdi aynı örenk problemi program üzerinden verelim Program 6.5-1 Newton bölünmüş fark interpolasyonu denklemi import java.io. * class SCO11C { public static double[][] Newton(double xi[],double yi[]) { int n=xi.length double F[][]=new double[n+1][n] for(int i=0 i<n i++) F[i][0]=yi[i] for(int i=1 i<n i++) { for(int j=1 j<=i j++) {F[i][j]=(F[i][j-1]-F[i-1][j-1])/(xi[i]-xi[i-j]) } } for(int i=0 i<n i++) {F[n][i]=xi[i] } //System.out.println(Matrix.toString(F)) return F } public static double funcNewton(double F[][],double x) { int n=F[0].length double carpim=1.0 double toplam=0 for(int i=0 i<n i++) { carpim=F[i][i] for(int j=0 j<=(i-1) j++) {carpim*=(x-F[n][j]) } toplam+=carpim } return toplam } public static double[][] funcNewton(double xi[],double yi[],int aradegersayisi) { //aradegersayisi x--o--o--x--o--o--x zincirinde x deneysel noktalar ise // ara değer sayısı 2 dir int n=xi.length int nn=(n-1)*(aradegersayisi+1)+1 double z[][]=new double[2][nn] double Q[][]=Newton(xi,yi) double dx=0 int k=0 int i for(i=0 i<(n-1) i++) { z[0][k]=xi[i] z[1][k]=funcNewton(Q,z[0][k]) k++ for(int j=0 j<aradegersayisi j++) {dx=(xi[i+1]-xi[i])/((double)aradegersayisi+1.0) z[0][k]=z[0][k-1]+dx z[1][k]=funcNewton(Q,z[0][k]) k++ } } z[0][k]=xi[i] z[1][k]=funcNewton(Q,z[0][k]) return z } public static void main(String args[]) throws IOException { double x[]={1940,1950,1960,1970,1980,1990} double y[]={132165,151336,179323,203302,226542,249633} double z1[][]=funcNewton(x,y,9) System.out.println( Newton interpolasyonu\n +Matrix.toStringT(z1)) Text.print(Text.T(z1), Newton interpolasyonu ) Plot pp=new Plot(x,y) pp.setPlabel( Newton interpolasyon yöntemi eğri uydurma ) pp.setPlotType(0,20) pp.addData(z1[0],z1[1]) pp.plot() } } Çıktı 6.5-1 Newton bölünmüş fark interpolasyonu grafik çıktısı Çıktı 6.5-2 Newton bölünmüş fark interpolasyonu rakam çıktısı 1940.0 132165.0 1956.0 168453.33574399998 1971.0 205566.7306065 1986.0 241050.42534399996 1941.0 132684.8307565 1957.0 171242.42802049997 1972.0 207832.72300800003 1987.0 243351.74387050004 1942.0 133658.281408 1958.0 173986.55059199999 1973.0 210105.9632045 1988.0 245567.776192 1943.0 135023.3483545 1959.0 176680.98561849998 1974.0 212391.793856 1989.0 247671.68846850004 1944.0 136723.01625599997 1960.0 179323.0 1975.0 214694.7265625 1990.0 249633.0 1945.0 138705.0703125 1946.0 140921.908544 1961.0 181911.65765650003 1976.0 217018.254144 1962.0 184447.631808 1977.0 219364.6629205 1947.0 143330.3540705 1963.0 186933.01725449998 1978.0 221734.844992 1948.0 145891.467392 1964.0 189371.142656 1979.0 224128.1105185 1949.0 148570.3586685 1965.0 191766.3828125 1980.0 226542.00000000003 1950.0 151336.0 1966.0 194123.97094400003 1981.0 228972.09655649998 1951.0 154161.0377065 1967.0 196449.8109705 1982.0 231411.83820800006 1952.0 157021.60460800002 1968.0 198750.289792 1983.0 233852.33015450006 1953.0 159897.13230449997 1969.0 201032.0895685 1984.0 236282.15705599997 1954.0 162770.16345599998 1970.0 203302.0 1985.0 238687.1953125 1955.0 165626.1640625 Lagrange interpolasyonunda bölünmüş farkların hesaplanması gerekmez. n f n ( x)   Li ( x) f ( xi ) Burada i 0 n Li ( x)   j 0 j i x  xj xi  x j şeklindedir.  Örneğin doğrusal polinom (n=1) için f1 ( x)  çarpım sembolüdür. x  x0 x  x1 f ( x0 )  f ( x1 ) x0  x1 x1  x0 ikinci dereceden polinom için ise f 2 ( x)  ( x  x0 )( x  x2 ) ( x  x0 )( x  x1 ) ( x  x1 )( x  x2 ) f ( x0 )  f ( x1 )  f ( x2 ) ( x0  x1 )( x0  x2 ) ( x1  x0 )( x1  x2 ) ( x2  x0 )( x2  x1 ) şeklinde açık formülü yazabiliriz. Program 6.6-1 Lagrange interpolasyon polinomu import java.io. * class SCO11D { public static double[][] Lagrange(double xi[],double yi[]) { int n=xi.length double L[][]=new double[2][n] for(int i=0 i<n i++) {L[0][i]=yi[i] for(int j=0 j<n j++) {if(i.=j) L[0][i]/=(xi[i]-xi[j]) } } for(int i=0 i<n i++) {L[1][i]=xi[i] } return L } public static double funcLagrange(double L[][],double x) { int n=L[0].length double carpim=1.0 double toplam=0 for(int i=0 i<n i++) {carpim=L[0][i] for(int j=0 j<n j++) {if(i.=j) carpim*=(x-L[1][j]) } toplam+=carpim } return toplam } } } Çıktı 6.6-1 Lagrange interpolasyon polinomu Lagrange interpolasyonu 1.3000000000 0.2800860000 1.3333333333 0.3167952180 1.3666666667 0.3491970259 1.4000000000 0.3772914238 1.4333333333 0.4010784116 1.4666666667 0.4205579894 1.5000000000 0.4357301571 1.5333333333 0.4465949148 1.5666666667 0.4531522624 1.6000000000 1.6333333333 1.6666666667 1.7000000000 1.7333333333 1.7666666667 1.8000000000 1.8333333333 1.8666666667 1.9000000000 0.4554022000 0.4533447275 0.4469798450 0.4363075524 0.4213278498 0.4020407372 0.3784462144 0.3505442817 0.3183349389 0.2818181860 Çıktı 6.6-2 Lagrange interpolasyon polinomu (grafik sonuç) Genel formül H(x) = Q0,0+ Q1,1(x-x0)+ Q2,2(x-x0)2+ Q3,3(x-x0)2(x-x1)+ Q4,4(x-x0)2(x-x1)2+…+ Q2n+1,2n+1(x-x0)2(x-x1)2…(x-xn-1)2(x-xn) Şeklinde verilebilir. Katsayıların hesaplanması Algoritma 6.6-1 ve Tablo 6.6-1 de açıklanmıştır. Q2i , j  } Adım 1 in sonu Adım 4 for i=2,3,…,2n+1 Q2i ,0  Q2i1,0 z2i  z2i1 { for j=2,3,…,i } Z4 = x2 f[z4]=f(x2) Z5 = x2 f[z5]=f(x2) f[z4, z5]  f(x2) xk f(xk) 0.6200860 0.4554022 0.2818186 f'(xk) -0.5220232 -05698959 -0.5811571 Tablo 6.7-1 deki fark tablosunu oluşturursak 1.3 0.620086 1.3 0.620086 -0.5220232 -0.08974267 -0.548946 1.6 0.4554022 0.06636556 -0.069833 -0.5698959 1.6 0.4554022 1.9 0.2818186 1.9 0.2818186 0.00266667 0.06796556 -0.02905367 -0.578612 -0.00277469 0.00100185 0.06856667 -0.00848367 -0.5811571 x=1.5 noktasındaki interpolasyon değeri H5(1.5) =0.620086+(1.5-1.3)*( -0.5220232)+ (1.5-1.3)2*(1.5-1.6)*( 0.06636556+ (1.5-1.3)2* (1.5-1.6)2*(0.00266667)+ 1.5-1.3)2* (1.5-1.6)2*(1.5-1.9) (-0.00277469)=0.5118277 Şimdi de aynı hesaplamayı yapan örnek programımızı inceleyelim. Yukarıda hesapladığımız nokta program çıktısında koyu olarak belirtilmiştir. Program 6-7-1 Hermit interpolasyonu import java.io. Hermite interpolasyonu 1.3000000000 0.6200860000 1.3333333333 0.6025660584 1.3666666667 0.5848174157 1.4000000000 0.5668545838 1.4333333333 0.5486921534 1.4666666667 0.5303447937 1.5000000000 0.5118272527 1.5333333333 0.4931543568 1.5666666667 0.4743410113 1.6000000000 1.6333333333 1.6666666667 1.7000000000 1.7333333333 1.7666666667 1.8000000000 1.8333333333 1.8666666667 1.9000000000 0.4554022000 0.4363529853 0.4172085082 0.3979839884 0.3786947244 0.3593560931 0.3399835500 0.3205926294 0.3011989443 0.2818181860 Örneğin üçüncü dereceden bir polinom düşünülebilir. rk(x)=ak(x-xk)3+ bk(x-xk)2+ ck(x-xk)+yk 1  k  n interpolasyon prosesinde polinomların veri noktalarından geçmesi gerekir. rk(xk+1)=yk+1 1 k  n aynı zamanda birinci türevlerin de sürekli olması gerekir. r'k-1(xk)= r'k(xk) 1 k  n üçüncü dereceden polinom için ikinci türevleri de eşitleyebiliriz. r k-1(xk)= r k(xk) 1  k  n tüm sistemi çözmek için iki şart daha gerekir. Bu şartlar r 1(x1)=0 r n-1(xn)=0 olarak alınırsa buna doğal kübik şerit interpolayonu adını veririz. Başka sınır şartları belirlememiz de mümkündür. hk=xk+1-xk 1  k  n Tum bu şartla bir denklem sistemi olarak bir araya toplanırsa akhk3+ bkhk2+ckhk = yk+1-yk, 1 k  n 3ak-1hk-12+ 2bk-1hk-1+ck-1-ck = 0 , 1 k  n 6ak-1hk-1+ 2bk-1+2bk =0 , 1 k  n 2b0 =0 6an-1hn-1+ 2bn-1 =0 seti oluşur bu set 3n-3 denklem içerir.bu sayıda denklemi bir arada çözme işlemi matris çözümlemesine oldukça ağır bir yük getirebilir artı hata olasılıklarını arttırır. Toplam çözülmesi gereken denklem sayısını azaltmanın bir yolu değiştirilmiş özel bir üçüncü dereceden polinom kullanmaktır.  yk 1  yk yk  yk 1    hk 1   hk hk-1ck-1+ 2( hk-1- hk )ck+ hk ck+1 = 6  , 1 k  n bu sistemde toplam n-2 denklem mevcuttur. wk  yk 1  yk , hk 1 k  n tanımını yaparsak çözülecek denklem sistemini burada A ve B kullanıcı tarafından verilmesi gereken sınır şartlarıdır. Program 6.8-1 Şerit (spline) interpolasyonu import java.io. * class SCO11F { public static double [] thomas(double a[][],double r[]) { // int n=a.length double f[]=new double[n] double e[]=new double[n] double g[]=new double[n] double x[]=new double[n] for(int i=0 i<n i++) {f[i]=a[i][i] } for(int i=0 i<(n-1) i++) {g[i]=a[i][i+1] } for(int i=0 i<(n-1) i++) {e[i+1]=a[i+1][i] } for(int k=1 k<n k++) {e[k]=e[k]/f[k-1] f[k]=f[k]-e[k]*g[k-1] } for(int k=1 k<n k++) {r[k]=r[k]-e[k]*r[k-1] } x[n-1]=r[n-1]/f[n-1] for(int k=(n-2) k>=0 k--) {x[k]=(r[k]-g[k]*x[k+1])/f[k] } return x } public static double [] thomas(double f[],double e[],double g[],double r[]) { int n=f.length double x[]=new double[n] for(int k=1 k<n k++) {e[k]=e[k]/f[k-1] f[k]=f[k]-e[k]*g[k-1] } for(int k=1 k<n k++) {r[k]=r[k]-e[k]*r[k-1] } x[n-1]=r[n-1]/f[n-1] for(int k=(n-2) k>=0 k--) {x[k]=(r[k]-g[k]*x[k+1])/f[k] } return x } Çıktı 6.8-1 Şerit (spline) interpolasyonu Sonsuz sayıda noktadan oluşmuş bir set düşünelim Bu fonksiyon dirac-delta fonksiyonu olarak bilinir. B şerit fonksiyonu aynı zamanda her durum için pozitif tanımlı bir fonsiyondur. Yani tüm x ve i değerleri için Bi0 ( x)  0 yazılabilir. Aynı zamanda tüm x değerleri için i  0  Bi ( x)  1 olur. i   B0i tanımlandığında daha üst dereceden B şerit fonksiyonları bu tanımdan yola çıkılarak tanımlanabilir.  x  ti Bik ( x)    ti 1  ti  k 1  t  x  k 1  Bi ( x)   i  2  Bi 1 ( x)   ti 2  ti 1  Şekil 6.9-2 B1i şerit tanımı Bu fonksiyon için de i   Bi ( x)  1 bağıntısı geçerlidir. i   1 B şerit interpolasyon formülü k inci dereceden B şerit için i  f ( x)   Cik Bik ( x) şeklinde ifade edilir. Ancak bu denklem yukarıdaki denklemle birlikte değerlendirilir ise i    x  ti i  f ( x)   Cik  i   ti1  ti  k 1  t  x  k 1   Bi ( x)   i2    t  t  Bi1 ( x) formunu alır. Buradan da denklemimizi    i 2 i1  i  f ( x)   Cik 1 Bik 1 ( x) formuna dönüştürebiliriz. Katsayılar arasında i   Bu temel bağıntılardan yararlanarak B şerit interpolasyonu adım adım oluşturabiliriz. En genel formda interpolasyon formülümüz i  S ( x)   Ai Bikk ( x) ise i   Önce 0ıncı dereceden şerit interpolasyon ile başlarsak, bu denkleme X t0 t1 … Y y0 y1 …. tn Yn verisini uyduracağız. Yani S(ti)=yi 0  i  n olmasını istiyoruz. Eğri uydurmaya Bi0 şeridinden başlarsak i  j 1 Bi0 (t j )   ij    olduğundan problemin çzümü basit olarak i  j 0 Ai=yi 0  i  n seçmekten ibarettir. Bu durumda şerit n Oıncı derece şeritten birinci derece şerite geçersek çözümümüz yine i 0 basit bir denklemdir. i  j 1 Bi11 (t j )   ij    i  j 0 i n S ( x)   yi Bi11 ( x) şeklinde olacaktır. Burada yine Ai=yi 0  i  n olmuştur. Daha yüksek dereceden i 0 polinomlar için, örneğin 2 derece polinom için i  k  Ai Bi2 (t j )  i     denklem sistemi elde edilir Bu durumda denklem Aj 1   j   j Aj 0  j  n formunda yazılabilir. Buradaki katsayılar  j  yi  j  şeklinde yazılabilir. Katsayıların değerlerini küçük tutabilmek için bizim seçtiğimiz A0 değeri n 1    Ai2 fonksiyonunu minimum yapacak şekilde seçilmesi tavsiye edilir. Buradan A0 değerini bulmak için i 0 (Bütün Ai değerlerinin A0 dan türediğini hatırlayalım) şu şekilde bir denklem yazabiliriz denklemdeki  j ve  j ardışık yerine koyma prosesi ile saptanabilir. qA0  p  0 şeklinde yazılırsa q  1   02  12  ...  n2 p   0 0   11   2 2  ...  n n şeklinde yazabiliriz. Bu tanımla ikinci dereceden B şerit interpolasyon katsayılarını bulmak için gereken tüm denklemler oluşmuş olur. Bu denklem seti kullanılarak problem 6.8-1 de ikinci dereceden B şerit interpolasyon programı oluşturulmuştur. Bu denklem sisteminde herhangi bir matris çözümü olmadığından ve değerler ardışık yerine koyma ile oluşturulduğundan programın oluşturulması bir üst bölümde verdiğimiz kübik şerit interpolasyonuna göre çok daha kolaydır. Program 6.9-1 B-Şerit (spline) interpolasyonu //B spline eğri uydurma import java.io. * import javax.swing. Çıktı 6.9-1 B-Şerit (spline) interpolasyonu örnek problem grafik çıktısı y  f (a x) genel fonksiyonu verildiğinde, bu polinoma xi,fi, i=0...n verisini uydurmak istiyoruz. Burada a katsayıları fonksiyonda lineer olmayan bir formda yer almaktadır. En küçük kareler hata fonksiyonunu en genel formunda n  H (a0( m ) ,....,am( m ) )   w( x i0 , x1i ,...,x ik ) yi  f (a0( m ) ,....,am( m ) , x i0 , x1i ,...,x ik ) i 1  2 şeklinde yazabiliriz. Ancak bu durumda lineer sistemlerde olduğu gibi katsayılardan bağımsız bir türev denklemi oluşturmamız mümkün olamaz. Programimiz hata denkleminin minimizasyonu olduğu için bu denklemi optimizasyon konusunda gördüğümüz metodları kullanarak minimize edebiliriz. Örnek programda Nelder-Mead minimizasyon metodu kullanılmıştır. Önce fonksiyonlarımızı bir boyutlu (bağımsız değişkenli) olarak irdeleyelim. 20.0 33.0 25.0 38.0 30.0 36.0 Eğri uydurmak istediğiz lineer olmıyan fonksiyon double pi=ai[0]*(1.0-Math.exp(-ai[1]*x)) şeklindedir. burada ai katsayılar x de bağımsız değişkendir. Program 6.10-1 Lineer olmayan eğri uydurma örneği, Nelder-Mead Simpleks metodu import java.io. * import javax.swing. * abstract class f_xj { // single function multi independent variable // a single value is returned ( // example f=x[0]+sin(x[1]) // func(x) returns the value of f abstract public double func(double x[]) } class yy extends f_xj { double xi[] // independent variable data set double yi[] //dependent variable data set double a[] //fit function coefficient set int nn public yy(String filename,double ia[]) { //read the data to curvefit //get the data file and initial fit coefficient when class is defined xi=new double[500] yi=new double[500] int n=ia.length a=new double[n] seta(ia) int i=-1 try{ BufferedReader fin=new BufferedReader(new FileReader(filename)) try { while(fin .= null) { i++ xi[i]=Text.readDouble(fin) yi[i]=Text.readDouble(fin) } } catch(EOFException e_eof) {System.out.println( end of file ) } }catch(IOException e_io) {System.out.println( dosya bulunamadı ) } nn=i a=ia } public void seta(double ia[]) { //assign new fit coefficient set for(int ii=0 ii<nn ii++) a[ii]=ia[ii] } public double[] geta() { // return fit coefficient set return a } double Ps(double x,double ai[]) { //sample specific function // saturation pressure as a function of saturation temperature a=ai double pi=ai[0]*(1.0-Math.exp(-ai[1]*x)) return pi //kPa } Çıktı 6.10-1 Lineer olmayan eğri uydurma örneği Aynı problemi değişik yöntemler kullanarak ta çözebiliriz, Örneğin Davidon-Fletcher-Powell yöntemini kullanırsak Program 6.10-2 Lineer olmayan eğri uydurma , Davidon-Fletcher-Powell metodu // OPO12F Davidon-Fletcher-Powell optimizasyonu // Metod Referansı Numerical Analysis, 8th edition Richard L. Burden, J. Douglas Faires 3 // sayfa 617 import java.util. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. * import java.io. * class fa extends f_xj { double xi[] // independent variable data set double yi[] //dependent variable data set double a[] //fit function coefficient set int nn public fa(String filename,double ia[]) { //read the data to curvefit //get the data file and initial fit coefficient when class is defined xi=new double[500] yi=new double[500] int n=ia.length a=new double[n] seta(ia) int i=-1 try{ BufferedReader fin=new BufferedReader(new FileReader(filename)) try { while(fin .= null) { i++ xi[i]=Text.readDouble(fin) { for(i=0 i<n-m i++) { T[i][m]=(h[i]*h[i]*T[i+1][m-1] - h[i+m]*h[i+m]*T[i][m-1])/(h[i]*h[i] - h[i+m]*h[i+m]) } } double xx=T[0][n-1] return xx } public static double[] df(f_xj f,double xxi[]) { //Gredyen vektörü // f(x0,x1,x2,...xn) founksiyonunun türev vektörü // [df/dx0, df/dx1,df/dx2,....,df/dxn] // df/dxj j=0...x.length // // bu fonksiyon bilgisayar tarafından hesaplanmaktadır // kullanıcı tarafından tanımlanan f(x) fonksiyonunun // sayısal olarak alınan türevidir. { T[i][m]=(h[i]*h[i]*T[i+1][m-1] h[i+m]*h[i+m]*T[i][m-1])/(h[i]*h[i] - h[i+m]*h[i+m]) } } double xx=T[0][n-1] return xx } public static double[] turev(f_xj f_deriv,double x[]) { // df/dxj j=0...x.length // This method calculates turev of a function with more than one independent variable. Math.abs(a) -Math.abs(a)) } public static double MAX(double a,double b) {return (a > b . a b) } ax cx) b=((ax > cx) . ax cx) a-x b-x)) } u=(Math.abs(d) >= tol1 . Çıktı 6.10-2 Lineer olmayan eğri uydurma örneği // kullanıcının türev fonksiyonu tanımlaması gerekmez import java.util. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. * import java.io. public static double[] multiply(double left,double[] right) Math.abs(a) -Math.abs(a)) } public static double MAX(double a,double b) {return (a > b . a b) } public static double[] df(f_xj f,double xxi[]) { //Gredyen vektörü // f(x0,x1,x2,...xn) founksiyonunun türev vektörü // [df/dx0, df/dx1,df/dx2,....,df/dxn] // df/dxj j=0...x.length // // bu fonksiyon bilgisayar tarafından hesaplanmaktadır // kullanıcı tarafından tanımlanan f(x) fonksiyonunun // sayısal olarak alınan türevidir. // double a[]=new double[xxi.length] for(int i=0 i<xxi.length i++) { a[i]=dfdx(f,xxi,i) } return a } Çıktı 6.10-3 Lineer olmayan eğri uydurma örneği, Süreklilik metodu kullanılarak Genetik algoritmalar optimizasyon metodu kullanarak Program 6.10-4 Lineer olmayan eğri uydurma , Genetik algoritma metodu import java.io. * import javax.swing. * class fa extends f_xj { double xi[] // independent variable data set double yi[] //dependent variable data set double a[] //fit function coefficient set int nn public fa(String filename,double ia[]) { //read the data to curvefit //get the data file and initial fit coefficient when class is defined xi=new double[500] yi=new double[500] int n=ia.length a=new double[n] seta(ia) int i=-1 try{ BufferedReader fin=new BufferedReader(new FileReader(filename)) try { while(fin .= null) Çıktı 6.10-4 Lineer olmayan eğri uydurma , Genetik algoritma metodu Genetik algoritma metodunun maksimum bulan bir metod olduğunu, ve bu yüzden de – işaretiyle ters olarak çağrıldığını burada tekrar hatırlatmak istiyoruz. Bu bölümde son olarak çok değişkenli ve katsayıları lineer olmıyan fonksiyonlara eğri uydurmamız gerektiğinde ne yapacağımıza değinelim. Lineer fonksiyonlarda hatırlıyacağınız gibi genel en küçük kareler metodunu metodu değiştirmeden sadece fonksiyonların oluşum prosesini kullanarak çok boyutlu fonksiyonlar için de kullanabileceğimizi anlatmıştık. Aynı şekilde lineer olmıyan metodlarımızı da çok boyutlu fonksiyonların eğri uydurmasında sadece fonksiyonu oluşturma sistemini değiştirerek olşturabiliriz. Verisini alalım. Eğri uydurmak istediğimiz fonksion da double pi=x[1]*ai[0]*(1.0-Math.exp(-ai[1]*x[0])) şeklinde olsun. burada ai katsayılar vektörü x[0] ve x[1] bağımsız değişkenlerdir. Veriye incelediğimizde üstteki örneklerle aynı katsayıları vermesi gerektiğini görebiliriz. Örneğimizi süreklilik optimizasyon metoduyla vereceğiz, ama daha önce de belirttiğimiz gibi tüm optimizasyon metodlarını kullanabiliriz. // kullanıcının türev fonksiyonu tanımlaması gerekmez import java.util. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. * import java.io. * } Math.abs(a) -Math.abs(a)) } public static double MAX(double a,double b) {return (a > b . a b) } public static double[] df(f_xj f,double xxi[]) { //Gredyen vektörü // f(x0,x1,x2,...xn) founksiyonunun türev vektörü // [df/dx0, df/dx1,df/dx2,....,df/dxn] // df/dxj j=0...x.length // // bu fonksiyon bilgisayar tarafından hesaplanmaktadır // kullanıcı tarafından tanımlanan f(x) fonksiyonunun // sayısal olarak alınan türevidir. // double a[]=new double[xxi.length] for(int i=0 i<xxi.length i++) { a[i]=dfdx(f,xxi,i) } return a } Çıktı 6.10-5 Lineer olmayan eğri uydurma , birden fazla bağımsız değişken için olan versiyon, Süreklilik optimizasyon metodu kullanılarak çözüm Aynı programı Nelder-Mead optimizasyon metodu kullanarak oluşturacak olursak Program 6.10-6 Lineer olmayan eğri uydurma , birden fazla bağımsız değişken için olan versiyon, NelderMead optimizasyon metodu kullanılarak çözüm import java.io. * import javax.swing. * class fxa extends f_xj { double xi[][] // m independent variable data set double yi[] //dependent variable data set double a[] //fit function coefficient set int nn //number of data int m //number of idependent variables xi public fxa(String filename,double ia[]) { //read the data to curvefit //last column is treated as independent data set //get the data file and initial fit coefficient when class is defined int n=ia.length a=new double[n] seta(ia) double b[][]=Text.readDoubleT(filename) m=b.length-1 yi=b[m] nn=yi.length //System.out.println( m= +m) xi=new double[m][nn] for(int i=0 i<m i++) {xi[i]=b[i] } yi=b[m] //System.out.println( b=\n +Matrix.toString(Matrix.T(b))) System.out.println( xi=\n +Matrix.toString(xi)) System.out.println( yi=\n +Matrix.toString(yi)) nn=yi.length a=ia } public void seta(double ia[]) { //assign new fit coefficient set for(int ii=0 ii<nn ii++) a[ii]=ia[ii] } public double[] geta() { // return fit coefficient set return a } double Ps(double x[],double ai[]) { // sample specific function m dimensional independent variable // independent variables x[0],x[1]...x[m-1] a=ai double pi=x[1]*ai[0]*(1.0-Math.exp(-ai[1]*x[0])) return pi //kPa } public double func(double ai[]) { double ff=0 Çıktı 6.10-6 Lineer olmayan eğri uydurma , birden fazla bağımsız değişken için olan versiyon, NelderMead optimizasyon metodu kullanılarak çözüm İkinci bir örnek olarak gerçek bir mühendislik problemini inceleyelim Bir araştırma problemi olarak dilim olarak kesilmiş elmanın ısı pompası kullanılarak kurutulması incelenmektedir. Verimiz t zaman(saat), h dilim kalınlığı (mm) ve P ürünün kalan nem oranı(kg nem/kg yaş elma nemi) olarak lineer olmayan aşağıdaki formda bir eğri uydurulmak istenmektedir. a=a0+a1h k=a2+a3h 1.000 0.736 0.603 0.482 0.390 0.307 0.245 0.192 0.143 0.108 0.081 0.059 0.044 1.000 0.765 0.649 0.541 0.456 0.382 0.332 0.276 0.229 0.192 0.160 0.128 0.102 0.083 0.067 0.055 0.046 1.000 0.824 0.718 0.618 0.542 0.474 0.424 0.372 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 0.328 0.287 0.251 0.218 0.185 0.161 0.138 0.117 0.101 0.086 0.071 0.063 0.056 0.051 0.045 Şeklindedir. Bu veriye üstteki denkleme uygun veri uyduralım. Program 6.10-7 Lineer olmayan eğri uydurma , birden fazla bağımsız değişken için olan versiyon, NelderMead optimizasyon metodu kullanılarak çözüm, elma kurutma problemi import java.io. * import javax.swing. * class fxa extends f_xj { double xi[][] // m independent variable data set double yi[] //dependent variable data set double a[] //fit function coefficient set int nn //number of data int m //number of idependent variables xi double xmax public fxa(String filename,double ia[]) { //read the data to curvefit //last column is treated as independent data set //get the data file and initial fit coefficient when class is defined int n=ia.length a=new double[n] seta(ia) xmax=-1.0e99 double b[][]=Text.readDoubleT(filename) m=b.length-1 yi=b[m] nn=yi.length //System.out.println( m= +m) xi=new double[m][nn] for(int i=0 i<nn i++) { xi[0][i]=b[0][i] if(xi[0][i]>xmax) {xmax=xi[0][i] } xi[1][i]=b[1][i] yi[i]=b[m][i] } //System.out.println( b=\n +Matrix.toString(Matrix.T(b))) System.out.println( xi=\n +Matrix.toString(xi)) System.out.println( yi=\n +Matrix.toString(yi)) nn=yi.length a=ia } public void seta(double ia[]) { //assign new fit coefficient set for(int ii=0 ii<nn ii++) a[ii]=ia[ii] } public double[] geta() { // return fit coefficient set return a } double Ps(double x[],double ai[]) { // sample specific function m dimensional independent variable // independent variables x[0],x[1]...x[m-1] // x[0] t // x[1] kalınlık // ai[0] a // a=ai double t=x[0] double h=x[1] double a=ai[0]+ai[1]*h double k=ai[2]+ai[3]*h double pi=a*Math.exp(-k*t) return pi //kPa } public double func(double ai[]) { double ff=0 double w double yy double xx[]=new double[xi.length] for(int i=0 i<nn i++) { for(int j=0 j<m j++) {xx[j]=xi[j][i] } w=Ps(xx,ai) yy=yi[i] //System.out.println( x= +xi[i]+ w= +w+ yy= +yy+ ff= +ff) w-=yy ff+=w*w Elde edilen eğri a0= 0.990155880325089 a1= -0.002517036051923 a2= 0.765464843543500 a3= -0.048774936274541 veri ve eğrinin grafik gösterimi Çıktı 6.10-7 Lineer olmayan eğri uydurma , birden fazla bağımsız değişken için olan versiyon, Nelder-Mead optimizasyon metodu kullanılarak çözüm, elma kurutma problemi uyarlaması Bu bölümdeki metodlarımıza lineer olmıyan katsayılı genel en küçük kareler metodu ismini de verebiliriz, temel olarak eğri uydurmak için mümkün olan en genel bir tanımı vermiş olduk. Lineer olmıyan katsayılı eğri uydurma metodlarımızla istersek lineer katsayılı problemleri de çözebileceğimizi de hatırlatalım, ancak lineer olarak tanımlanmış bir setin direk olarak çözülmesinden dolayı tanımı daha kolaydır, lineer olmıyan metodlar yapısı icabı genelde iteratif prosesler kullanır. Bu değerlere bir eğri uydurmaya çalıştığımızda klasik eğri uydurma metodlarının cevap vermediğini göreceğiz. Çünki aynı x noktasına karşı gelen 1 den fazla y verisi bulunmaktadır. Bu durumda bir eğri uydurmak istediğimizde sete suni bir ek parametre ilave edebiliriz. Örneğin tablodaki t parametresini ilave edelim. (t,x) ve (t,y) tekrarlanmayan iki eğri seti olduğundan bu iki sete eğri uydurmamız mümkün olabilecektir. Bunu yaptıktan sonra değerlendirme aşamasında seti tekrar (x,y) setine dönüştürebiliriz. Program 6.11-1 İndirek parametrik değişken kullanımı, şerit interpolasyonu İmport java.io. * import javax.swing. * class SCO11F3 { public static double [] thomas(double a[][],double r[]) { // int n=a.length double f[]=new double[n] double e[]=new double[n] double g[]=new double[n] double x[]=new double[n] for(int i=0 i<n i++) {f[i]=a[i][i] } for(int i=0 i<(n-1) i++) {g[i]=a[i][i+1] } for(int i=0 i<(n-1) i++) {e[i+1]=a[i+1][i] } for(int k=1 k<n k++) {e[k]=e[k]/f[k-1] f[k]=f[k]-e[k]*g[k-1] } for(int k=1 k<n k++) {r[k]=r[k]-e[k]*r[k-1] } x[n-1]=r[n-1]/f[n-1] for(int k=(n-2) k>=0 k--) {x[k]=(r[k]-g[k]*x[k+1])/f[k] } return x } public static double [] thomas(double f[],double e[],double g[],double r[]) { int n=f.length double x[]=new double[n] for(int k=1 k<n k++) {e[k]=e[k]/f[k-1] f[k]=f[k]-e[k]*g[k-1] } for(int k=1 k<n k++) {r[k]=r[k]-e[k]*r[k-1] } x[n-1]=r[n-1]/f[n-1] for(int k=(n-2) k>=0 k--) {x[k]=(r[k]-g[k]*x[k+1])/f[k] } return x } Çıktı 6.11-1 İndirek parametrik değişken kullanımı, şerit interpolasyonu  a (jm)   k 0  m olarak tanımlamış ve bu denklemi ağırlık fonksiyonu wi=1=sabit olmak üzere çözmüştük. Bu çözümde polinomun üssünü artırmanın her zaman için çözüm vermediğini görebiliriz. Örneğin x f 1.47 2.09 1.83 1.92 3.02 2.19 3.56 2.64 5.86 3.19 8.75 3.13 Verisine en küçük kareler polinom metodu ile 3.üncü,4üncü ve 5inci dereceden eğriler uyduralım. * import javax.swing. 9.45 3.61 public static double[][] funcEKK(double xi[],double yi[],int polinomkatsayisi,int aradegersayisi) { //aradegersayisi x--o--o--x--o--o--x zincirinde x deneysel noktalar ise // ara değer sayısı 2 dir int n=xi.length int nn=(n-1)*(aradegersayisi+1)+1 double z[][]=new double[2][nn] double E[]=EKK(xi,yi,polinomkatsayisi) System.out.println( katsayılar +Matrix.toStringT(E)) double dx=0 int k=0 int i for(i=0 i<(n-1) i++) {z[0][k]=xi[i] z[1][k]=funcEKK(E,z[0][k]) k++ for(int j=0 j<aradegersayisi j++) {dx=(xi[i+1]-xi[i])/((double)aradegersayisi+1.0) z[0][k]=z[0][k-1]+dx z[1][k]=funcEKK(E,z[0][k]) k++ } } z[0][k]=xi[i] z[1][k]=funcEKK(E,z[0][k]) return z } Burada tüm eğriler birbirinden farklı sonuçlar vermiştir, peki hangisi daha doğrudur. Bunu kestirmemiz her zaman için çok kolay olmıyacaktır. Burada uygulayabileceğimiz değişik bir yaklaşım da sürekli değişebilir bir ağırlık fonksiyonunu uygulamaktır. Örneğin ağırlık fonksiyonu olarak x'in fonksiyonu olarak değişen wi ( x)  1 x  xi k gibi bir fonksiyon alabiliriz. Böyle bir fonksiyonda x  xi olduğunda wi (x)   olduğu görülmektedir. Yalnız bu durumda wi(x) x in fonksiyonu olarak değiştiğinden her nokta için katsayı matrisini tekrar hesaplamamız gerekecektir. Bu yüzden hareket halindeki bir en küçük kareler metodu oluşturmuş olacağız. Bu şartlarda en küçük kareler metodumuzu oluşturduğumuzda üstte verdiğimiz sabit en küçük kareler algoritması aşağıdaki forma dönüşecektir Program 6.12-2 Hareket halinde en küçük kareler polinom metodu ile eğri uydurma import java.io. * import javax.swing. double dx=0 int k=0 int i for(i=0 i<(n-1) i++) {z[0][k]=xi[i] z[1][k]=hareketliEKK(z[0][k],xi,yi,polinomkatsayisi,kk) k++ for(int j=0 j<aradegersayisi j++) {dx=(xi[i+1]-xi[i])/((double)aradegersayisi+1.0) z[0][k]=z[0][k-1]+dx z[1][k]=hareketliEKK(z[0][k],xi,yi,polinomkatsayisi,kk) k++ } } z[0][k]=xi[i] z[1][k]=hareketliEKK(z[0][k],xi,yi,polinomkatsayisi,kk) return z } z1\n +Matrix.toString(z1)) Plot pp=new Plot(z1[0],z1[1]) pp.setPlabel( hareketli En küçük kareler yöntemi eğri uydurma ) pp.setXlabel( x ) pp.setYlabel( y ) pp.setPlotType(0,0) pp.addData(x,y) pp.setPlotType(1,21) pp.plot() } } Aynı veriye hareketli en küçük kareler metodunu uydurduğumuzda 4. dereceden polinom kullanarak ve ağırlık fonksiyonu olarak wi ( x)  1 x  xi 2 fonksiyonunu alarak Çıktı 6.12-2 Hareket halinde 4. dereceden en küçük kareler polinom metodu ile eğri uydurma Bu metodun en büyük dezavantajı her nokta için matris sistemimizi çözmek zorunda olmamızdır. Metoddaki temel tanımdan dolayı veri tüm noktalardan tam olarak geçmektedir, bu da en küçük kareler yöntemindeki deneysel veri hatalarını düzeltme avantajını yok edebilir.  n Bn ( f x)    ( x  a)i (b  x) n i f ( xi ) i 0  i  n şeklinde tanımlanır. Buradaki xi sabit aralıklar için xi=a+ih=a+(i/n)(b-a) i=0..n formunda yazılabilir. i Bernsttein polinomlarını direk olarak fonksiyon yaklaşımı olarak kullandığımızda dönüşüm oranlarının çok düşük olduğunu, tam bir yaklaşım için pratik olmıyan çok fazla iterasyon gerektiğini gözlemleriz. Bu polinomlar verilen ilk ve son noktalardan tam olarak geçerlerken orta noktalara daha yavaş yakınsarlar, ancak orta noktaları sadece çizmek istediğimiz eğri için bir referans noktası olarak düşünür isek oldukça pratik bir çizim eğri oluşturma yöntemi elde ederiz. Bu yönteme Bezier eğrileri ismi vereceğiz. Bezier eğrilerinde daha önce kullandığımız indirek referanslama yöntemi kullanılır ve böylece genel bir eğri elde etme metodu oluşturulmuş olur. Herhangi bir (xi,yi) veri seti için 0 ile 1 arasında değişen bir t değişkeni kabul edersek (x0,y0) ve (x1,y1) arasında n denklem setini (Bezier eğrisini) tanımlayabiliriz. Aynı kavramı kullanarak daha üst boyutlu eğrileri de oluşturmak oldukça basit bir denklem seti üzerinden mümkün olur. Örnek problem olarak -1.0000000000 0.0000000000 -0.6666666667 0.6666666667 -0.3333333333 0.6666666667 0.3333333333 -0.6666666667 0.6666666667 -0.6666666667 1.0000000000 0.0000000000 0.6666666667 0.3333333333 -0.3333333333 -0.6666666667 -1.0000000000 0.6666666667 0.6666666667 -0.6666666667 -0.6666666667 0.0000000000 verisini kullanarak bir Bezier eğrisi oluşturalım. Bezier eğrisinde eğrinin ilk ve son noktadan geçtiğini diğer noktaların referans noktaları olduğunu tekrar hatırlatalım. Program 6.13-1 başlangıç, bitiş ve referans noktaları kullanarak Bezier eğrisi uydurma import java.io. * import javax.swing. z1\n +Matrix.toString(Matrix.T(z1))) Plot pp=new Plot(z1[0],z1[1]) pp.setPlabel( Bezier yöntemi eğri uydurma ) pp.setXlabel( x ) pp.setYlabel( y ) pp.setPlotType(0,0) pp.addData(x,y) pp.addData(x,y) pp.setPlotType(2,18) pp.plot() } } Çıktı 6.13-1 başlangıç, bitiş ve referans noktaları kullanarak Bezier eğrisi uydurma Referans noktalarını değiştirerek kompleks eğrileri çizmek mümkündür. eğrisini oluştururken 00 35 52 30 5 -2 3 -5 00 Çıktı 6.13-3 başlangıç, bitiş ve referans noktaları kullanarak Bezier eğrisi uydurma eğrisini oluşturacaktır. Bu iki eğri arasında sadece bir referans noktasını değiştirdik. Bu şekilde az sayıdaki referans noktası ile daha kompleks şekillerde elde edebiliriz. Çıktı 6.13-4 başlangıç, bitiş ve referans noktaları kullanarak iki parelel Bezier eğrisi ile kelebek şekli tanımlanması Eğer uydurduğumuz eğrinin hata seviyesi istediğimiz sınırlara düşemiyorsa hata seviyesini düşürmenin yollarından birisi devamlı tek bir fonksiyon yerine kısmı devamlı bir fonksiyon ailesi uydurmaktır. Her fonksiyon yeterince küçük parçalara ayrıldığında lineere yaklaşacağından hata miktarı da tek bir fonksiyon uydurmaya göre otomatik olarak azalır. Yöntem matematiksel olarak tek bir eğri uydurma ile aynıdır. Temel far burada bir eğri ailesinin olmasıdır. Bu tür bir eğri uydurmada doğal olarak her eğrinin geçerli olduğu minimum ve maksimum sınırların da tanımlanmış olması gereklidir. Veri olarak Azot gazının Cp değerlerini (kJ/kg K) alalım 298.15 300 400 500 600 700 800 29.123 29.125 29.246 29.583 30.113 30.752 31.43 1800 1900 2000 2100 2200 2300 2400 35.598 35.794 35.969 36.126 36.267 36.395 36.511 3500 3600 3700 3800 3900 4000 4100 37.324 37.373 37.42 37.464 37.507 37.548 37.588 900 1000 1100 1200 32.094 32.696 33.24 33.723 1300 1400 1500 1600 1700 34.148 34.519 34.844 35.128 35.378 2500 2600 2700 2800 2900 3000 3100 3200 3300 3400 36.616 36.713 36.802 36.884 36.961 37.031 37.097 37.159 37.217 37.272 4200 4300 4400 4500 4600 4700 4800 4900 5000 37.627 37.665 37.701 37.737 37.773 37.808 37.842 37.877 37.911 Bilgisayar programı olarak daha önce gördüğümüz genelleştirilmiş en küçük kareler yöntemini kullanacağız, ancak bu versyonumuzda program veriyi istediğimiz alt veri parçalarına bölerek ayrı ayrı eğri uyduracaktır. * import java.util. * import javax.swing. public double viscosity_l(double t) {return funcEKKgenel(f2,visl,t) } public double k_l(double t) {return funcEKKgenel(f2,kl,t) } Çıktı 6.14.1 . N2 (AZOT) Cp Özgül ısı kısmi devamlı polinom katsayıları 12 denklem Ai Bi Ci Di TLi THi 29.48410467 -4.39231362 0.135791768 8.962719183 19.58127458 18.1244325 6.04125597 -5.613346914 25.58318122 9.820000158 -3.406728392 -2.366536137 31.97208934 3.568391773 -23.39157514 -0.640497282 33.95938165 1.99152595 -32.75504611 -0.288631316 37.66790853 -0.18797764 -64.90671398 0.073070085 32.38982337 2.448472237 -1.808705885 -0.298231241 37.37149772 0.104842902 -68.56025763 0.011860004 34.09434238 1.362910336 -2.482405204 -0.124112185 298.2 600 1000 1400 1800 2200 2600 3000 3400 600 1000 1400 1800 2200 2600 3000 3400 3800 42.95067177 -1.76724832 -214.1109621 0.18778721 56.98821926 -5.88637732 -689.7268107 0.525601294 36.43273733 0.299350851 -15.74029559 0.001781188 3800 4200 4600 4200 4600 5000 Çıktı 6.14-2 12 kısmi devamlı denklem olarak uydurulmuş eğri ve verinin görünümü Aynı veri 6 kısmi devamlı eğriye uydurulacak olursa Çıktı 6.14.3 12 kısmi devamlı denklem olarak uydurulmuş verinin hata miktarının görünümü Ai Bi Ci Di TLi THi 25.49891 28.52807 34.95458 36.85793 38.84858 38.12276 7.210171 6.592687 1.329468 0.31981 -0.40481 -0.15113 1.329118 -10.4511 -39.3578 -59.869 -104.123 -85.9557 -0.11578 -1.38176 -0.16512 -0.01345 0.060592 0.03551 298.15 1000 1800 2600 3400 4200 1000 1800 2600 3400 4200 5000 Çıktı 6.14.4. N2 (AZOT) Cp Özgül ısı kısmi devamlı polinom katsayıları 6 denklem Eğer sadece 1 eğri kullanırsak (sürekli fonksiyon) Çıktı6.14.7 N2(AZOT) Cp Özgül ısı devamlı polinom Ai Bi 28.87568 4.485071 Ci -1.318301 Di -0.5604611 TLi 298.15 THi 5000 Grafik formdaki sonuçlar incelendiğinde kısmi devamlı fonksiyoların hata miktarı üzerindeki etkileri açık olarak görülmektedir. Hata miktar kontrollu eğri uydurma gerktiğinde kısmi devamlı fonksiyonlar önemli bir alternatif olarak karşımıza çıkmaktadır. X Y 5 3 Bu değerler alttaki tabloda tanımlanmıştır. Bu veriyi bilgisayara aktarabileceğimiz bir egri uydurunuz, eğrinin hata miktarını hesaplayınız, daha iyi bir eğri oluşturabilmak için (hata miktarını azaltmak için) kullanabileceğiniz diğer yöntemleri tartışınız, mümkünse uygulayınız. -101.1111111 -95.55555556 -90 -84.44444444 -78.88888889 -73.33333333 -70.55555556 -67.77777778 -65 -62.22222222 -59.44444444 -56.66666667 -53.88888889 -51.11111111 -48.33333333 -45.55555556 -42.77777778 -40.81111111 -40 -37.22222222 -34.44444444 -31.66666667 8.6519780084E-04 7.7466826506E-04 6.9943367368E-04 6.3536025795E-04 5.8079451036E-04 5.3325616965E-04 5.1176057211E-04 4.9150510520E-04 4.7290314580E-04 4.5512794014E-04 4.3817948824E-04 4.2205779009E-04 4.0717622256E-04 3.9312140879E-04 3.7947997189E-04 3.6666528874E-04 3.5426398247E-04 3.4599644496E-04 3.4268942995E-04 3.3152825431E-04 3.2078045554E-04 3.1044603365E-04 -28.88888889 -26.11111111 -23.33333333 -20.55555556 -17.77777778 -15 -12.22222222 -9.444444444 -6.666666667 -3.888888889 -1.111111111 1.666666667 4.444444444 7.222222222 10 12.77777778 15.55555556 18.33333333 21.11111111 23.88888889 26.66666667 29.44444444 3.0093836551E-04 2.9143069737E-04 2.8233640610E-04 2.7365549171E-04 2.6538795420E-04 2.5712041668E-04 2.4926625605E-04 2.4182547228E-04 2.3479806540E-04 2.2777065851E-04 2.2074325162E-04 2.1412922161E-04 2.0792856848E-04 2.0172791534E-04 1.9552726220E-04 1.8973998595E-04 1.8395270969E-04 1.7857881030E-04 1.7320491092E-04 1.6783101153E-04 1.6287048902E-04 1.5749658964E-04 32.22222222 35 37.77777778 40.55555556 43.33333333 46.11111111 48.88888889 51.66666667 54.44444444 57.22222222 60 62.77777778 65.55555556 68.33333333 71.11111111 73.88888889 76.66666667 79.44444444 82.22222222 85 87.77777778 90.55555556 93.33333333 1.5253606713E-04 1.4798892150E-04 1.4302839899E-04 1.3848125336E-04 1.3393410773E-04 1.2938696209E-04 1.2483981646E-04 1.2070604770E-04 1.1615890207E-04 1.1202513331E-04 1.0747798768E-04 1.0334421892E-04 9.9210450167E-05 9.5076681410E-05 9.0529535778E-05 8.6395767021E-05 8.1848621388E-05 7.7714852631E-05 7.2754330123E-05 6.8207184490E-05 6.2833285106E-05 5.7046008846E-05 5.0018601959E-05 Bu değerler tabloda tanımlanmıştır. Bu veriyi bilgisayara aktarabileceğimiz bir egri uydurunuz, eğrinin hata miktarını hesaplayınız, daha iyi bir eğri oluşturabilmak için (hata miktarını azaltmak için) kullanabileceğiniz diğer yöntemleri tartışınız, kaynakları araştırarak doyma eğrilerinde kullanılan en uygun eğri denklemini bulunuz, mümkünse bu denklemi kullanarak eğri uydurunuz. -99 -98 -97 -96 -95 -94 -93 -92 -91 -90 -89 -88 -87 -86 -85 -84 0.01 0.01 0.01 0.01 0.01 0.02 0.02 0.02 0.03 0.03 0.04 0.04 0.05 0.06 0.07 0.08 -49 -48 -47 -46 -45 -44 -43 -42 -41 -40 -39 -38 -37 -36 -35 -34 2.06 2.21 2.37 2.54 2.72 2.91 3.11 3.32 3.54 3.78 4.03 4.29 4.57 4.86 5.17 5.5 32.73 34.24 35.81 37.43 39.12 40.86 42.67 44.54 46.48 48.49 50.57 52.72 54.94 57.23 59.61 62.06 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 212.61 219.24 226.02 232.96 240.07 247.33 254.77 262.38 270.15 278.1 286.23 294.54 303.03 311.7 320.57 329.62 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 786.93 804.64 822.65 840.96 859.56 878.47 897.69 917.22 937.07 957.23 977.71 998.52 1019.66 1041.12 1062.92 1085.05 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 2100.93 2137.75 2175.06 2212.87 2251.19 2290.01 2329.35 2369.21 2409.61 2450.54 2492.01 2534.04 2576.63 2619.8 2663.54 2707.88 -83 -82 -81 -80 -79 -78 -77 -76 -75 -74 -73 -72 -71 -70 -69 -68 -67 -66 -65 -64 -63 -62 -61 -60 -59 -58 -57 -56 -55 -54 -53 -52 -51 -50 -33 -32 -31 -30 -29 -28 -27 -26 -25 -24 -23 -22 -21 -20 -19 -18 -17 -16 -15 -14 -13 -12 -11 -10 -9 -8 -7 -6 -5 -4 -3 -2 -1 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 64.59 67.2 69.9 72.68 75.55 78.52 81.57 84.71 87.95 91.29 94.73 98.27 101.92 105.66 109.52 113.49 117.57 121.76 126.07 130.49 135.04 139.71 144.51 149.43 154.48 159.66 164.98 170.43 176.03 181.76 187.63 193.65 199.82 206.14 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 338.86 348.3 357.93 367.77 377.81 388.05 398.5 409.17 420.04 431.13 442.45 453.98 465.74 477.72 489.93 502.38 515.06 527.98 541.15 554.55 568.21 582.11 596.27 610.68 625.35 640.28 655.47 670.94 686.67 702.68 718.96 735.53 752.38 769.51 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 1107.52 1130.35 1153.52 1177.04 1200.91 1225.15 1249.75 1274.71 1300.04 1325.74 1351.82 1378.28 1405.13 1432.36 1459.98 1488 1516.41 1545.23 1574.46 1604.1 1634.15 1664.62 1695.52 1726.84 1758.6 1790.79 1823.42 1856.5 1890.03 1924.01 1958.46 1993.37 2028.74 2064.6 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 2752.81 2798.36 2844.54 2891.36 2938.83 2986.97 3035.81 3085.29 3135.59 3186.64 3238.47 3291.12 3344.62 3399.02 3454.38 3510.78 3568.29 3627.05 Bu değerlere bir eğri uydurmaya çalıştığımızda klasik eğri uydurma metodlarının cevap vermediğini göreceğiz. Çünki aynı x noktasına karşı gelen 1 den fazla y verisi bulunmaktadır. Bu durumda bir eğri uydurmaki istediğimizde sete suni bir ek parametre ilave edebiliriz. Örneğin tablodaki t parametresini ilave edelim. (t,x) ve (t,y) tekrarlanmayan iki eğri seti olduğundan bu iki sete eğri uydurmamız mümkün olabilecektir. Bunu yaptıktan sonra değerlendirme aşamasında seti tekrar (x,y) setine dönüştürebiliriz. Bu veriye eğri uyduracak bir program hazırlayınız. 0 0 -1 0 Verisine a) en küçük kareler yöntemiyle b) interpolasyon yöntemlerini kullanarak eğri uydurunuz. Uydurduğunuz eğriyi çizerek kontrol ediniz. Verisine kübik şerit interpolasyonu uydurunuz. Verisine kübik şerit interpolasyonu uydurunuz. . Formül olarak (x,t)= a0+a1*x+a2*t+a3*x2+a4*t2+a5*xt+a6*x3+a7*t3+a8*x2t +a9*xt2+a10*x4+a11*t4+a12*x2t2+a13x3t+a14*xt3 kullanılacaktır. Buradaki formülden de görüldüğü gibi bu özellikler x ve t nin fonksiyonudurlar ve veri de bu şekilde verilmiştir. Eğrinin uyum verimi yeterlimidir. Değilse formül ile oynıyarak daha iyi uyan bir formülü deneyiniz. x %hacim oranı etilen glikol konsantrasyonu t sıcaklık C 60% 70% 80% 90% -35 0% 10% 20% 30% 40% 1090 1105 1119 1132 -30 1089 1104 1117 1131 -25 50% 1088 1102 1116 1129 1142 -20 1072 1087 1101 1115 1128 1140 -15 1071 1086 1100 1113 1126 1138 1054 1070 1084 1098 1111 1124 1136 -10 -5 1037 1053 1068 1083 1096 1109 1122 1134 0 999.8 1019 1036 1052 1067 1081 1095 1108 1120 1132 5 999.9 1018 1034 1050 1065 1079 1093 1105 1118 1129 10 999.7 1016 1033 1049 1063 1077 1091 1103 1115 1127 15 999.1 1015 1031 1047 1062 1075 1089 1101 1113 1124 20 998.2 1013 1030 1045 1060 1073 1086 1098 1110 1121 25 997 1012 1028 1043 1058 1071 1084 1096 1107 1118 30 995.6 1010 1026 1041 1055 1069 1081 1093 1105 1115 35 994 1008 1024 1039 1053 1066 1079 1090 1102 1112 40 992.2 1006 1022 1037 1051 1064 1076 1088 1098 1109 45 990.2 1004 1020 1034 1048 1061 1073 1084 1095 1106 50 988 1002 1017 1032 1045 1058 1070 1081 1092 1102 55 985.7 999.2 1015 1029 1043 1055 1067 1078 1088 1098 60 983.2 996.7 1012 1026 1040 1052 1064 1075 1085 1095 65 980.5 994.1 1009 1023 1037 1049 1060 1071 1081 1091 70 977.7 991.4 1006 1020 1033 1045 1057 1067 1077 1087 75 974.8 988.5 1003 1017 1030 1042 1053 1064 1073 1083 80 971.8 985.5 1000 1014 1027 1038 1049 1060 1069 1078 85 968.6 982.4 997 1011 1023 1035 1046 1056 1065 1074 90 965.3 979.2 993.6 1007 1019 1031 1042 1052 1061 1070 95 961.9 975.8 990.1 1003 1016 1027 1038 1047 1056 1065 100 958.3 972.3 986.5 999.7 1012 1023 1033 1043 1052 1060 105 954.7 968.7 982.8 995.8 1008 1019 1029 1038 1047 1055 110 950.9 965 978.9 991.8 1004 1014 1025 1034 1042 1050 115 947.1 961.2 974.9 987.7 999.3 1010 1020 1029 1038 1045 120 943.1 957.2 970.8 983.4 994.9 1005 1015 1024 1032 1040 125 939 953.1 966.6 979.1 990.4 1001 1010 1019 1027 1035 Doğal kübik şerit interpolasyonu kullanarak CD değerini Re = 5, 50, 500 and 5000 değerleri için bulunuz. Not Logaritmik skala kullanabilirsiniz. Re 0.2 2 20 200 2000 20 000 cD 103 13.9 2.72 0.800 0.401 0.433 kanalın derinlik ve su hızı verisi aşağıdaki tabloda verilmiştir. 0 0 0 20 0 0 0 0 5 10 15 20 25 -1 derinlik m -2 -3 Seri 2 -4 -5 -6 -7 sol kıyıdan uzaklık m 0 90 5 55 10 40 15 28 20 24 25 22 30 21.5 35 20.6 Şeklinde verilmiştir. t=13 sn ve t=23 sn t=33 sn, t=43sn ve t=53 sn deki sıcaklık dağılımını bulunuz. Kullanacağınız yöntemler size bırakılmıştır . Son 2 değer için tahmin değerlerinizi ne şekilde bulacağınız konusunda özellikle dikkatli olunuz. Verilen şekle bir eğri uydurunuz. Xi 241 258 283 307 322 333 334 yi 127 107 96 97 106 120 138 Xi 331 323 312 298 283 267 241 yi 157 178 197 217 232 246 258 Xi 215 199 184 170 159 151 148 yi 246 232 217 197 178 157 138 xi 149 160 175 199 224 241 Yi 120 106 97 96 107 127 Not Aynı değerler yinelenmektedir. Bu ilişki aşağıdaki tabloda verilmiştir. Hız (km/h) 24 32 40 48 Durma mesafesi (m) 4.8 6.0 10 12 Newton interpolasyon polinomunu kullanarak hesaplayınız. Suyun sıcaklıkla ısıl iletkenlik katsayısının değişimi için aşağıdaki tablodaki veriler bilinmektedir. Sıcaklık T . [K] . Isıl iletkenlik katsayısı k. [W/(m K)] 275 290 305 320 340 360 0.574 0.598 0.620 0.640 0.660 0.674 a-) Isıl iletkenlik katsayısının sıcaklıkla değişimi için k  AT  B doğrusunu uydurunuz. b-) 300 K sıcaklığı için, suyun ısıl iletkenlik katsayısını tahmin ediniz. Bu verileri kullanarak Pr sayısı ile sıcaklık arasındaki polinom eşitliğini türetiniz ve bu eşitlikten yararlanarak 42 °C sıcaklıktaki Pr sayısını hesaplayınız. Sıcaklık (K) Pr sayısı 280 400 300 151 320 73.5 340 42.8 biçiminde bir kübik eşitlik uydurulmak istenmektedir. Aşağıdaki veriler termodinamik tablolardan alınmıştır. 10 41.99 30 125.66 50 209.26 70 292.97 90 376.94 Burada k yay katsayısı, x ise yaydaki uzamadır. Aşağıdaki tabloda, bir yaya uygulanan kuvvet ve uzama miktarları deney sonuçları verilmiştir. Bu verilere göre yay sabitini tahmin ediniz. 0.02 3.1 0.04 6.1 0.06 9.2 0.08 12 0.1 15.1 X Y -1 13.46 0 3.02 1 0.68 2 0.14 Levha malzemesinin ısı iletim katsayısı k=25 W/m K'dir. Levhanın bir yüzeyi (x=0) 161.5 °C, diğer yüzeyi (x=5 mm) ise 166.9 °C sıcaklıklarında bulunmaktadır. Levha içindeki farklı konumlarda sıcaklık değerleri tabloda verilmiştir. Bu verileri kullanarak Newton interpolasyon polinomunu kullarak levha içindeki sıcaklık dağılımını polinom şeklinde ifade ediniz. X=4 mm düzlemindeki sıcaklık değerini hesaplayınız. x (mm) 0 0.5 2.5 4.5 5.0 T (°C) 161.5 166.9 177.7 171.22 166.9 Bu verilere y hız x yüzeyden mesafe olmak üzere y=a0+a1x+a2x2 polinomunu en küçük kareler yöntemi ile uydurunuz. k xk yk Burada A ve B sabitler , h ,(kJ/kg) olarak entalpi ve T , (oC) olarak sıcaklıktır. h (kJ/kg) T (oC) 2510.6 5 2519.8 10 2528.9 15 2538.1 20 2547.2 25 2556.3 30 2565.3 35 İlişkisi mevcuttur. Motorla ilgili deneysel ölçmeler aşağıdaki tablodaki gibi verilmiştir. F (Nm) I (Amper) 100 8 200 11.31 300 13.85 400 16 Bu ilişkiyi en küçük kareler yöntemi ile belirleyiniz. 22,5 °C'da kuru havanın yoğunluğunu hesaplayınız. 1 2 3 2 2 1 P=f(t) ilişkisi için önerilen eşitliklerden birisi de Dupperet Eşitliği olarak bilinir. Bu eşitlik Pdoyma  t doyma    A  100  4 biçimindedir. Sıcaklıkla su buharının doyma basıncının değişimi ile ilgili aşağıdaki tablodaki değerler verilmektedir. En küçük kareler tekniği ile A katsayısını belirleyiniz. 10 1.2276 30 4.246 60 19.940 90 70.14 110 143.27 140 361.3 180 1002.1 200 1553.8 250 3973 300 8581 340 14586 Levhanın bir yüzeyi (x=0) 161,5 °C, diğer yüzeyi (x=5 mm) ise 166,9 °C sıcaklıklarında bulunmaktadır. Levha içindeki faklı konumlarda sıcaklık değerleri tabloda verilmiştir. Bu verileri kullanarak Newton enterpolasyon yönteminden yararlanarak levha içindeki sıcaklık dağılımını polinom şeklinde ifade ediniz.X= 4 mm düzlemindeki sıcaklık değerini hesaplayınız. İ ti 1 0 2 2 3 4 4 6 370 21030 5,0 xi 3,7 2,7 2,0 Bu makinanın titreşimi için x(t )  aebt biçiminde zamana bağlı bir fonksiyon uydurunuz. Ölçme deneyleri sırasında üstteki levha 2 m/s hızla hareket ettirilirken, alttaki levha ise sabit tutulmaktadır. İki levha arasındaki uzaklık (h) 0,025 m'dir.     (V / h) eşitliği ile hesaplanmaktadır. Laboratuvar çalışması sonucu viskozite ile sıcaklık arasındaki ilişki tablodaki gibi elde edilmiştir. b) Newton interpolasyon polinomlarını kullanarak birinci, ikinci, üçüncü, dördüncü denklemleri ayrı ayrı elde ediniz. En uygun denklemi belirleyiniz. Bu denklemi kullanarak 38 °C'daki viskoziteyi ve kayma gerilimini hesaplayınız. Vizkozitenin sıcaklıkla değişimi için 253 4,0 biçiminde bir eğri uydurunuz. 353 0,0086 373 0,005 Q (lt/s) P (kPa) 0,5 275 1,0 290 1,5 280 2,0 255 2,5 229 3,0 205 3,5 178 a-)Bu değerlere ikinci dereceden bir polinomu[ P=f(Q)=aQ2+bQ+c ] en küçük kareler yöntemi ile uydurunuz. c-) Bu pompa ile en yüksek basınç hangi debide su basılırken oluşur.  kg/m3 0,950 0,748 0,617 0,525 T °C 100 200 300 400 Newton enterpolasyon yöntemini kullanarak 1'den 4'ü dereceye kadar polinom Denklemlerini bulunuz. 285 °C'da yanma gazlarının yoğunluğunu hesaplayınız. Böyle bir cihaz şekilde gösterilmektedir. Aşağıdaki veriler bu orifis tasarımında kullanılmıştır. A Orifis kesit alanı. A1 Boru kesit alanı. Burada Cc büzülme katsayısı (A/A1) oranının bir fonksiyonudur. Bu katsayı için deneysel veriler aşağıda verilmiştir. Bu deneysel verilere uygun bulabileceğiniz en küçük kareler eğrisini [C c=f(A/A1)] uydurunuz. hi'nin belirlenmesi için gerçekleştirilen deneylerde, Nu Nusselt sayısı, Re Reynolds sayısı, Pr Prandtl sayısı, Boyutsuz sayıları arasındaki ilişkiler araştırılır. Burada C ve m belirli aralıklardaki Re ve Pr sayıları için sabitlerdir. Aşağıdaki deney sonuçları için C ve m sabitlerini en küçük kareler yöntemi ile (çoklu regresyon) belirleyiniz. Bu verileri kullanarak yoğunluğun sıcaklıkla değişimini veren denklemleri a-) Newton enterpolasyon yöntemi ve b-) Lagrange yöntemi ile bulunuz.  (kg/m3) T(K) 859.9 340 847.8 360 836.0 380 825.1 400 812.1 420 X Y 1 1 2 1 3 2 4 4 Aşağıdaki veriler termodinamik tablolardan alınmıştır. 10 41.99 30 125.66 50 209.26 70 292.97 90 376.94 X 1 2 3 5 6 f(X) 4,75 4 5,25 19,75 36 a) Newton enterpolasyon yöntemini kullanarak 4'cü derece polinom denklemini elde ediniz. X=4 için bu denklemden fonksiyon değerini elde ediniz. b) Üçüncü derece spline fonksiyonunu ikinci aralık için elde ediniz. Bu denklemi kullanarak X=4 için fonksiyon değerini elde ediniz. En küçük kareler yöntemi kullanarak düz bir doğru (f(x)=a 0+a1x ) geçiriniz. x y 5 16 10 25 15 32 20 33 25 38 30 36 35 3 40 40 45 42 50 42 5 16 10 25 15 32 20 33 25 38 30 36 35 3 40 40 a) =ae(b/T) denkleminine göre vizkozite için bir denklem uydurunuz. 45 42 50 42 5 4 b)  a T denkleminine göre vizkozite için bir denklem uydurunuz b 1 T f ( x)  a) kübik şerit interpolasyonu b) quadratik B-şerit interpolasyonu kullanarak hesaplayınız c) her iki yaklaşım için asıl foksiyondan hata miktarlarını belirleyiniz. Sıcaklık T(K) k (W/m2K) 200 1 600 0.4 1000 0.3 1400 0.25 0.1 210 1 30 10 4 100 1 1000 0.5 10000 0.4 Bu değişkenler arasında veriyi yeterince doğru olarak verecek bir denklem oluşturunuz. şeklini oluşturunuz. şeklini oluşturunuz. 7 f(x) fonksiyonu verilmiş olsun. a ve b noktaları arasındaki integralini sayısal olarak hesaplamak istiyelim. Integral fonksiyonun altındaki alan olduğundan en basit yaklaşım iki noktayı bir doğru ile birleştirip altındaki alanı hesaplamaktır. Bu yaklaşım bize trapez(yamuk) denklemini verir. Şekil 7.1-1 trapez(yamuk) yaklaşımı düz bir doğru altındaki alan yaklaşımı b I   f ( x)dx  (b  a) a f (b)  f (a) 2 Şekil 7.1-2 çoklu trapez (çoklu yamuk) integral yaklaşımı Eğer toplam alanı küçük parçacıklara bölersek hata miktarı azalacaktır. Küçük parçacıklar içn eğri formülü doğru formülüne yaklaşacaktır. Bu durumda integral formülü n 1 I  a f ( x)dx  (b  a) b 2n şeklinde yazılabilir. Örnek fonksiyon olarak I  0 1 4  fonksiyonunu alalım. Fonksiyonun değerini bildiğimiz için karşılaştırma yapabiliriz. Program 7.1-1 Trapezoidal integral kuralı //====================================================== // Numerical Analysis package in java // Newton-Cotes integral formula 4 points , n=3 // trapezoidal rule // Dr. Turhan Coban // ===================================================== import java.io. * class f1 extends f_x { double func(double x) Çıktı 7.1-1 Trapez (yamuk) integral kuralı (0 ile 1 arası tek parça olarak) ---------- Capture Output ---------> C \co\java\bin\java.exe integ6A integral of class f1 0.6366197723675814 hata = 0.3633802276324186 Burada oluşan hatayı görebilmemiz için grafik çıktısını aldık. Grafik çıktıyı alan trapezoidal integral programı Program 7.1-2 Trapezoidal integral kuralı, grafik çizmeli versiyonu //====================================================== // Numerical Analysis package in java // Newton-Cotes integral formula 4 points , n=3 // trapezoidal rule // Dr. Turhan Coban // ===================================================== import java.io. * Çıktı 7.1-2 Trapez (yamuk) integral kuralı (0 ile 1 arası tek parça olarak) integral alanı ve fonksiyon grafik görünümü İntegral bölgesini 2 eşit bölgeye bölerek trapez kuralını uygularsak Çıktı 7.1-3 Trapez (yamuk) integral kuralı (0 ile 1 arası 2 parça olarak) ---------- Capture Output ---------> C \co\java\bin\java.exe integ6A integral of class f1 0.8696387816055828hata = 0.13036121839441717 Çıktı 7.1-4 Trapez (yamuk) integral kuralı (0 ile 1 arası 2 parça olarak) grafik gösterim Trapezi 3 parça olarak hesaplarsak Çıktı 7.1-5 Trapez (yamuk) integral kuralı (0 ile 1 arası 3 parça olarak) ---------- Capture Output ---------> C \co\java\bin\java.exe integ6A integral of class f1 0.9286860839333196hata = 0.07131391606668036 > Terminated with exit code 1. Çıktı 7.1-6 Trapez (yamuk) integral kuralı (0 ile 1 arası 3 parça olarak) grafik gösterim Trapezi 10 parça için hesapladığımızda Çıktı 7.1-7 Trapez (yamuk) integral kuralı (0 ile 1 arası 10 parça olarak) ---------- Capture Output ---------> C \co\java\bin\java.exe integ6A integral of class f1 0.9881988750835945hata = 0.011801124916405503 Trapezi 100 parça olarak hesaplarsak Çıktı 7.1-8 Trapez (yamuk) integral kuralı (0 ile 1 arası 100 parça olarak) ---------- Capture Output ---------> C \co\java\bin\java.exe integ6A integral of class f1 0.9996257879552262hata = 3.742120447738362E-4 Görüldüğü gibi step sayısı arttıkça trapez integral tahmini gerçek sayıya yaklaşıyor. Ancak yeterince iyi bir tahmin için step sayısını oldukça arttırmamız gerekebilir. Daha az step sayısıyla daha iyi integral tahmini yapabilmek için birinci derece polinom(doğru) yerine daha yüksek dereceden polinom formülleri kullanılabilir. I  a f ( x)dx  (b  a) b n 1 n2 i 1, 3, 5 j 2, 4, 6 I  a f ( x)dx  b h (b  a) (b  a)  n 4 I  a f ( x)dx  b beşinci derece polinom formülü n=5, 6 noktalı Newton-Cotes formülü I  a f ( x)dx  b (b  a) [19 f ( x0 )  75 f ( x1 )  50 f ( x2 )  50 f ( x3 )  75 f ( x4 )  19 f ( x5 )] 288 veya n=5 için (b  a) (b  a) h  n 5 I  a f ( x)dx  b 5h [19 f ( x0 )  75 f ( x1 )  50 f ( x2 )  50 f ( x3 )  75 f ( x4 )  19 f ( x5 )] 288 * * Program 7.1-5 4. derece polinom(Boole ) integral kuralı, 1 parça //====================================================== // Numerical Analysis package in java // Newton-Cotes integral formula 5 points , n=4 // Boole formula // Dr. Turhan Coban // ===================================================== import java.io. * çıktı 7.1-10 4. derece polinom(boole) integral kuralı ( 1 parça) ---------- Capture Output ---------> C \co\java\bin\java.exe integ3 integral of class f1 0.9838206253495985 hata=0.016179374650401535 > Terminated with exit code 0. Program 7.1-6 5. derece polinom integral kuralı //====================================================== // Numerical Analysis package in java // Newton-Cotes integral formula 6 points, n=5 // // Dr. Turhan Coban // ===================================================== import java.io. Çıktı 7.1-11 5. derece polinom integral kuralı ---------- Capture Output ---------> C \co\java\bin\java.exe integ2 integral of class f1 0.9872489399864514 hata=0.012751060013548643 > Terminated with exit code 0. Program 7.1-7 8. derece polinom integral kuralı //====================================================== // Numerical Analysis package in java // Newton-Cotes integral formula 9 points, n=8 // // Dr. Turhan Coban // ===================================================== import java.io. * Çıktı 7.1-12 8. derece polinom integral kuralı ---------- Capture Output ---------> C \co\java\bin\java.exe integ2A integral of class f1 0.9952701383291108 hata=0.004729861670889179 > Terminated with exit code 0. İntegral sonuçlarını bir tablo halinde özetlersek Tablo 7.1-1 örnek fonksiyon Newton-Cotes formülleri sonuçlarının karşılaştırılması I  0 1 4  Burada h2, h1 den küçük olmalıdır. I 3 3 İnterpolasyon başlangıcı için polinom yaklaşımlarından birisi kullanılabilir. İteratif formülümüz genel olarak yazılırsa haline gelir. Bu genel denklem başlangıç integral değerleri olarak trapez kuralından başlayarak uygulandığında Romberg integrasyonu adını alır. Program 7.2-1 Romberg integrali //====================================================== // Numerical Analysis package in java // example to show utilisation