Number_of_Data,int Number_of_Function,int ipt[]) public void addFunction(fi_x f,double xmin,double xmax,int Number_of_Data,int Number_of_Function, ================== Settings of additional plot information ================= ----------Plot Type ---------------------public void setPlotType(int plot_type[]) public void setPlotType(int dataset,int plot_no) public void setPlotType(int dataset,char plot_char) ----------x y grid on-off ---------------public void setXgrid(int igx) public void setYgrid(int igy) public void setGrid(int igx,int igy) public void setXtic(int ixt) public void setYtic(int iyt) public void setXYtic(int ixt,int iyt) ---------- Color setting for plot data -------public void setColor(int dataset,int ired,int igreen,int iblue) public void setColor(int ired[],int igreen[],int iblue[]) ================ Setting of Minimum Maximum fuctions =================== public void setMinMax() public void setMinMax(double xi[][],double yi[][]) public void setMinMax(double iminx,double imaxx,double iminy,double imaxy) =============== Plot Window Formatting ================================== public void set_plotwindow(int width,int height,double xip,double yip,double dxp,double dyp) public void setabsMaxMin(int ixmin,int iymin,int idx,int idy) ================ Actual Plotting of constructed data public void plot() */ public static double[] data(double xmin,double xmax,double dx) { int n=(int)((xmax-xmin)/dx)+1 double x[]=new double[n] for(int i=0 i<n-1 i++) {x[i]=xmin+dx*i } x[n-1]=xmax return x } public static double[] data(double xmin,double xmax,int n) { double dx=(xmax-xmin)/n double x[]=new double[n] for(int i=0 i<n i++) {x[i]=xmin+dx*i } return x } public Plot() throws IOException { //read input variables from Plot.txt //adding max-min prompts and input fields //initial values of max and mins // Structure of input file // filename // xlabel // ylabel // nline // datafilename plottype redcolor greencolor bluecolor // ........ // datafilename plottype redcolor greencolor bluecolor // // A sample data file input //========================== // filename public Plot(String pl,String xl,String yl,int xnt,int ynt ,int xgo,int ygo,String fn[],int ipt[],int ir[],int ig[] public Plot(String fn[]) throws IOException { //reading data from file(s) nline=fn.length int ipt[]=new int[nline] int ir[]=new int[nline] int ig[]=new int[nline] int ib[]=new int[nline] xmin=9.99e50 public Plot(double xi[][],double yi[][],int ipt[],int ir[],int ig[],int ib[]) { pp2(xi,yi,ipt,ir,ig,ib) } public void pp2(double xi[][],double yi[][]) { int ir[] int ig[] int ib[] int ipt[] int nn=xi.length ir=new int[nn] ig=new int[nn] ib=new int[nn] ipt=new int[nn] for(int i=0 i<nn i++) { ir[i]=0 xx+=dx } pp1(xi,yi,ipt,ir,ig,ib) } public Plot(f_x f,double xm,double xma,int N,int ipt,int ir,int ig,int ib) { pp3(f,xm,xma,N,ipt,ir,ig,ib) } public Plot(f_x f,double xm,double xma,int N,int ipt) { // reading data from a given function//one data set only int ir=0 int ig=0 int ib=0 pp3(f,xm,xma,N,ipt,ir,ig,ib) } public Plot(f_x f,double xm,double xma,int N) { // reading data from a given function//one data set only int ipt=0 int ir=0 int ig=0 int ib=0 pp3(f,xm,xma,N,ipt,ir,ig,ib) } public void pp4(fi_x f,double xm,double xma,int Number_of_Data,int Number_of_Function,int ipt[],int ir[],int ig[],int ib[]) { // reading data from a given functon set // same xmin xmax and Number_of_data for each function nline=Number_of_Function xmin=xm xmax=xma ymin=9.99e50 ymax=-9.99e50 double xtemp,ytemp n=new int[100] red=new int[100] green=new int[100] blue=new int[100] plottype=new int[100] ch=new char[100] int N=Number_of_Data double dx=(xmax-xmin)/N double xx=xmin int NF=Number_of_Function nline=NF double xi[][]=new double[NF][N] double yi[][]=new double[NF][N] double yy[]=new double[NF] for(int j=0 j<N j++) { yy=f.func(xx) for(int i=0 i<NF i++) { yi[i][j]=yy[i] xi[i][j]=xx } xx+=dx } pp2(xi,yi,ipt,ir,ig,ib) } public Plot(fi_x f,double xm,double xma,int Number_of_Data,int Number_of_Function, int ipt[],int ir[],int ig[],int ib[]) { pp4(f,xm,xma,Number_of_Data,Number_of_Function,ipt,ir,ig,ib) } public Plot(fi_x f,double xm,double xma,int Number_of_Data,int Number_of_Function, int ipt[]) { int ir[] int ig[] int ib[] int nn=Number_of_Function ir=new int[nn] ig=new int[nn] ib=new int[nn] for(int i=0 i<nn i++) { ir[i]=0 ig[i]=0 ib[i]=0 } pp4(f,xm,xma,Number_of_Data,Number_of_Function,ipt,ir,ig,ib) } public Plot(fi_x f,double xm,double xma,int Number_of_Data,int Number_of_Function) { int ir[] int ig[] int ib[] int ipt[] int nn=Number_of_Function ir=new int[nn] ig=new int[nn] ib=new int[nn] ipt=new int[nn] for(int i=0 i<nn i++) { ir[i]=0 ig[i]=0 ib[i]=0 ipt[i]=0 } pp4(f,xm,xma,Number_of_Data,Number_of_Function,ipt,ir,ig,ib) } public void setPlabel(String ip) {label=ip } public void setXlabel(String ix) {xlabel=ix } public void setYlabel(String iy) {ylabel=iy } public void setXYlabel(String ix,String iy) {xlabel=ix ylabel=iy } public void set_plotwindow(int width,int height,double xip,double yip,double dxp,double dyp) { //sets rectangular plot window //function scale input variables //real scale plot window width //real scale plot window height //xip minimum real scale x //yip minimum real scale y //dxp real scale x width xmax=xip+dxp //dyp real scale y height ymax=yip+dyp // xabsmin absolute (pixel) scale minimum x // yabsmin absolute (pixel) scale minimum y //abswidth absolute (pixel) scale x width (maximum x=minimum x+abswidth) //absheight absolute (pixel) scale y height (maximum y=minimum y+absheight) xabsmin = yabsmin = abswidth = absheight = (int)(width*(xip+0.2)) (int)(height*(yip+0.2)) (int)(width*dxp) (int)(height*dyp) int ipt[]=new int[Number_of_Function] int ir[]=new int[Number_of_Function] int ig[]=new int[Number_of_Function] int ib[]=new int[Number_of_Function] addFunction(f,xmin,xmax,Number_of_Data,Number_of_Function,ipt,ir,ig,ib) } public void addFunction(fi_x f,double xmin,double xmax,int Number_of_Data,int Number_of_Function,int ipt[]) { int ir[]=new int[Number_of_Function] int ig[]=new int[Number_of_Function] int ib[]=new int[Number_of_Function] addFunction(f,xmin,xmax,Number_of_Data,Number_of_Function,ipt,ir,ig,ib) } public void addFunction(fi_x f,double xmin,double xmax,int Number_of_Data,int Number_of_Function, int ipt[],int ir[],int ig[],int ib[]) { int N=Number_of_Data double dx=(xmax-xmin)/N double xx=xmin int NF=Number_of_Function double xi[][]=new double[NF][N] double yi[][]=new double[NF][N] double yy[]=new double[NF] for(int j=0 j<N j++) { yy=f.func(xx) for(int i=0 i<NF i++) { yi[i][j]=yy[i] xi[i][j]=xx } xx+=dx } addData(xi,yi,ipt,ir,ig,ib) } public void setPlotType(int plot_type[]) { for(int i=0 i<plot_type.length i++) { setPlotType(i,plot_type[i]) } setMinMax() } public void setXlogScaleOn() {xlog=1 xminmaxlog=Math.log10(xmax-xmin+10.0)-1.0 } public void setYlogScaleOn() {ylog=1 yminmaxlog=Math.log10(ymax-ymin+10.0)-1.0 } public void setXlogScaleOff() {xlog=0 } public void setYlogScaleOff() {ylog=0 } public void setPlotType(int dataset,int plot_no) { // plottype = 0 continuous line // plottype = 1 dashed line // plottype = 2 // plottype = 3 // plottype = 10 variable character plot type // plottype = 10 ch[i]='*' //you can change character set by using setPlotType(0,'%') // plottype = 11 ch[i]='#' // plottype = 12 ch[i]='$' // plottype = 13 ch[i]='%' // plottype = 14 ch[i]='&' // plottype = 15 ch[i]='£' // plottype = 16 ch[i]='~' // plottype = 17 ch[i]='+' //plottype = 18 ch[i]='^' //plottype = 19 ch[i]='=' // plottype = 20 rectangle // plottype = 21 filled rectangle // plottype = 22 circle // plottype = 23 filled circle // plottype = 24 triangle // plottype = 25 diamond // plottype = 26 pentagon // plottype = 27 hexagon // plottype = 28 filled triangle // plottype = 29 filled diamond // plottype = 30 filled pentagon // plottype = 31 filled hexagon // plottype = 32 triangle star // plottype = 33 diamond star // plottype = 34 pentagon star // plottype = 35 hexagon star // plottype = 36 filled triangle star // plottype = 37 filled diamond star // plottype = 38 filled pentagon star // plottype = 39 filled hexagon star // plottype = 40 bar plot // plottype = 41 filled bar plot plottype[dataset]=plot_no if(plot_no==10) ch[dataset]='*' //user defined char is defined as * } public void setPlotType(int dataset,char plot_char) { // plottype = 10 user defined character plot plottype[dataset]=10 ch[dataset]=plot_char } public void setXgrid(int igx) { xgridon=igx } public void setYgrid(int igy) { ygridon=igy } public void setGrid(int igx,int igy) { xgridon=igx ygridon=igy } public void setXtic(int ixt) { xntic=ixt } public void setYtic(int iyt) { yntic=iyt } public void setXYtic(int ixt,int iyt) { xntic=ixt yntic=iyt } public void setColor(int dataset,int ired,int igreen,int iblue) { red[dataset]=ired green[dataset]=igreen blue[dataset]=iblue } public void setColor(int dataset,Color x) { red[dataset]=x.getRed() green[dataset]=x.getGreen() blue[dataset]=x.getBlue() } public void setColor(int ired[],int igreen[],int iblue[]) { for(int i=0 i<nline i++) { red[i]=ired[i] green[i]=igreen[i] blue[i]=iblue[i] } } public void setColor(Color x[]) { for(int i=0 i<nline i++) { red[i]=x[i].getRed() green[i]=x[i].getGreen() blue[i]=x[i].getBlue() } } public void setMinMax() { xmin=9.99e50 xmax=-9.99e50 ymin=9.99e50 ymax=-9.99e50 for(int i=0 i<nline i++) { for(int j=0 j<n[i] j++) { if(x[i][j]>xmax) xmax=x[i][j] if(x[i][j]<xmin) xmin=x[i][j] if(y[i][j]>ymax) ymax=y[i][j] if(y[i][j]<ymin) ymin=y[i][j] } } } public void setMinMax(double xi[][],double yi[][]) { xmin=9.99e50 xmax=-9.99e50 ymin=9.99e50 ymax=-9.99e50 for(int i=0 i<nline i++) { if(xi[i].length>nmax) {nmax=xi[i].length ni=i } for(int j=0 j<xi[i].length j++) { if(xi[i][j]>xmax) xmax=xi[i][j] if(xi[i][j]<xmin) xmin=xi[i][j] if(yi[i][j]>ymax) ymax=yi[i][j] if(yi[i][j]<ymin) ymin=yi[i][j] } } } public void setMinMax(double iminx,double imaxx,double iminy,double imaxy) { xmin=iminx ymin=iminy xmax=imaxx ymax=imaxy } public void plot() { PlotW.plot(this) } //==== B-Spline intrepolation============= public static double[] hi(double ti[]) { int n=ti.length-1 //ti 0..n int i for(i=0 i<(n-1) i++) { z[0][k]=xi[i] z[1][k]=funcSpline(S,z[0][k]) k++ for(int j=0 j<aradegersayisi j++) {dx=(xi[i+1]-xi[i])/((double)aradegersayisi+1.0) z[0][k]=z[0][k-1]+dx z[1][k]=funcSpline(S,z[0][k]) k++ } } z[0][k]=xi[i] z[1][k]=funcSpline(S,z[0][k]) return z } Plot pp=new Plot(ff1,xmin,xmax,n,pnumber) pp.plot() return pp } public static Plot func(fi_x ff1,double xmin,double xmax,int n) { Plot pp=new Plot(ff1,xmin,xmax,n,0) pp.plot() return pp } public static Plot func(fi_x ff1,double xmin,double xmax) { Plot pp=new Plot(ff1,xmin,xmax,300,0) pp.plot() return pp } public static Plot file(String ff1)throws IOException { Plot pp=new Plot(ff1) pp.plot() return pp } public static Plot file()throws IOException { Plot pp=new Plot() pp.plot() return pp } public static Plot file(String ff1,String ff2)throws IOException { String ff3[]={ff1,ff2} Plot pp=new Plot(ff3) pp.plot() return pp } public static Plot file(String ff1,String ff2,String ff3)throws IOException { String ff4[]={ff1,ff2,ff3} Plot pp=new Plot(ff4) pp.plot() return pp } public static Plot data(double x[],double y[]) { Plot pp=new Plot(x,y) pp.plot() return pp } public static Plot data(double a[][]) { Plot pp=new Plot(a) pp.plot() return pp } } */ import java.lang.Integer import java.awt. * import java.awt.event. * import java.awt.font. * import java.awt.geom. * import java.awt.image. * import javax.swing. * import java.io. { n=pi.nline lab1=new JLabel[n] c1=new JComboBox[n] red1=new JTextField[n] green1=new JTextField[n] blue1=new JTextField[n] col1=new JButton[n] //System.out.println( n= +n) for(int i=0 i<n i++) { Color color1=new Color(pi.red[i],pi.green[i],pi.blue[i]) lab1[i]=new JLabel( eğri +i+ ) c1[i]=new JComboBox(pi.plotst) c1[i].setSelectedIndex(pi.plottype[i]) red1[i]=new JTextField( +pi.red[i]) green1[i]=new JTextField( +pi.green[i]) blue1[i]=new JTextField( +pi.blue[i]) col1[i]=new JButton( ) col1[i].setBackground(color1) } Container contentPane = getContentPane() JTabbedPane tabbedPane = new JTabbedPane() promptXmin=new JLabel( Xmin ) inputXmin=new JTextField(10) promptXmax=new JLabel( Xmax ) inputXmax=new JTextField(10) promptYmin=new JLabel( Ymin ) inputYmin=new JTextField(10) promptYmax=new JLabel( Ymax ) inputYmax=new JTextField(10) //******* promptLabel=new JLabel( Plot başlığı ) promptXLabel=new JLabel( x ekseni başlığı ) promptYLabel=new JLabel( y ekseni başlığı ) inputLabel=new JTextField(40) inputXLabel=new JTextField(40) inputYLabel=new JTextField(40) //******* promptXntic=new JLabel( X tik no ) inputXntic=new JTextField(10) promptYntic=new JLabel( Y tik no ) inputYntic=new JTextField(10) promptXgridon=new JLabel( X grid (küçük kare) ) if(pi.xgridon.=0) inputXgridon=new JCheckBox( ,true) else inputXgridon=new JCheckBox( ,false) promptYgridon=new JLabel( Y grid (küçük kare) ) if(pi.ygridon.=0) inputYgridon=new JCheckBox( ,true) else inputYgridon=new JCheckBox( ,false) promptXlogon=new JLabel( x log ) promptYlogon=new JLabel( y log ) if(pi.xlog.=0) inputXlogon=new JCheckBox( ,true) else inputXlogon=new JCheckBox( ,false) if(pi.ylog.=0) inputYlogon=new JCheckBox( ,true) else inputYlogon=new JCheckBox( ,false) // check field xlogon //******* JPanel pane1 = new JPanel() { public Dimension getPrefferedSize() { Dimension size=super.getPreferredSize() size.width=800 return size } } JPanel mpane=new JPanel() mpane.setLayout(new GridLayout(5,4)) mpane.add(promptXmin) mpane.add(inputXmin) mpane.add(promptXmax) mpane.add(inputXmax) else if (e.getSource()==inputXmin ) {Double valXmin=new Double(inputXmin.getText()) jta.p1.xmin=valXmin.doubleValue() } else if (e.getSource()==inputXmax ) {Double valXmax=new Double(inputXmax.getText()) jta.p1.xmax=valXmax.doubleValue() } else if (e.getSource()==inputYmin ) {Double valYmin=new Double(inputYmin.getText()) jta.p1.ymin=valYmin.doubleValue() } else if (e.getSource()==inputYmax ) {Double valYmax=new Double(inputYmax.getText()) jta.p1.ymax=valYmax.doubleValue() } else if (e.getSource()==inputXntic ) {Integer valXntic=new Integer(inputXntic.getText()) jta.p1.xntic=valXntic.intValue() } else if (e.getSource()==inputYntic ) {Integer valYntic=new Integer(inputYntic.getText()) jta.p1.yntic=valYntic.intValue() } else if (e.getSource()==inputLabel ) {jta.p1.label=inputLabel.getText() } else if (e.getSource()==inputXLabel ) {jta.p1.label=inputXLabel.getText() } else if (e.getSource()==inputYLabel ) {jta.p1.label=inputYLabel.getText() } //***** for(int i=0 i<n i++) { Color color1=new Color(jta.p1.red[i],jta.p1.green[i],jta.p1.blue[i]) Color color2 if (e.getSource()==red1[i] ) {Integer valred=new Integer(red1[i].getText()) jta.p1.red[i]=valred.intValue() } else if (e.getSource()==green1[i] ) {Integer valgreen=new Integer(green1[i].getText()) jta.p1.green[i]=valgreen.intValue() } else if (e.getSource()==blue1[i] ) { Integer valblue=new Integer(blue1[i].getText()) } else if (e.getSource()==col1[i] ) { color2=JColorChooser.showDialog(null, grafik programı eğri +i,color1 ) jta.p1.red[i]=color2.getRed() jta.p1.green[i]=color2.getGreen() jta.p1.blue[i]=color2.getBlue() red1[i].setText( +jta.p1.red[i]) green1[i].setText( +jta.p1.green[i]) blue1[i].setText( +jta.p1.blue[i]) } color2=new Color(jta.p1.red[i],jta.p1.green[i],jta.p1.blue[i]) col1[i].setBackground(color2) } //***** jta.yenidenciz() } public void degerleriGir(String e,int x,int y) { s=e if(jta.p1.xlog.=0) {xi1=jta.p1.xmin+Math.pow(10.0,(double)((x-jta.p1.xabsmin)/(double)jta.p1.abswidth*(double)jta.p1.xminmaxlog+1.0))-10.0 } else {xi1=jta.p1.xmin+(double)(x-jta.p1.xabsmin)/(double)jta.p1.abswidth*(jta.p1.xmax-jta.p1.xmin) } if(jta.p1.ylog.=0) {yi1=jta.p1.ymin-10.0+Math.pow(10.0,((double)(1.0-(double)(y-jta.p1.yabsminjta.p1.absheight)/(double)jta.p1.absheight*(double)jta.p1.yminmaxlog))) } else {yi1=jta.p1.ymin-(double)(y-jta.p1.yabsmin-jta.p1.absheight)/(double)jta.p1.absheight*(jta.p1.ymax-jta.p1.ymin) } altbar.setText(e+ [ +xi1+ , +yi1+ ] ) //jta.yenidenciz() } public void mouseClicked(MouseEvent e) { degerleriGir( Kliklendi ,e.getX(),e.getY()) } public void mousePressed(MouseEvent e) { degerleriGir( Basıldı ,e.getX(),e.getY()) } public void mouseReleased(MouseEvent e) { degerleriGir( Bırakıldı ,e.getX(),e.getY()) } public void mouseEntered(MouseEvent e) { setTitle( Fare applet alanı içinde ) } public void mouseExited(MouseEvent e) { setTitle( Fare applet alanı dışında ) degerleriGir( Fare applet alanı dışında ,e.getX(),e.getY()) } //MouseMotionListener (fare hareket dinleyicisi) metotlari public void mouseDragged(MouseEvent e) { degerleriGir( basilip cekiliyor ,e.getX(),e.getY()) } public void mouseMoved(MouseEvent e) { degerleriGir( hareket halinde ,e.getX(),e.getY()) } public static void plot() { //takes plot sata from Plot.txt file PlotW pencere= new PlotW() pencere.addWindowListener(new BasicWindowMonitor()) pencere.setSize(1000,800) pencere.setVisible(true) } public static void plot(Plot pi) { //take plot data from pi object PlotW pencere= new PlotW(pi) pencere.addWindowListener(new BasicWindowMonitor()) pencere.setSize(1000,800) pencere.setVisible(true) } public static void main(String[] args) { PlotW pencere= new PlotW() pencere.addWindowListener(new BasicWindowMonitor()) pencere.setSize(1000,800) pencere.setVisible(true) } } * import java.awt. * import java.awt.event. * import java.awt.geom. * import javax.swing. * import java.awt.print.PrinterJob import java.awt.print. * public class Plot2D extends JPanel implements Printable { public Graphics2D g public Plot p1 final static Color bg = Color.white final static Color fg = Color.black final static Color red = Color.red final static Color white = Color.white final static BasicStroke stroke = new BasicStroke(1.0f) final static BasicStroke boldStroke = new BasicStroke(2.0f) PlotShapesSW ps double xx[],yy[] int xn public Plot2D(Plot pi) { //Initialize drawing colors setBackground(Color.white) setForeground(Color.black) //read data from file Plot data previously defined p1=pi xx=new double[200] yy=new double[200] xn=0 } public Plot2D() { //Initialize drawing colors setBackground(Color.white) setForeground(Color.black) //read data from file Plot data previously defined try{p1=new Plot() } catch(IOException ioe) {System.err.println( IOExceptionin opening plot ) } xx=new double[200] yy=new double[200] xn=0 } public Plot2D(String pl,String xl,String yl,int xnt,int ynt ,int xgo,int ygo,String ifn[],int ipt[],int ir[],int ig[] ,int ib[]) { //input variables // pl plot label // xl x axis label // yl y axis label //xnt x axis tic (0=off, any other on) //ynt y axis tic (0=off, any other on) //xgo x axis grid on (0=off, any other on) //ygo y axis grid on (0=off, any other on) //ifn file name array variable //ipt plot type array variable //ir color red component array variable //ig color green componenet array variable //Initialize drawing colors setBackground(Color.white) setForeground(Color.black) try{ p1=new Plot(pl,xl,yl,xnt,ynt,xgo,ygo,ifn,ipt,ir,ig,ib) } catch(IOException ioe) {System.err.println( IOExceptionin opening plot ) } xx=new double[200] yy=new double[200] xn=0 } public void setXY(double ixx[],double iyy[],int ixn) { xn=ixn for(int i=0 i<xn i++) {xx[i]=ixx[i] yy[i]=iyy[i] } } public void yenidenPlotDatasiOku() { try{ p1=new Plot() } catch(IOException ioe) {System.err.println( IOExceptionin opening plot ) } } public void yenidenPlotDatasiOku(Plot pi) { p1=pi } public void plotVerisiEkle(double xi[],double yi[],int iplottype,int ir,int ig,int ib) { p1.addData(xi,yi,iplottype,ir,ig,ib) } public void plotVerisiEkle(double xi[][],double yi[][],int iplottype[],int ir[],int ig[],int ib[]) { p1.addData(xi,yi,iplottype,ir,ig,ib) } public void plotVerisiEkle(f_x f,double xmin,double xmax,int N,int iplottype,int ir,int ig,int ib) { p1.addFunction(f,xmin,xmax,N,iplottype,ir,ig,ib) } public void yenidenPlotDatasiOku(String pl,String xl,String yl,int xnt,int ynt ,int xgo,int ygo,String ifn[],int ipt[],int ir[],int ig[] ,int ib[]) { //input variables // pl plot label // xl x axis label // yl y axis label //xnt x axis tic (0=off, any other on) //ynt y axis tic (0=off, any other on) //xgo x axis grid on (0=off, any other on) //ygo y axis grid on (0=off, any other on) //ifn file name array variable //ipt plot type array variable //ir color red component array variable //ig color green componenet array variable //Initialize drawing colors setBackground(Color.white) setForeground(Color.black) try{ p1=new Plot(pl,xl,yl,xnt,ynt,xgo,ygo,ifn,ipt,ir,ig,ib) } catch(IOException ioe) {System.err.println( IOExceptionin opening plot ) } } public void yenidenciz() { repaint() } public void yazdir() { PrinterJob printJob = PrinterJob.getPrinterJob() printJob.setPrintable(this) if (printJob.printDialog()) { try { printJob.print() } catch (Exception ex) {ex.printStackTrace() } } } * import java.awt.event. * import java.awt.geom. * import javax.swing. * import java.awt.font. { xx1=(int)(xabsmin+(x1-xmin)/(xmax-xmin)*abswidth) xx2=(int)(xabsmin+(x2-xmin)/(xmax-xmin)*abswidth) } if(ylog.=0) { yy1=(int)(yabsmin+absheight-((Math.log10(y1-ymin+10.0)-1.0)/yminmaxlog*absheight)) yy2=(int)(yabsmin+absheight-((Math.log10(y2-ymin+10.0)-1.0)/yminmaxlog*absheight)) } else { yy1=(int)(yabsmin+absheight-(y1-ymin)/(ymax-ymin)*absheight) yy2=(int)(yabsmin+absheight-(y2-ymin)/(ymax-ymin)*absheight) } g.draw(new Line2D.Double( xx1,yy1,xx2,yy2)) } //end of drawLine yvalues[2*i+1]= (int)(Math.floor(yabsmin+absheight-((Math.log10(y1-ymin+10.0)-1.0)/ yminmaxlog*absheight-r*Math.sin(teta2)))) } else { yvalues[2*i]= (int)(Math.floor(yabsmin+absheight-(y1-ymin)/ (ymax-ymin)*absheight-R*Math.sin(teta1))) yvalues[2*i+1]= (int)(Math.floor(yabsmin+absheight-(y1-ymin)/ (ymax-ymin)*absheight-r*Math.sin(teta2))) } if(i==side) { xvalues[2*i]=xvalues[0] yvalues[2*i]=yvalues[0] } } for(int i=0 i<=2*side i++) { if(i==0) { polygon.moveTo(xvalues[0],yvalues[0]) } else { polygon.lineTo(xvalues[i],yvalues[i]) } } g.fill(polygon) }//end of drawStar public void drawXTic(int ticNumber,double ticHeight,int ticSide) { //draw a series of x axis tics double dtic=(xmax-xmin)/ticNumber double x1=xmin double y1=ymin double dy dy=ticHeight int xx1,yy1,yy2,yy3 for(int i=0 i<=ticNumber i++) { if(xlog.=0) { xx1=(int)(xabsmin+((Math.log10(x1-xmin+10.0)-1.0)/xminmaxlog*abswidth)) } else { xx1=(int)(xabsmin+(x1-xmin)/(xmax-xmin)*abswidth) } yy1=(int)(yabsmin+absheight-(y1-ymin)/(ymax-ymin)*absheight) yy2=(int)(yabsmin+absheight-(y1-dy-ymin)/(ymax-ymin)*absheight) yy3=(int)(yabsmin+absheight-(y1+dy-ymin)/(ymax-ymin)*absheight) if(ticSide==0) {g.draw(new Line2D.Double( xx1,yy1,xx1,yy2)) } else {g.draw(new Line2D.Double( xx1,yy1,xx1,yy3)) } x1=x1+dtic } } public void drawYTic(int ticNumber,double ticWidth,int ticSide) { //draw a series of y axis tics double dtic=(ymax-ymin)/ticNumber double x1=xmin double y1=ymin double dx dx=ticWidth double xx1,xx2,xx3,yy1 for(int i=0 i<=ticNumber i++) { if(ylog.=0) public void drawYNumbers(int ticNumber) { // draw y numbers double dtic=(ymax-ymin)/ticNumber double x1=xmin double y1=ymin int xx1,yy1 String s s= for(int i=0 i<=ticNumber i++) { if(xlog.=0) VisAD çok çeşitli 3 boyutlu uygulamalar için Java 3D grafik paketinikullanan bir program paketidir. Visad Paketini http //www.ssec.wisc.edu/~billh/visad.html veya çeşitli adreslerden indirebilirsiniz. İsterseniz kendiniz kodları derleyerek kurabilirsiniz, isterseniz, hazır visad.jar dosyasını javanın jre dosyası altındaki lib dosyası altındaki ext dosyasına kopyalıyarak (örneğin benim bilgisayarımda c \co\java\jre\lib\ext) bilgisayarınızı VisAD paketini direk kullanabilir hale getirebilirsiniz. 3 boyutlu grafikler için aynı zamanda Java 3D grafik paketine de ihtiyacınız olacaktır. bu paketin en son versiyonuna www.java.sun.com adresinden temin edebilirsiniz (benim şu anda kullandığım versiyonu java3d-1_4_0_01-windows-i586) paket açtığınızda kendi kendine yüklenecektir. Java 3D paketi default olarak Windows ortamında openGL kullanır (diğer ortamlardaki grafik kullanımı ile ilgili Java 3D paketini inceleyiniz). Eğer grafik kartınız openGL sistemini destekliyorsa bu bölümde verdiğimiz programları direk olarak kullanabilirsiniz. Bu durumda programı çalıştırırken Java 3D paketine default değer olan openGL yerine directX kullandığınızı belirtmeniz gerekecektir. Bunun için java programını çalıştırırken java -Dj3d.rend=d3d sınıfismi komutunu kullanmanız gerekir. directX'in Windows için en son versiyonunu http //www.microsoft.com/windows/directx/ adresinden bulabilirsiniz. Oluşturduğumuz 3D programı Plot3D için temel olarak VisAD paketinin örnek problemlerini kullandık, bu örnek programları bizim iki boyutlu grafik ortamlarında da kullandığımız fonksiyon abstract sınıf ve veri yapılarına uygun hale getirdik. Plot3D Program çıktısı Program 1.6-14-1 de verilmiştir. * import visad.java3d.DisplayImplJ3D import visad.java2d.DisplayImplJ2D import java.rmi.RemoteException import java.awt. * import javax.swing. * import java.awt.event. * class f1 extends f_xj { public double func(double x[]) { //çözümü istenen fonksiyon // The function (domain_tuple -> altitude ) FunctionType func_domain_alt // Our Data values for the domain are represented by the Set Set domain_set // The Data class FlatField FlatField vals_ff // The DataReference from data to display DataReferenceImpl data_ref // The 2D display, and its the maps // ...and put the altitude values above into it // Note the argument false, meaning that the array won't be copied vals_ff.setSamples( flat_samples , false ) // Create Display and its maps display = new DisplayImplJ3D( display1 ) // Get display's graphics mode control and draw scales GraphicsModeControl dispGMC = (GraphicsModeControl) display.getGraphicsModeControl() dispGMC.setScaleEnable(true) // Also enable Texture dispGMC.setTextureEnable(false) // Create a data reference and set the FlatField as our data data_ref = new DataReferenceImpl( data_ref ) data_ref.setData( vals_ff ) display.addReference( data_ref) // Set maps ranges latMap.setRange(x1min, x1max) altMap.setRange(zmin, zmax) // Create application window and add display to window JFrame jframe = new JFrame( VisAD Tutorial example 4_06 ) jframe.getContentPane().add(display.getComponent()) // Add the LabeledColorWidget to the frame // The function (domain_tuple -> altitude ) FunctionType func_domain_alt // Our Data values for the domain are represented by the Set Set domain_set display.addReference( data_ref) // Set maps ranges latMap.setRange(x1min, x1max) altMap.setRange(zmin, zmax) // Create application window and add display to window JFrame jframe = new JFrame(sz) jframe.getContentPane().add(display.getComponent()) // Add the LabeledColorWidget to the frame // The function (domain_tuple -> altitude ) FunctionType func_domain_alt // Our Data values for the domain are represented by the Set Set domain_set // The Data class FlatField FlatField vals_ff // The DataReference from data to display DataReferenceImpl data_ref // The 2D display, and its the maps DisplayImpl display ScalarMap latMap, lonMap ScalarMap altMap, altRGBMap ColorControl colCont // Our color table float[][] myColorTable // Code for slope data // Data in a FlatField FlatField slope_vals_ff // Get the funtionc from the FlatField for slope FunctionType func_domain_slope = ((FunctionType)slope_vals_ff.getType()) // slope is a RealType RealType slope = (RealType) func_domain_slope.getRange() // Create Display and its maps display = new DisplayImplJ3D( display1 ) // Get display's graphics mode control and draw scales GraphicsModeControl dispGMC = (GraphicsModeControl) display.getGraphicsModeControl() dispGMC.setScaleEnable(true) // Also enable Texture dispGMC.setTextureEnable(false) altMap = new ScalarMap( altitude, Display.ZAxis ) // Add maps to display display.addMap( latMap ) display.addMap( lonMap ) display.addMap( altMap ) display.addMap( altRGBMap ) // Create a data reference and set the FlatField as our data data_ref = new DataReferenceImpl( data_ref ) data_ref.setData( vals_ff ) // Data reference for slope DataReferenceImpl data_ref2 = new DataReferenceImpl( data_ref2 ) data_ref2.setData( slope_vals_ff ) // Add reference to display ConstantMap[] constAlpha_CMap = { new ConstantMap( 0.50f, Display.Alpha)} display.addReference( data_ref2, constZ_CMap ) display.addReference( data_ref, constAlpha_CMap ) // Set maps ranges latMap.setRange(x1min, x1max) altMap.setRange(x2min, x2max) // Create application window and add display to window JFrame jframe = new JFrame(sz) jframe.getContentPane().add(display.getComponent()) // Add the LabeledColorWidget to the frame // Tuple to pack longitude and latitude together, as the domain RealTupleType domain_tuple // The function (domain_tuple -> temperature ) // Remeber, range is only temperature FunctionType func_domain_temp // Our Data values for the domain are represented by the Set Set domain_set // ...and for the isocontours iso_vals_ff = new FlatField( func_domain_isoTemp, domain_set) // Get the values from the temperature FlatField // create flat_isoVals array for clarity's sake // false argument means don't copy float[][] flat_isoVals = vals_ff.getFloats(false) // ...and put the values above into it // Note the argument false, meaning that the array won't be copied again iso_vals_ff.setSamples( flat_isoVals , false ) // starting at this base value // ...and set the lines with the method isoControl.setContourInterval(interval, lowValue, highValue, base) isoControl.enableLabels(true) // Create data references and set the FlatField as our data data_ref = new DataReferenceImpl( data_ref ) iso_data_ref = new DataReferenceImpl( iso_data_ref ) data_ref.setData( vals_ff ) iso_data_ref.setData( iso_vals_ff ) // Add reference to display display.addReference( data_ref ) display.addReference( iso_data_ref ) // Create application window and add display to window JFrame jframe = new JFrame(s3) jframe.getContentPane().add(display.getComponent()) // Get the Set samples to facilitate the calculations float[][] set_samples = domain_set.getSamples( true ) // Add maps to display display.addMap( latMap ) display.addMap( lonMap ) display.addMap( tempIsoMap ) display.addMap( tempRGBMap ) // Create a data reference and set the FlatField as our data data_ref = new DataReferenceImpl( data_ref ) data_ref.setData( vals_ff ) // Add reference to display display.addReference( data_ref ) // Create application window and add display to window JFrame jframe = new JFrame(s3) jframe.getContentPane().add(display.getComponent()) jframe.setSize(300, 300) jframe.setVisible(true) } public static void main(String[] args) throws RemoteException, VisADException { f1 f=new f1() double a[][]=grid2D(f,-1,1,-1,1,20,20) Bu programı ne şekilde kullanabileceğimizi çeşitli örnek problemlerle görelim.Kodu bir araya getirirken Plot programında olduğu gibi çok basit bir şekilde kullanılır olmasını düşündük. Kartınız openGL'i desteklemiyorsa(Windows sistemleri için) programı directX ile çalıştırmak için java komutunu java -Dj3d.rend=d3d Plot3DT1 şeklinde kullanınız. * import visad.java3d.DisplayImplJ3D import visad.java2d.DisplayImplJ2D import java.rmi.RemoteException import java.awt. * import javax.swing. * import java.awt.event. Gördüğünüz gibi grafik çıktısını alabilmek için çok fazla bir bilgiye ihtiyacınız olmayacak, veriyi verip çiz demeniz temel olarak yeterli olacaktır. Şimdi veriyi bir fonksiyondan alalım. * import visad.java3d.DisplayImplJ3D import visad.java2d.DisplayImplJ2D import java.rmi.RemoteException import java.awt. * import javax.swing. * import java.awt.event. * import visad.java3d.DisplayImplJ3D import visad.java2d.DisplayImplJ2D import java.rmi.RemoteException import java.awt. * import javax.swing. * import java.awt.event. * class f1 extends f_xj { public double func(double x[]) { //çözümü istenen fonksiyon double ff ff=(x[1]-x[0]*x[0])*(x[1]-x[0]*x[0])+0.01*(x[0]-1.0)*(x[0]-1.0) return -ff } } public class Plot3DT3 { public static void main(String[] args) throws RemoteException, VisADException { f1 f=new f1() Contour grafikleri 3 boyutlu eğrinin ikiboyuta izdüşümüdür. Haritalarda da bu yöntemi kullanmaktayız. * import visad.java3d.DisplayImplJ3D import visad.java2d.DisplayImplJ2D import java.rmi.RemoteException import java.awt. * import javax.swing. * import java.awt.event. Burada verdiğimiz kadarı size 3 boyutlu grafiklere bir giriş sağlamak ve aynı zamanda sayısal çözümleme sonuçlarını gözlemleyebileceğimiz 3 boyutlu grafik ortamını oluşturmak amacı ileydi. Eğer daha detaylı kullanımlara girmek isterseniz VisAD veya benzeri paketleri detaylı inceleyerek bu konuda kendinizi rahatlıkla geliştirebilirsiniz. JMath isimli bu paket yukarda verdiğimiz ve genel 3 boyutlu grafik paketi kadar sofistike değil ama basitliği bazı kullanıcılarımız için rahatlık getirebilir diye bu paketi de nasıl kullanacağımız ve 3 boyutlu rafik çıktılarını sayısal çözümleme problemlerimize adapte edebilecek temel bir programı burada sunuyoruz. Bu paketi sadece fonksiyon grafikleri için adape ettim. Div. // turhan.coban@ege.edu.tr // ===================================================== // utilizes JMath 3D Plot // http //jmathtools.sourceforge.net/doku.php // to use this program please add to javahome/jre/lib/ext // jmathio.jar jmathplot.jar ve jmatharray.jar jar files import javax.swing. * import org.math.plot. * import static java.lang.Math. * import static org.math.array.DoubleArray. * import java.awt. * import java.awt.event. * class f2 extends f_xj { public double func(double x[]) { //çözümü istenen fonksiyon double ff ff=7.9+0.13*x[0]+0.21*x[1]-0.05*x[0]*x[0]-0.016*x[1]*x[1]-0.007*x[0]*x[1] //ff=sin(x[0])*cos(x[1]) return ff } } public class Plot3D_JM{ Plot3DPanel plot Programı verilen fonksiyonu değiştirerek tek başına kullanabileceğiniz gibi başka bir programdan da çağırarak grafiği çizdirebilirsiniz. Program hoşunuza gidebilecek bir çok özellikler barındırıyor(benim yazdığım değil bizzat paketten hazır olarak gelen) Bunlardan birkaçına bakalım Program değişkenlerinin maksimum-minimum değerlerini değiştirerek detayları inceleyebiliriz. Verileri direk olarak JTable sınıfı tablolardan alarak kullanabiliriz . Görüleceği gibi b programda VisAD paketi için yazdığımız Plot3D setindekifonksiyon çizme metod formatları aynen korunmaya çalışılmıştır. 3 boyutlu fonksiyon grafik programımızı kendi programımız içinde de çağırabiliriz. * import javax.swing. * import java.awt.event. GUI, USER Kullanıcıya sunulan programın onun rahatlıkla anlayabileceği bir formata sahip olması günümüz programlamacılığında oldukça önemlidir. Reklamlarla büyüyen bir kuşak için paket bazen paketin içindekinden bile önemli hale gelebilmektedir. Grafik Kullanıcısı Arabirim programları kullanıcıya sunduğumuz paketi oluşturmaktadır. Java'da temel grafik arabirim kütüphaneleri java.awt sınıfında yer almaktadır. Bu bölümde awt ve swing yapılarını paralel olarak vermeye çalışacağız.. Yalnız swing kütüphanesi kapsam olarak çok daha geniş olduğundan swing ile yapılan tüm işlemlerin ve grafik arabirim alt programlarını awt'de karşılıkları mevcut değildir. Bir önceki grafik çiziminde olduğu gibi grafik arabirim elemanlarının tanıtımı da oldukça geniş bir yelpaze oluşturduğuundan mümkün olduğunca detay verilmeye çalışılsa bile tüm kapsamı burada işlemek mümkün değildir. Örneğin java swing konusundaki kapsamlı bir kitap olan Java Swing , O'Reily basım evi kitabı yaklaşık 1200 sayfalık bir kitabı sadece bu konuya ayırmıştır. GUI metotları java.awt (Abstract windowing toolkit) paketinde yer almaktadır. Bu pakette Container ve Component isimli iki alt pakette yer almaktadır. Her zaman kullandığımız Applet sınıfı Component sınıfından türiyen Panel sınıfının alt sınıfıdır. Yani Component Appletlerin süper sınıfıdır. Burada Component sınıfının  TextComponent  TextField  TextArea  Button  Label  Checkbox  List  Choice  Canvas  Scrollbar  Container  Panel Java.applet.Applet sınıfının  ScrollPane  Window  Frame  Dialog Sınıflarını incelemeye calışacağız. Paralel olarak javax.swing paketinde yer alan grafik arayüz programlarında yer alan üst seviye paketler Japplet, JDialog, JFrame,JWindow ve JComponent'dir JComponent sınıfının altında yer alan sınıfların bazıları  JcomboBox  JLabel  JList  JMenuBar  JPanel  JPopupMenu  JScrollBar  JScrollPane  JTable                               JTree JInternalFrame JOptionPane JProgressBar JRootPane JSeperator JSlider JSplitPane JTabbedPane JToolBar JToolTip JViewePort JColorChooser JTextComponent JTextArea JTextField JPasswordField JEditorPAne JTextPane JFileChooser JLayeredPane AbstractButton JToggleButton JCheckBox JRadioButton JButton JMenuItem JMenu JRadioButtonMenuItem JCheckButtonMenuItem Yine yineleyelim, swing sınıfındaki tüm alt metodları kapsamak bu kitabın kapsamını oldukça büyütecektir, bu yüzden şimdilik buna imkan göremiyoruz, fakat pratikte ne oldukları hakkında iyi bir fikir verebilecek genişlikte bir spektrum vermeye çalışacağız. Burada özellkle awt ve swing sınıfı grafik işlemcilerini bir arada vermeye çalıştık. Kullanıcı her iki tip grafik ortamıyla da karşılaşacağı için (Kendi yazmasa bile hazır programlar karşısına çıkacaktır), her ikisini de bilmesi gereklidir. Zaten bu kitabın tüm konularında da hem awt hem de swing ile yazılmış program örnekleri vermeye çalıştık. Bu konudan sonra geriye dönüp tüm program örneklerini grafik ortamı gözüyle inceliyebilirsiniz. Label sınıfında tanımlanan metotlar şunlardır  Kurucu Metotlar public Label() // Label sınıfı nesneyi olusturur herhangi bir yazı göstermez public Label(String s) // Label sınıfı nesneyi olusturur ve s stringini gösterir public void Label(String s,int pozisyon) // Label sınıfı nesneyi olusturur ve s stringi gösterir aynı zamanda Labeli pozisyonda verilen değere göre istenilen yere yerleştirir.  Giriş çıkış metotları public String getText() // Label sınıfının String değişkenini okur. public void setText(String s) // Label sınıfının String değişkenine yeni değer girer. public void setAlignment(int pozisyon) Label pozisyon değişkeninde verilen değere göre istenilen yere yerleştirir. Swing sınıfı Jlabel Lable sınıfındandan farklı olarak bize sadece yazı değil aynı zamanda görüntü ekleme olasılıkları da sunar. Jlabel sınıfının çok kullanacağımız bazı metotlarını sayacak olursak Jcomponent sınıfından gelen metodlar void setBackground(Color c) arkaplan rengini değiştiri Color getBackground() arkaplan rengini okur void setForeground(Color c) önpaln rengini değiştiri Color getForeground() ön plan rengini okur. void setFont(Font f) yazı fontunu seçer Font getFont() yazı fontunu okur Boolean isVisible görünür olup olmadığını kontrol eder Void setVisible(Boolean b) görünür veya görünmez yapar. Jlabel sınıfında tanımlanmış bazı alt sınıflar void setText(String s) JLabel'ın text değişkeninin değerine yeni verilen değeri atar String getText() JLabel'ın String text değişkenini okur. int getVerticalAlignment() void setVerticalTextPosition(int düşey_pozisyon) Label'in içindeki yazının Label içindeki düşey pozisyonunu ayarlar. Sabitler üsttekilerin aynıdır. int getVerticalTextPosition() Label'in içindeki yazının Label içindeki düşey pozisyonunu okur. void setHorizontalTextPosition(int düşey_pozisyon) Label'in içindeki yazının Label içindeki yatay pozisyonunu ayarlar. int getHorizontallTextPosition() Label'in içindeki yazının Label içindeki yatay pozisyonunu okur. void setIcon(Icon resim) Label içindeki resmi değiştirir veya eğer yoksa ilk defa atar Icon getIcon() Label içindeki resmi okur. void setDisplayedMnemonic(int c) Mnemoic alt harf kontrolunu kullanarak belli bir girişe ulaşmayı sağlar. (örneğin ‘m' harfine set edilmişse alt-m bu komuta gider. Örnek problemlerle bu kavram açılacaktır. int getDisplayedMnemonic(int c) Mnemonic değerini okur. Şimdi örnek problemlerle swing JLabel kullanımına daha detaylı olarak bakalım. Birinci örneğimizde basit bir şekilde String label yazdıracağız. Çerçeve olarak JFrame kullandık. * public class label1SW { public static void main(String[] args) { JLabel etiket=new JLabel( JLabel sınıfına hoş geldiniz ) JFrame cerceve=new JFrame() cerceve.addWindowListener(new BasicWindowMonitor()) cerceve.getContentPane().add(etiket) cerceve.pack() cerceve.setVisible(true) } } Bu programın aynı zamanda main metodu da olduğundan hem applet hem de frame olarak çağırılması mümkündür. Çerçeve olarak JFrame kullandık. * import java.awt.event. * import java.awt.geom. * import javax.swing. * public class LabelTestiSW extends JApplet { protected String iconname1= images/kuş.gif ImageIcon icon1 public static void main(String s[]) { JFrame f = new JFrame( Label testi ) f.addWindowListener(new WindowAdapter() { public void windowClosing(WindowEvent e) {System.exit(0) } }) JApplet applet = new LabelTestiSW() f.getContentPane().add( Center , applet) applet.init() f.pack() f.setSize(new Dimension(550,200)) f.show() } } images/middle.gif middle.gif dosyasının images alt direktorysinde yer aldığını belirtir. Burada Icon interphase'ine biraz daha yakından göz atalım. Icon interphase sınıfı olduğundan tanımlanan sınıfı içerisinde public int getIconWidth() public int getIconHeight() public void paintIcon(Component c, Graphics g, int x,int y) metodları tanımlanmak zorundadır. * import java.awt.geom. * import java.awt. * * import java.awt. Bu sınıfın çıktısı Diğer bir deyimle kullanıcının başlatacağı işlemleri yapar ve kullanıcının yeni bir işlem tanımlamasını beklerler. Bu işlemleri yapan sınıflar java.awt.event kütüphanesinde tanımlanmıştır. Bu kütüphanede en çok kullanacağımız sınıflar hiyerarşi düzeninde şöyle verilebilir  AdjustmentEvent // asağı yukarı kaydırma cubugunda (scroll bar) bir işlem yapıldığında kullanılır.  ItemEvent // List veya CheckBox kliklendiginde (bir kere) kullanılır  ComponentEvent //appletteki elemanların gizlenmesi, boylarının değiştirilmesi, veya değişik yerlere alınması amacıyla kullanılır.  ContainerEvent //Containera(applete) yeni bir eleman eklenilir veya çıkarılırken kullanılır.  FocusEvent//herhangi bir applet elemanı kullanılmaya baslandıgında on plana cıkarılmakk, ve kullanılmadıgında arka plana atılmak istendiğinde kullanılır.  PaintEvent  WindowEvent //pencere acılıp kapandığında,kücültülüp büyütüldüğünde vb kullanılır. Dinleme işlemini yapan metotlar şunlardır Java.util.EventListener  ActionListener  AdjustmentListener  ComponentListener  ContainerListener  FocusListener  ItemListener  KeyListener  MouseListener  MouseMotionListener  TextListener  WindowListener Bu metotların bir çoğunu ilgili örneklerde yeri geldiğinde kullanacağız. * import java.awt.event. class B2Basilinca implements ActionListener { Applet applet public B2Basilinca(Applet a) {applet=a } public void actionPerformed(ActionEvent e) { applet.showStatus( +e.paramString()+ dugmesine basildi ) } } * import java.awt.event. Birinci programda düğmelere basıldığında oluşan eylemler (showStatus köşesine basılan düğmeyi yazdırma) ayrı sınıflarda yaptırılmış ve Applet sınıfı üzerinden bizim ButtonTesti sınıfına aktarılmıştır. İkinci programda ise aynı işlemler tek bir sınıfın içerisinde yer almıştır. Programdan da görülecegi gibi düğme basma eylemi ActionEvent sınıfı üzerinden aktarılmıştır. JButton sınıfı ile Button sınıfı arasında kullanım açısından Label ve Jlabel sınıfının arasındakilere benzer farklar vardır. JButton sınıfının sınıf tanımı public class JButton extends AbstractButton implements Accessible { public JButton() public JButton(Icon resim) public JButton(String yazı) public JButton(String yazı, Icon resim) public AccessibleContext getAccessibleContext() public String getUIClassID() public boolean isDefaultButton() public boolean isDefaultCapable() public void setDefaultCapable(boolean b) pubkic void updateUI() } şeklindedir. Görüldüğü gibi JButton fazla metod barındırmaz bir çok önemli metodu Abstract button ve onun tepe sınıfı JComponent sınıflarından alır. JButton sınıfında Jlabel sınıfında da kullandığımız JComponent sınıfından gelen metodlar public void setBackground(Color c) arkaplan rengini değiştiri public Color getBackground() arkaplan rengini okur public void setForeground(Color c) önpaln rengini değiştiri public Color getForeground() ön plan rengini okur. public void setFont(Font f) yazı fontunu seçer public Font getFont() yazı fontunu okur public Boolean isVisible() görünür olup olmadığını kontrol eder public Void setVisible(Boolean b) görünür veya görünmez yapar. AbstractButton sınıfında tanımlanmış bazı alt sınıflar public void setText(String s) JLabel'ın text değişkeninin değerine yeni verilen değeri atar public String getText() AbstractButton'ın String text değişkenini okur. public int getVerticalAlignment() public void setVerticalTextPosition(int düşey_pozisyon) AbstractButton‘ın içindeki yazının Label içindeki düşey pozisyonunu ayarlar. Sabitler üsttekilerin aynıdır. public int getVerticalTextPosition() AbstractButton‘ın içindeki yazının AbstractButton içindeki düşey pozisyonunu okur. public void setHorizontalTextPosition(int düşey_pozisyon) AbstractButton‘ın içindeki yazının AbstractButton içindeki yatay pozisyonunu ayarlar. Public void setIcon(Icon resim) AbstractButton‘ın içindeki resmi değiştirir veya eğer yoksa ilk defa atar public Icon getIcon() AbstractButton içindeki resmi okur. public void setDisplayedMnemonic(int c) Mnemoic alt harf kontrolunu kullanarak belli bir girişe ulaşmayı sağlar. (örneğin ‘m' harfine set edilmişse alt-m bu komuta gider. Örnek problemlerle bu kavram açılacaktır. Public int getDisplayedMnemonic(int c) Mnemonic değerini okur. Listener (pencere dinleme) metod ve neslerinden ise protected ActionListener actionListener protected Itemlistener itemListener protected ChangeListener changeListener public void addActionListener(ActionListener l) public void addChangeListener(ChangeListener l) public void addItemListener(ItemListener l) public void removeActionListener(ActionListener l) public void removeChangeListener(ChangeListener l) public void removeItemListener(ItemListener l) public String getActionCommand() public void setActionCommand(String com) gibi metodlar mevcuttur. * import java.awt. * import java.awt.event. * Not isimler aynı olduğundan bu iki programı aynı dosyalarda saklıyamayız. Şekil 8. */ import javax.swing. JPanel pane = new JPanel() pane.add(b1) pane.add(b2) pane.add(b3) //Add JPanel to this applet, using the default BorderLayout. Şekil 9. ButtonDemoApplet.java sonuçlarının swing JApplet olarak Appletviewer browserında görüntüsü Programdan da görüldüğü gibi bu program bir önce verilmiş olan programın swing frame benzeridir. İki program da Applet olarak verilmiştir. Programlarda setEnabled(Boolean b) metodu kullanılarak düğmenin çalışması etkisisz hale getirilmiştir. URL network ortamında bilgi aktarmaya yarayan bir sınıftır. Resim dosyası başka bir bilgisayarda olabilirdi. TextField'in metotları aşağıda verilmiştir  Kurucu Metotlar public TextField() public TextField(int satırsayısı) // satır sayısı uzunluğunda bir yazı kutusu açar. public TextField(String s) // s uzunluğunda bir yazı kutusu açr ve s yi içine yazar public TextField(String s,int satırsayısı) ) // satır sayısı uzunluğunda bir yazı kutusu açr ve s yi içine yazar  Diğer Metotlar Public void setEchoChar(char c) // kutudaki gerçek yazıyı gizleyerek onun yerine c karacter değişkenini yazar. Public void setEditable(boolean b) //kutunun içine yazılan yazının degiştirileblmesini sağlar veya engeller b=true yazı yazılabilir b=false yazı yazılamaz. * import java.awt.event. TextField sınıfının java swing eşdeğeri JTextField sınıfıdır. JTextField sınıfı kurucu metotları JTextField() JTextField(String) JTextField(String, int) JTextField(int) JTextField(Document, String, int) Şeklindedir. TextFielde Paralel olarak Özel bir TextField türü olan PasswordField de swingde tanımlanmıştır. PassWord fieldin kurucu metod tanımları JPasswordField() JPasswordField(String) JPasswordField(String, int) JPasswordField(int) JPasswordField(Document, String, int) Şeklinde tanımlanmıştır. Bu iki sınıfın Text değerini girmak veya okumak için void setText(String) String getText() metodları tanımlanmıştır. void setEditable(boolean) boolean isEditable() metodları Yazı alanındaki yazıyı kullanıcının değiştirp değiştiremeyaceğini saptar veya bu müsadeyi değiştirir. void setColumns(int) int getColumns() int getColumnWidth() metodları yazı alanının byutunu değiştirmek veya saptamak amacıyla kullanılabilir. void setHorizontalAlignment(int) int getHorizontalAlignment() metodları yazıı alanındaki yazının ne şekilde yerleştirildiğini saptar veya isteğe göre yerleştirir. void addActionListener(ActionListener) metodları ise TextFieldin dinlenmesini ve giriş tuşu basıldığında yapılacak eylemlerin verildiği ActionListener implement'inden gelen public void actionPerformed(ActionEvent e) metodunu çalıştırmaya yarar. void removeActionListener(ActionListener) ise ActionListener dinleme metodunu iptal eder. JTextField ve JPasswordField metodlarının kullanılmasını bir örnek problemle inceleyelim. Bu bir önceki problemin hemen hemen aynı işlemleri yapan JFrame ortamında yazılmış bir örnek problemdir. * import java.awt. * import java.awt.event. En onemli farkı bir satır yerine birden fazla satır girdi alabilme olasılığıdır. TextField ve TextArea sınıfları TextComponent sınıfının alt sınıflarıdır. Bu yüzden üstte belirttiğimiz Public void setEchoChar(char c) // kutudaki gerçek yazıyı gizleyerek onun yerine c karacter değişkenini yazar. Public void setEditable(boolean b) //kutunun içine yazılan yazının degiştirileblmesini sağlar veya engeller b=true yazı yazılabilir b=false yazı yazılamaz. Metotları burada da aynen geçerlidir.TextArea'nınkurucu metotlarıda şöyledir public TextArea() public TextArea(int sütun,int satır) sütun x satır boyutunda yazı alanı tanımlar public TextArea(String s) String değişkeni s nin boyuna göre yazı alanı tanımlar ve s yi içine yazar. Alt satıra geç ve gelecek tab noktasına git anlamına gelir Bu komutlar aslında c dilinden alınmadır ve c dilindeki tüm \ komutları java stringlerinde de geçerlidir. * import java.awt.event. Buradaki metot birinci kutuya yazılan yazıyı ikinci kutuya kopyalamaktadır. Kopye düğmesine basılınca ise sadece T1.getSelectedText() metotuyla secilmiş olan text actionPerforned metotu üzerinden T2 Yazım Alanına (TextArea) aktarılmaktadır. Java swing JTextArea sınıfı awt deki TextArea sınıfının benzeridir. Sınıfın kurucu metodlarının tanımı public JTextArea() public JTextArea(int rows,int cols) public JTextArea(Document doc) public JTextArea(Document doc, String Text, int satırsayısı int sütun sayısı) public JTextArea(String Text) public JTextArea(String Text,int satırsayısı int sütun sayısı) şeklindedir. * import java.awt. * import java.awt.event. Choice sınıfının kurucu metotu ve diger metotlarının listesi aşağıda verilmiştir public Choice() // Kurucu metot public String getItem(int indeks) İndeksteki seçimi verir public synchronised void add(String s) verilen Stringi Choice listesine ekler. * import java.applet.Applet import java.awt.event. Choice seçimlerini yukarıdaki ChoiceTesti.html de de görüleceği gibi aktarılırken ItemListener ve ItemEvent kullanılmıştır. Bu metotla kullanılması gereken method ItemStateChanged metotudur. Onun yerini JComboBox sınıfı almıştır JComboBox sınıfının Kurucu metodları public JComboBox() public JComboBox(ComboBoxModel m) public JComboBox(Object obj[]) public JComboBox(Vector v) şeklindedir. Vector gelişmiş bir boyutlu değişken türüdür detayları 11 inci bölüm, gelişmiş java bilgi işleme yapıları kısmında verilmiştir. ComboBox Jcomponent sınıfından türetilmiştir. ActionListener, ItemSelectable, ListDataListener ve Accessible sınıflarını implement eder. JComboBox sınıfı, seçilen sınıfı size veren veya seçilme opsiyonunu tanımlayan şu sınıfları barındırır getSelectedItem() bu noktadaki Object değerini çağırır. getSelectedIndex() bu noktanın indeks değerini çağırır getSelectedObjects() birden fazla seçim yapıldığında tüm seçilen object listesini iletir. * import javax.swing. * import java.awt.event. public void itemStateChanged(ItemEvent e) { C.setFont(new Font(e.getItem().toString(), C.getFont().getStyle(), C.getFont().getSize())) } } class TextFieldKontrolu implements ItemListener { private JTextField T public TextFieldKontrolu(JTextField T) { this.T=T } public void itemStateChanged(ItemEvent e) { JComboBox C=(JComboBox)e.getItemSelectable() T.setText( Indeks + C.getSelectedIndex()+ Font +e.getItem()) }} Kurucu metotları Public CheckBox(String s) Tek bir kare kontrol kutusu oluşturur. Kontrol kutusu başta boştur Public CheckBox(String s, CheckBoxGroup c,boolean durum) Tekbir daire şeklinde kontrol kutusu oluşturur ve bu kontrol kutusunu CheckBoxGroup nesnesine ilave eder. * import java.awt.event. * public class CheckBoxTesti extends Applet implements ItemListener { private TextField T private Checkbox Kalin,Italic public void init() { setBackground(Color.lightGray) //bos textField T=new TextField( Buradaki yazinin degismesini izleyiniz ) add(T) Kalin=new Checkbox( Kalin ) Kalin.addItemListener(this) add(Kalin) Italic=new Checkbox( Italik ) Italic.addItemListener(this) add(Italic) } public void itemStateChanged(ItemEvent e) Burada guruplanmış olan checkbox'lardan sadece bir tanesini seçme izni verilmiştir. * import java.awt.event. else if(e.getSource()== Italic) {T.setFont(ItalicFont) } else if(e.getSource()== KalinItalic) {T.setFont(KalinItalicFont) } } } JCheckBox sınıfının kurucu metodları public JCheckBox() public JCheckBox(Icon resim) public JCheckBox(Icon resim,boolean kutuişareti) public JCheckBox(String yazı) public JCheckBox(String yazı, boolean kutuişareti) public JCheckBox(String yazı, Icon resim) public JCheckBox(String yazı, , Icon resim ,boolean kutuişareti) Burada da daha önceki JLabel, JButton gibi sınıflarda gördüğümüz gibi yazının yanında resim yerleştirme seçimimiz de mevcuttur. Buradaki örnek problemde bir önceki problemin aynısı JcheckBox ile çözülmüştür. * import java.awt. * import java.awt.event. Kurucu metodları public JRadioButton() public JRadioButton(Icon resim) public JRadioButton(Icon resim,boolean kutuişareti) public JRadioButton(String yazı) public JRadioButton(String yazı, boolean kutuişareti) public JRadioButton(String yazı, Icon resim) public JRadioButton(String yazı, , Icon resim ,boolean kutuişareti) Burada JRadioButton sınıfına ilave olarak bir tane daha ilave olarak bir tane daha yardımcı sınıf kullanacağız. Bu sınıf ButtonGroup sınıfıdır. Bu sınıf düğmeleri bir gurup altında toplayarak sadece bir tanesinin basılı durumda olması işlevini kontrol eder. Bu sınıfın tanımı public class ButtonGroup extends Object implements Serializable { protected Vector düğmeler public ButtonGroup() public void add(AbstractButton ab) public Enumeration getElements() public ButtonModel getSelection() public boolean isSelected(ButtonModel bm) public void remove(AbstractButton ab) public void setSelected(ButtonModel bm,boolean b) } şeklindedir. Şimdi yine bir öncekine benzer bir örnekte JradioButton ve ButtonGroup sınıflarının birarada kullanımını görelim. * import java.awt. * import java.awt.event. * public class RadioButtonTestiSWF extends JFrame implements ItemListener } public static void main(String[] args) { RadioButtonTestiSWF pencere= new RadioButtonTestiSWF() pencere.addWindowListener(new BasicWindowMonitor()) pencere.setSize(400,100) pencere.setVisible(true) } } JToggleButton sınıfı işlevsel olarak JcheckBox sınıfının aynıdır. Sadece basılım alanı düğme(button) şeklindedir. JcheckBox için verdiğimiz programın JToggleButton'a dönüştürülmüş şekli aşağıda verilmiştir. * import java.awt. * import java.awt.event. Javada gurubunda temel fare kontrollarını sağlayan sınıflar MouseListener ve MouseMotionListener sınıflarıdır. Bu sınıfların en çok kullanılan metotları şunlardır 1. MouseListener Metotları public void mousePressed(MouseEvent e) bir mouse düğmesi basılınca çağırılır public void mouseClicked(MouseEvent e) bir mouse düğmesi basılıp bırakılırsa çağırılır. public void mouseReleased(MouseEvent e) Bir mouse düğmesi basılı olarak mouse çekildikten sonra düğme bırakılınca çağırılır. public void mouseEntered(MouseEvent e) mouse pencere içine girince çağırılır. public void mouseExited(MouseEvent e) mouse pencere çerçevesinin dışındaysa çağırılır. 2. MouseMotionListener Metotları public void mouseDragged(MouseEvent e) Mouse düğmesi basılı iken mouse hareket ettirilirse çağırılır public void mouseMoved(MouseEvent e) Mouse hareket ederse çağırılır. Bu metotların kullanımlarını göstermek amacıyla FareTesti.java programı aşağıda verilmiştir. Bu program awt Applet programı olarak hazırlanmıştır. * import java.awt.event. * public class FareTesti extends Applet implements MouseListener, MouseMotionListener { private int nx,ny=-10 private String s= public void init() { addMouseListener(this) addMouseMotionListener(this) } public void paint(Graphics g) { g.drawString(s+ [ +nx+ , +ny+ ] ,nx,ny) } public void degerleriGir(String e,int x,int y) { s=e nx=x ny=y repaint() } //fare dinleyicisinin dinledikleriyle ilgili cikti metotlari public void mouseClicked(MouseEvent e) { degerleriGir( Kliklendi ,e.getX(),e.getY()) } public void mousePressed(MouseEvent e) { degerleriGir( Basildi ,e.getX(),e.getY()) } public void mouseReleased(MouseEvent e) { degerleriGir( Birakildi ,e.getX(),e.getY()) } public void mouseEntered(MouseEvent e) { showStatus( Fare applet alani icinde ) } public void mouseExited(MouseEvent e) { showStatus( Fare applet alani disinda ) } //MouseMotionListener (fare hareket dinleyicisi) metotlari public void mouseDragged(MouseEvent e) { degerleriGir( basilip cekiliyor ,e.getX(),e.getY()) } public void mouseMoved(MouseEvent e) { degerleriGir( hareket halinde ,e.getX(),e.getY()) } } * import java.awt. * import java.awt.event. public void mouseEntered(MouseEvent e) { setTitle( Fare applet alanı içinde ) } public void mouseExited(MouseEvent e) { setTitle( Fare applet alanı dışında ) degerleriGir( Fare applet alanı dışında ,e.getX(),e.getY()) } //MouseMotionListener (fare hareket dinleyicisi) metotlari public void mouseDragged(MouseEvent e) { degerleriGir( basilip cekiliyor ,e.getX(),e.getY()) } public void mouseMoved(MouseEvent e) { degerleriGir( hareket halinde ,e.getX(),e.getY()) } public static void main(String[] args) { FareTestiSWF pencere= new FareTestiSWF() pencere.addWindowListener(new BasicWindowMonitor()) pencere.setSize(350,150) pencere.setVisible(true) } } JTable sınıfının kurucu sınıfları public JTable() public JTable(TableModel tm) public JTable(TableModel tm, TableColumnModel tcm) public JTable(TableModel tm, TableColumnModel tcm, ListSelectionModel lm) public JTable(int satırsayısı,int sütunsayısı) public JTable(Object[][] tablogirdisi ,Object[] tablobaşlığıgirdisi) public JTable(Vector tablogirdisi ,Vector tablobaşlığıgirdisi) şeklindedir. Kurucu metodlarda girdi olarak görünen TableModel sınıfı public interface TableModel{ public abstract void addTableModelListener(TableModelListener l) public abstract Class getColumnClass(int sütun) public abstract int getColumnCount() public abstract String getColumnName(int Column) public abstract int getRowCount() public abstract Object getValueAt(int satır, int sütun) public abstract boolean isCellEditable(int satır, int sütun) public abstract void removeTableModelListener(TableModelListener l) public abstract void setValueAt(Object o.int satır,int sütun) } görüldüğü gibi bu sınıf interface olduğundan bu sınıftan türetilen sınıfların bu sınıftaki tüm metodları tanımlamaları gerekir. Bu yüzden AbstractTableModel gibi Table Model'den türetilen sınıflar üzerinden yeni sınıfın türetilmesine gidilebilir. public abstract class AbstractTableModel implements TableModel { public AbstractTableModel() public abstract void addTableModelListener(TableModelListener l) public int findColumn(String ColumnName) public void fireTableCellUpdated(int satır,int sütun) public void fireTableChanged(TableModelEvent e) public void fireTableDataChanged() public void fireTableRowsDeleted(int satır,int sütun) public void fireTableRowsInserted(int satır,int sütun) public void fireTableRowsUpdated(int satır,int sütun) public void fireTableStructureChanged() public abstract Class getColumnClass(int sütun) public abstract String getColumnName(int Column) public abstract boolean isCellEditable(int satır, int sütun) public abstract void removeTableModelListener(TableModelListener l) public abstract void setValueAt(Object o.int satır,int sütun) } Örnek problemlerde önce AbstractTableModel'den türetilen ve Tablonun giriş değerlerini veren TableModel sınıfı yaratılmış, sonra bu sınıf tabloda girdi olarak kullanılmıştır. * import java.awt.event. * import javax.swing. * import javax.swing.table. * import javax.swing.event. //===================================================== public static void main(String[] args) { tableSWF_2000 pencere= new tableSWF_2000() pencere.setVisible(true) } } * import java.awt.event. * import javax.swing. * import javax.swing.table. * import javax.swing.event. List ve Jlist sınıfları bir listeden seçim yapmaya ve bu seçim sonucu gerekli işlemleri oluşturmaya yarar. List sınıfı ItemListener ve ActionListener sınıf implementlerini kullanır. Örnek programımızda Listeden seçilen renge göre arkaplan rengi değişmektedir. * import java.awt.event. * public class ListTesti extends Applet implements ActionListener,ItemListener { private List renkListesi private String renkIsmi[]={ Siyah , Mavi , Cam Gobegi , Koyu Gri , Gri , Yesil , Acik gri , Mor , Portakal , Pembe , Kirmizi , Beyaz , Sari } private Color C[]={Color.black,Color.blue,Color.cyan,Color.darkGray, Color.gray,Color.green,Color.lightGray,Color.magenta,Color.orange, Color.pink,Color.red,Color.white,Color.yellow} public void init() { //Ekranda 5 isim g rlebilecel bir liste ac //ayn ismi birden fazla tekrarlama renkListesi=new List(5,false) renkListesi.addActionListener(this) renkListesi.addItemListener(this) //listeye ekle for(int i=0 i<renkIsmi.length i++) { renkListesi.add(renkIsmi[i]) } add(renkListesi) } public void actionPerformed(ActionEvent e) { setBackground(C[renkListesi.getSelectedIndex()]) repaint() } public void itemStateChanged(ItemEvent e) { showStatus(renkListesi.getSelectedItem()+ indeks + renkListesi.getSelectedIndex()) } } Jlist metodu pencereye ilave edilirken direk olarak ilave edilmez, JscrollPane alt pencere programı üzerinden ilave edilir. Aynı zamanda dinleme metodu olarak ListSelectionListener metodu kullanılır. Bu metod java swing kütüphanesi javax.swing.event de tanımlanmıştır. JList metoduyla bir seçim yapıldığı gibi birden fazla seçim yapmakta mümkündür. JList metodunun kurucu metodları public JList() public JList(ListModel lm) public JList(Object o[]) public JList(Vector v) dir. Seçimde kullanılan bazı önemli metodları public int GetSelectedIndex() seçilen (veya en son seçilen) elemanın indisini verir public int[] getSelectedIndices() seçilen elemanların (birden fazla olabilir) indislerini boyut üzerinden aktarır public Object getSelectedValue() son seçilen elemandaki değeri Object olarak aktarır. public object[] getSelectedValues() seçilen elemanlardaki değerleri boyutlu object olarak aktarır void setSelectionMode(int mode) tek eleman mı seçileceğini yoksa çok sayıda eleman mı seçileceğini belirler. Public void setVisibleRowCount(int sayı) listenin kaç elemanının görüntüleneceğini verir. Listenin kenar kayma çubukları, listenin içinde yer alacağı JScrollPane penceresi tarafından oluşturulur. JScrollPane metodunun kurucu metodları public JScrollPane() public JScrollPane(int düşeyçubukçeşidi,int yatayçubukçeşidi) public JScrollPane(Component pencere) public JScrollPane(Component pencere ,int düşeyçubukçeşidi,int yatayçubukçeşidi) Buradaki pencere JScrollPane'in içinde yeralacağı container'ı gösterir. Yatayçubukçeşidi ise JScrollPane. Birkaç örnek problemle Jlist sınıfını vermetye çalışalım. İlk örnek yukarıdaki JcomboBox problemlerin aynı işlemini yapmaktadır. Listeden yapılan seçime göre JtextField alanındaki fontu değiştirecektir. Listenin iki elemanının görülmesi müsadesi verilmiştir. Liste tek seçimli listedir. * import javax.swing. * import java.awt.event. * import javax.swing.event. Bu örnekte ise listeden yapacağımız seçime göre arka plan rengini değiştiriyoruz. Bu program yukarıda verilen List programının oldukça benzeridir. Listede dört elemanın görülmesi izni verilmiştir. Liste tek seçimli bir listedir. * // java swing sinifini cagir import javax.swing.event. * import java.awt. * // java pencere kullanma sinifini cagir import java.awt.event. Diğer bir Liste kullanma örneği Bu örnekte Listeye JtextField üzerinden ilave yapabiliyoruz ve çıkarabiliyoruz. Örnek Java döküman kütüphanesinden alınıp adapte edilmiştir. * import java.awt.event. * import javax.swing. * import javax.swing.event. int index = list.getSelectedIndex() listModel.remove(index) int size = listModel.getSize() //Listede eleman kalmadı işten atmayı durdur if (size == 0) { fireButton.setEnabled(false) //seçimi düzenle } else { if (index == listModel.getSize()) index-- list.setSelectedIndex(index) } } } class HireListener implements ActionListener { public void actionPerformed(ActionEvent e) { //Eğer yeni isim girilmemişse if (employeeName.getText().equals( )) { Toolkit.getDefaultToolkit().beep() return } int index = list.getSelectedIndex() int size = listModel.getSize() if (index == -1 || (index+1 == size)) { listModel.addElement(employeeName.getText()) list.setSelectedIndex(size) } else { listModel.insertElementAt(employeeName.getText(), index+1) list.setSelectedIndex(index+1) } } } public void valueChanged(ListSelectionEvent e) { if (e.getValueIsAdjusting() == false) { if (list.getSelectedIndex() == -1) { fireButton.setEnabled(false) employeeName.setText( ) } else { fireButton.setEnabled(true) String name = list.getSelectedValue().toString() employeeName.setText(name) } } } public static void main(String s[]) { JFrame frame = new ListDemoSWF() frame.addWindowListener(new BasicWindowMonitor()) frame.pack() frame.setVisible(true) } } Aşağıdaki örnekte listeden Liste türü değişkeninde yaptığımız değişikliğe göre bir veya birden fazla seçim yapabiliyoruz . Bu program hem JFrame hem de Japplet olarak çalışabilmektedir. * import javax.swing.event. * import javax.swing.table. * import java.util. * import java.awt. * import java.awt.event. * public class ListSelectionDemo extends JApplet { JTextArea output JList list JTable table String newline = \n ListSelectionModel listSelectionModel private boolean inAnApplet = true //bazı sistemlerde ana kurucu metod olmayınca hata verebileceği // için tanımlandı. // Find out which indexes are selected. int minIndex = lsm.getMinSelectionIndex() int maxIndex = lsm.getMaxSelectionIndex() for (int i = minIndex i <= maxIndex i++) { if (lsm.isSelectedIndex(i)) { output.append( + i) } } } output.append(newline) } } } Menuler pencerenin tepesinden açılan ve çeşitli görevler yüklenen komponentlerdir. Java swing menu'leri temel olarak JMenuBar, JMenu ve JMenuItem sınıflarından oluşur. Ayrıca menulerde JcheckBoxMenuItem, JradioButtonMenuItem gibi alt elemanlar da bulunabilir. JmenuBar kurucu metodu Public JmenuBar() Şeklindedir. Bazı önemli metodları public JMenu add(JMenu menu) menu ilave eder public Component getComponent() public Component getComponentAtIndex(int indeks) public Insets getMargin() public Jmenu getMenu(int) public int getMenuCount() public SingleSelectionModel getSelectionModel() public MenuElement[] getSubElements() protected void paintBorder(Graphics g) public void processMouseEvent(MouseEvent e,MouseElement path[],MouseSelectionManager mgr) public void setBorderPainted(boolean b) public void setHelpMenu(Jmenu menu) public void setMargin(Insets in) pubic void setSelected(Component c) Jmenu kurucu metodları public JMenu() public JMenu(String Label) public JMenu(String label,boolean menudenayır) Bazı önemli JMenu metodları public JMenuItem add(Action act) public JMenuItem add(JMenuItem item) public Component add(Component c) public void add(String Jlabel) public void addMenuListener(MenuListener l) public void addSeperator() public JMenuItem getItem(int pos) public int getItemCount() public Component getMenuComponent(int pos) public int getMenuComponentCount() public Component[] getMenuComponents(public MenuElement[] getSubElements() public JMenuItem insert(JMenuItem item,int pos) public void insert(String etiket,int pos) public void remove(int pos) public void remove(MenuItem item) public void removeAll() public void removeMenuListener(MenuListener l) public void setAccelerator(KeyStroke s) public void setDealy(int delay) public void setMenuLocation(int x,int y) public void setPopUpMenuVisible(boolean b) public void setSelected(boolean b) JMenuItem kurucu metodları public JMenuItem() public JMenuItem(Icon resim) public JMenuItem(String Label) public JMenuItem(String Label,int mnemonic) public JMenuItem(String Label,Icon resim) bazı metodları publci Component getComponent() public menuElement[] getSubElements() JCheckBoxMenuItem, JMenuItem sınıfının bir alt sınıfı olarak oluşturulmuştur. Davranışı JCheckBox sınıfı gibidir. Kurucu metodları public JCheckBoxMenuItem() public JCheckBoxMenuItem(Icon resim) public JCheckBoxMenuItem(String Label) public JCheckBoxMenuItem(String Label,Icon resim) public JCheckBoxMenuItem(String Label,Boolean seçildimi) public JCheckBoxMenuItem(String Label,Icon resim, Boolean seçildimi) JRadioButtonMenuItem' da JMenuItem'ın alt sınıfı olarak oluşturulmuştur. Kurucu metodları public JRadioButtonMenuItem () public JRadioButtonMenuItem (Icon resim) public JRadioButtonMenuItem (String Label) public JRadioButtonMenuItem (String Label,Icon resim) Şimdi bu metodları kullanan bir örnek menu oluşturalım. Örnek menu sadece menu yapısını göstermek amaçlı olduğundan fazla bir eyem yamamaktadır. Gerçek programlarınızda gerekli eylemleri yereştirebilirsiniz. * import java.awt.event. * import javax.swing.JMenu import javax.swing.JMenuItem import javax.swing.JCheckBoxMenuItem import javax.swing.JRadioButtonMenuItem import javax.swing.ButtonGroup import javax.swing.JMenuBar import javax.swing.KeyStroke import javax.swing.ImageIcon import javax.swing.JTextArea import javax.swing.JScrollPane import javax.swing.JFrame /* * Menu Demo */ public class MenuDemo extends JFrame implements ActionListener, ItemListener { JTextArea output JScrollPane scrollPane String newline = \n public MenuDemo() { JMenuBar menuBar JMenu menu, submenu JMenuItem menuItem JRadioButtonMenuItem rbMenuItem JCheckBoxMenuItem cbMenuItem addWindowListener(new BasicWindowMonitor()) //Add regular components to the window, using the default BorderLayout. menuBar = new JMenuBar() setJMenuBar(menuBar) //Build the first menu. menu = new JMenu( İknci bir Menu ) menu.setMnemonic('n') menu.getAccessibleContext().setAccessibleDescription( Bu menu hiç bir şey yapmaz ve alt elemanı yoktur ) menuBar.add(menu) } public void actionPerformed(ActionEvent e) { JMenuItem source = (JMenuItem)(e.getSource()) String s = Action event kaydedildi + newline + Event kaynağı + source.getText() + (sınıfın adı + getClassName(source) + ) output.append(s + newline) } public void itemStateChanged(ItemEvent e) { JMenuItem source = (JMenuItem)(e.getSource()) String s = Item event kaydedildi. seçildi seçim iptal edildi ) output.append(s + newline) } // Sınıfın adını verir protected String getClassName(Object o) { String classString = o.getClass().getName() int dotIndex = classString.lastIndexOf( . ) return classString.substring(dotIndex+1) } public static void main(String[] args) { MenuDemo window = new MenuDemo() window.setTitle( MenuDemo ) window.setSize(450, 260) window.setVisible(true) } } * import java.awt. * import yildizSW import java.awt.geom. * import renk public class ovalPanelSWP extends JPanel { int xi,yi,yaricap public ovalPanelSWP(int xi1, int yi1,int yaricap1) { xi=xi1 yi=yi1 yaricap=(yaricap1 >= 0 . yaricap1 10) } public void setOvalPanelSWP(int xi1, int yi1,int yaricap1) { xi=xi1 yi=yi1 yaricap=(yaricap1 >= 0 . * // java swing sinifini cagir import java.awt. * // java pencere kullanma sinifini cagir import java.awt.event. * // java pencereyi dinleme sinifini cagir import BasicWindowMonitor import ovalPanelSWP import javax.swing.event. Daire JPanel sınıfında çizilmiştir. Daireyi çizmek için ovalPanelSWP sınıfını yarattık. JPanel sınıfında kurucu metodlarımızı herhangi bir sınıfta olduğu gibi tanımladık ve public void paintComponent(Graphics g) metodu ve Graphics sınıfı üzerinden çizimimizi tanımladık. Tekrar çizdirmek için repaint() metodunu kullandık. İkinci JFrame proramımızda StateChanged event metodundaki p.setOvalPanelSWP(30, 30,cap.getValue()) komutuyla da çapını değiştirip repaint() komutuyla tekrar çizdirdik. awt grafik interface'inde default değer olarak kullanılan Layout sınıfı FlowLayout sınıfıdır. Swing arayüz programlarında ise BorderLayout sınıfı default olarak kullanılar. Flow layout sınıfı grafik ortamına (Panel, Applet, Frame, Jpanel, Japplet, JFrame vs.) alt elemanları yerleştirirken soldan sağa doğru akleme (add) sırasıyla yerleştirir. Penceredeki yer bittiyse bir alt satıra geçer. Bu değerlere göre içerdiği elemanları sağa ortaya veya sola yerleştirir. Yatay_bosluk pixel olarak yatay posisyonda elemanlar arasında kalan boslugu gosterir. Dikey bosluk ise dikey dogrultudaki pixel olarak boşluktur. Küçuk bir örnek problemle FlowLayout kullanımını daha açık hale getirebiliriz. * import java.awt.event. * public class FlowLayoutTesti extends Applet implements ActionListener { private Button B[] public void init() { B=new Button[3] B[0]=new Button( Sol ) B[1]=new Button( Orta ) B[2]=new Button( Sag ) for(int i=0 i<B.length i++) * import java.awt. * import java.awt.event. Bu sınıf swing grafik kütüphanesinde default formatlama sınıfı olarak seçilmiştir. BorderLayout sınıfının kurucu metotları şunlardır public BorderLayout() public BorderLayout(int yatay_bosluk,int dikey_bosluk) yatay_bosluk ve dikey_basluk pixel olarak alınır. GUI elemanlarının arasındaki bosluk miktarını tanımlar. Şimdi bir örnekle sınıfı açıklamaya çalışalım. * import java.awt.event. * import java.awt. * import java.awt.event. GridLayout sınıfının kurucu metotları şöyledir public GridLayout(int satırlar,int sütunlar) publicGridLayout(int satırlar,int sütunlar,int yatay_bosluk,int dikey_bosluk) yatay_bosluk ve dikey_basluk pixel olarak alınır. GUI elemanlarının arasındaki bosluk miktarını tanımlar. Şimdi bir örneklerle bu sınıfı açıklamaya çalışalım. * import java.awt.event. * import java.awt. * import java.awt.event. } public void actionPerformed(ActionEvent e) { for(int i=0 i<B.length i++) { if(e.getSource()==B[i]) B[i].setVisible(false) else B[i].setVisible(true) } c.validate() } public static void main(String[] args) { GridLayoutTestiSWF_2000 pencere= new GridLayoutTestiSWF_2000() pencere.addWindowListener(new BasicWindowMonitor()) pencere.setSize(400,200) pencere.setVisible(true) } } Değişik sayfalar halinde bir grafik arayüzü çağırır. Bu sayfalardan istenilen seçilerek kullanılabilir. Her sayfa bağımsız bir grafik ortamı oluşturur. * import java.awt. * import java.awt.event. * public class JTabbedPaneTestiSWF_2000 extends JFrame implements ActionListener { private JButton B[] private String S[]={ Düğme 1 , Düğme 2 , Düğme 3 , Düğme 4 , Düğme 5 , Düğme 6 } private Container c public JTabbedPaneTestiSWF_2000() { super( JTabbedPane formatlama Grafik ara yüz (GUI) testi ) c=getContentPane() c.setLayout(new BorderLayout(5,5)) B=new JButton[6] JTabbedPane jtp=new JTabbedPane() for(int i=0 i<B.length i++) { B[i]=new JButton(S[i]) B[i].addActionListener(this) jtp.addTab(S[i],B[i]) } c.add(jtp) } public void actionPerformed(ActionEvent e) { for(int i=0 i<B.length i++) { if(e.getSource()==B[i]) B[i].setText(S[i]+ düğmeye basıldı ) else B[i].setText(S[i]) } c.validate() } public static void main(String[] args) { JTabbedPaneTestiSWF_2000 pencere= new JTabbedPaneTestiSWF_2000() pencere.addWindowListener(new BasicWindowMonitor()) pencere.setSize(400,200) pencere.setVisible(true) } } Bu ikiye bölme işlemlerini yineleyerek istediğimiz alt parçaları oluşturabiliriz. JSplitPane ile bölünen alt parçalar fare ile çekilerek büyütülüp küçültülebilir. Böylece birbirinden bağımsız dört ayrı alt parça (split) oluşturuyoruz. * import java.awt. * import java.awt.event. public void actionPerformed(ActionEvent e) { for(int i=0 i<B.length i++) { if(e.getSource()==B[i]) B[i].setText(S[i]+ düğmeye basıldı ) else B[i].setText(S[i]) } c.validate() } public static void main(String[] args) { JSplitPaneTestiSWF_2000 pencere= new JSplitPaneTestiSWF_2000() pencere.addWindowListener(new BasicWindowMonitor()) pencere.setSize(400,200) pencere.setVisible(true) } } Bu formatlama sınıfı Scrollbar adını verdiğimiz yatay ve düşey kaydırma çubukları yardımıyla küçük bir pencereye sığmayacak kadar büyükolan grafiklerin kullanılmasını sağlar. * import java.awt. * import java.awt.event. } c.validate() } public static void main(String[] args) { JScrollPaneTestiSWF_2000 pencere= new JScrollPaneTestiSWF_2000() pencere.addWindowListener(new BasicWindowMonitor()) pencere.setSize(400,200) pencere.setVisible(true) } } Panel sınıfı applete yerleştirebileceğimiz alt bolgeler oluşturur. Hemen bir ornekle paneli nasıl kulandığımızı açıklamaya çalışalım. * import java.awt.event. JPanel'i formatlama işleminde aynı Panel sınıfında olduğu gibi bir alt formatlama elemanı olarak kullanabiliriz. Zaten bütün swing programlarının temeli de JPanel sınıfıdır. Swing gurubunda bir üstteki problemin aynısını JApplet olarak yineledik. Awt penceresi ve swing penceresi arasındaki en önemli farkın awt de add terimini appletin bir alt terimi gibi kullanabilirken, swingde getContentPane() deyimiyle ana JPanel'i çağırmak ve çizimleri bunun üzerine yapmak olduğunu bir kere daha yineleyelim. * import java.awt. * import java.awt.event. * import java.applet.Applet import java.awt.event. * import javax.swing. * import java.awt.event. Java swing gurubunda aynı zamanda kullanılmaya hazır bir çok grafik arayüzleri tanımlanmıştır. Bunların en çok kullanılanı, ve bu kitapta da şu ana kadar yoğun olarak kullanageldiğimiz JOPtionPane sınıfıdır. Bu sınıfın ana gayesi pop-up mesaj ve girdi ortamı sağlamaktır. JoptionPane sınıfını programımızda kurucu metod kullanarak kurmamız gerekmez. Temel olarak direk statik metodlarını çağırırız. JoptionPane panelinde genellikle bir resim,bir yazı alanı, bir girdi alanı (JtextField alanı), birde Seçilebilen düğmeler bulunur. JoptionPane'in girdi/çıktı olarak kullanılabilen başlıca metodları şunlardır public static String showInputDialog(Object mesaj) public static String showInputDialog(Component anapencere,Object mesaj) public static String showInputDialog(Component anapencere,Object mesaj,String başlık,int mesajtürü) public static String showInputDialog(Component anapencere,Object mesaj,String başlık,int mesajtürü, Icon resim, Object[] listeseçmedeğerleri, Object girişdeğeri) public static String showInternalInputDialog(Component anapencere,Object mesaj) public static String showInternalInputDialog(Component anapencere,Object mesaj, String başlık,int mesajtürü) public static String showInternalInputDialog(Component anapencere,Object mesaj,String başlık,int mesajtürü, Icon resim, Object[] listeseçme değerleri,, Object girişdeğeri) public static void showMessageDialog(Component anapencere,Object mesaj) public static void showMessageDialog(Component anapencere,Object mesaj,String başlık,int mesajtürü) public static void showMessageDialog(Component anapencere,Object mesaj,String başlık,int mesajtürü, Icon resim) public static void showInternalMessageDialog(Component anapencere,Object mesaj) public static void showInternalMessageDialog(Component anapencere,Object mesaj,String başlık,int mesajtürü) public static void showInternalMessageDialog(Component anapencere,Object mesaj,String başlık,int mesajtürü, Icon resim) public static int showConfirmDialog(Component anapencere,Object mesaj) public static int showConfirmDialog(Component anapencere,Object mesaj,String başlık,int mesajtürü) * import java.awt. Renk seçmeye yarar ve renk seçilmesi gereken her yerde kullanılabilir. Bir önceki bölümdeki bir alıştırmada bu özelliği kullanmıştık. * import java.awt.event. * import javax.swing. * import javax.swing.event. * import javax.swing.colorchooser. * public class ColorChooserDemo extends JFrame { public ColorChooserDemo() { super( ColorChooser Renk seçici ) //Pencerenin tepesinde bir JLabel açalım final JLabel etiket = new JLabel( Java Programlama diline Hoş geldiniz. Bilgisayardan bir dosyayı seçme ileminde yararlanılır. Dosya prosesleri konusunda Java Girdi çıktı programlanması bölümüne bakınız. * import java.awt. * import java.awt.event. * import javax.swing. * import javax.swing.filechooser. log.append( Dosya açılıyor + file.getName() + . + newline) } else { log.append( Dosyanın açılması kullanıcı tarafından iptal edildi. //gerçek dosyanın kaydedilme yeri.. log.append( Kaydediliyor + file.getName() + . + newline) } else { log.append( Dosyanın kaydedilmesi kullanıcı tarafından iptal edildi + newline) } } }) //Güzel bir görünüm için aç ve kapa düğmelerini ayrı bir panele yerleştir. JAR teknolojisi peogramların taşınmasını ve yeniden yüklenmesini daha kolay bir hale getirir. jar dosyasının içindeki dosyalara bakmak için jar tf isim.jar jar dosyası içindeki dosyaların listesini almak için jar xf isim.jar jar dosyasını applet içinden çalıştırmak için html içinde <applet code=AppletClassIsmi.class archive= JarDosyasiIsmi.jar width=width height=height </applet komutu kullanılır. Örnek olarak yine alıştırma 5 de kullanılan jar dosyasının html dosyasını verebiliriz. eğer listede sadece bir isim varsa bunu jar dosyası olarak alır ve içindeki tüm dosyaları listeler, eğer ilk simden sonra komutta başka isimler yer alıyorsa, sadece bu isimleri (eğer jarda mevcutsa) listeler. 0 sıkıştırma kullanma Veri akışını bir su akışı veya bir kablolu sistem üzerinden bilgi akışı gibi düşünebiliriz. Javada sadece dosya değil yazıcı, scanner gibi herhangi bir kaynağa veri iletmek istediğimizde bu veri akış sistemini kullanırız. Javada oldukça geniş bir veri akış kütüphanesi bulunmaktadır. java.io kütüphanesinde yer alan girdi çıktı programlama sınıfları şunlardır InputStream FilterInputStream LineNumberInputStream BufferedInputStream DataInputStream PushbackInputStream ByteArrayInputStream FileInputStream ObjectInputStream PipedInputStream SequenceInputStream StringBufferInputStream OutputStram ByteArrayOutputStream FileOutputStream FilterOutputStream BufferedOutputStream DataOutputStream PrintStream ObjectOutputStream PipedOutputStream ObjectStreamClass StreamTokenizer Reader FileReader BufferedReader LineNumberReader CharArrayReader FilterReader PushbackReader InputStreamReader FileReader PipedReader StringReader Writer BufferedWriter CharArrayWriter FilterWriter OutputStreamWriter PipedWriter PrintWriter StringWriter File FileDescriptor RandomAccessFile Bu sınıfların hepsinin genel görevi javaya girdi sağlamak ve çıktı almaktır. Burada bunlardan bir kısmının işlevlerini ve nasıl çalıştıklarını inceleyeceğiz. Önce temel ana sınıfların bazılarının tanımlarına daha detaylı bakalım. InputStream sınıfı byte türü yazı okuma sınıfıdır. Tüm byte türü bilgi akış kanalı sınıflarının ana sınıfıdır. Tanımı public abstract class InputStream extends Object { public InputStream() public int available() throws IOException public void close() throws IOException public synchronized void mark(int readlimit) public boolean markSupported() public abstract int read() throws IOException public int read(byte b[]) throws IOException public int read(byte b[],int off,int len) throws IOException public synchronized void reset() throws IOException public long skip(long n) throws IOException } InputStream sınıfının byte türü yazma pareleli olan OutputStream sınıfının tanımı ise public abstract class OutputStream extends Object { public outputStream() public void close() throws IOException public void flush() throws IOException public abstract void write(int b) throws IOException public void write(byte b[]) throws IOException public void write(byte b[],int başlamanoktası,int uzunluk) throws IOException } Abstract sınıf Reader, InputStream sınıfına olduça yakındır, yalnız data transferinde byte yerine char kullanır, böylece girdi çıktıda unicode stream kullanabilme olasılığı yakalar. public abstract class Reader extends Object { protected Reader() protected Reader(Object o) public abstract void close() throws IOException public void mark(int readlimit) throws IOException public boolean markSupported() public abstract int read() throws IOException public int read(char c[]) throws IOException public int read(char c[],int başlamanoktası,int uzunluk) throws IOException public boolean ready() throws IOException public void reset() throws IOException public long skip(long n) throws IOException } Abstract sınıf Writer da Output straem sınıfına eşdeğerdir. Fakat aynı readerda olduğu gibi bu sınıf da veri akışında char ve string kullanır. public abstract class Writer extends Object { public outputStream() public void close() throws IOException public void flush() throws IOException public abstract void write(int b) throws IOException public void write(char c[]) throws IOException public void write(char c[],int başlamanoktası,int uzunluk) throws IOException public void write(String s) throws IOException public void write(String s,int başlamanoktası,int uzunluk) throws IOException } Bu sınıflar temel sınıflardır. Bunların altında yer alan çeşitli sınıflara aşağıdaki bölümlerde daha detaylı bakacağız. File sınıfının tanımı Public class File extends Object implements Serializable, Comparable { public static final String pathSeperator public static final char pathSeperatorChar public static final String seperator public static final char seperatorChar public File(String dosya_ismi) public File(String dizin_ismi, String dosya_ismi) public File(File file_tipi_nesne,String dosya_ismi) File sınıfında tanımlanmış olan Metotlardan bazılarının tanımları şunlardır. canRead() Tanımlanan dosyadan bilgi okunulabilirliğini test eder. canWrite() Tanımlanan dosyaya bilgi yazılabilirliğini test eder. delete() Dosyayı siler equals(Object) Dosya ismini Object te verilen dosya ismiyle karşılaştırır. exists() Dosyanın mevcut olup olmadığını kontrol eder. getAbsolutePath() Dosyanın tam dizin ismini ve dosya ismini verir( co/java/prog/Hosgeldiniz.java). getName() Dosyanın ismini verir. (Hosgeldiniz.java) getParent() Dosyanın içinde bulunduğu dizinin ismini verir. (prog) getPath() dosyanın ismini ve içinde bulunduğu dizinin ismini verir. (prog/Hosgeldiniz.java) isAbsolute() Dosya isminin mutlak isim olup olmadığını kontrol eder. (Eğer dosya ismi co/java/prog/Hosgeldiniz.java olarak verilmişse true değeri verir.) isDirectory() verilen isimin bir dizin ismi olup olmadığını kontrol eder. isFile() verilen isimin