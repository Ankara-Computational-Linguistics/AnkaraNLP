Number_of_Data,int Number_of_Function,int ipt[]) public void addFunction(fi_x f,double xmin,double xmax,int Number_of_Data,int Number_of_Function, ================== Settings of additional plot information ================= ----------Plot Type ---------------------public void setPlotType(int plot_type[]) public void setPlotType(int dataset,int plot_no) public void setPlotType(int dataset,char plot_char) ----------x y grid on-off ---------------public void setXgrid(int igx) public void setYgrid(int igy) public void setGrid(int igx,int igy) public void setXtic(int ixt) public void setYtic(int iyt) public void setXYtic(int ixt,int iyt) ---------- Color setting for plot data -------public void setColor(int dataset,int ired,int igreen,int iblue) public void setColor(int ired[],int igreen[],int iblue[]) ================ Setting of Minimum Maximum fuctions =================== public void setMinMax() public void setMinMax(double xi[][],double yi[][]) public void setMinMax(double iminx,double imaxx,double iminy,double imaxy) =============== Plot Window Formatting ================================== public void set_plotwindow(int width,int height,double xip,double yip,double dxp,double dyp) public void setabsMaxMin(int ixmin,int iymin,int idx,int idy) ================ Actual Plotting of constructed data public void plot() */ public static double[] data(double xmin,double xmax,double dx) { int n=(int)((xmax-xmin)/dx)+1 double x[]=new double[n] for(int i=0 i<n-1 i++) {x[i]=xmin+dx*i } x[n-1]=xmax return x } public static double[] data(double xmin,double xmax,int n) { double dx=(xmax-xmin)/n double x[]=new double[n] for(int i=0 i<n i++) {x[i]=xmin+dx*i } return x } public Plot() throws IOException { //read input variables from Plot.txt //adding max-min prompts and input fields //initial values of max and mins // Structure of input file // filename // xlabel // ylabel // nline // datafilename plottype redcolor greencolor bluecolor // ........ // datafilename plottype redcolor greencolor bluecolor // // A sample data file input //========================== // filename public Plot(String pl,String xl,String yl,int xnt,int ynt ,int xgo,int ygo,String fn[],int ipt[],int ir[],int ig[] public Plot(String fn[]) throws IOException { //reading data from file(s) nline=fn.length int ipt[]=new int[nline] int ir[]=new int[nline] int ig[]=new int[nline] int ib[]=new int[nline] xmin=9.99e50 public Plot(double xi[][],double yi[][],int ipt[],int ir[],int ig[],int ib[]) { pp2(xi,yi,ipt,ir,ig,ib) } public void pp2(double xi[][],double yi[][]) { int ir[] int ig[] int ib[] int ipt[] int nn=xi.length ir=new int[nn] ig=new int[nn] ib=new int[nn] ipt=new int[nn] for(int i=0 i<nn i++) { ir[i]=0 xx+=dx } pp1(xi,yi,ipt,ir,ig,ib) } public Plot(f_x f,double xm,double xma,int N,int ipt,int ir,int ig,int ib) { pp3(f,xm,xma,N,ipt,ir,ig,ib) } public Plot(f_x f,double xm,double xma,int N,int ipt) { // reading data from a given function//one data set only int ir=0 int ig=0 int ib=0 pp3(f,xm,xma,N,ipt,ir,ig,ib) } public Plot(f_x f,double xm,double xma,int N) { // reading data from a given function//one data set only int ipt=0 int ir=0 int ig=0 int ib=0 pp3(f,xm,xma,N,ipt,ir,ig,ib) } public void pp4(fi_x f,double xm,double xma,int Number_of_Data,int Number_of_Function,int ipt[],int ir[],int ig[],int ib[]) { // reading data from a given functon set // same xmin xmax and Number_of_data for each function nline=Number_of_Function xmin=xm xmax=xma ymin=9.99e50 ymax=-9.99e50 double xtemp,ytemp n=new int[100] red=new int[100] green=new int[100] blue=new int[100] plottype=new int[100] ch=new char[100] int N=Number_of_Data double dx=(xmax-xmin)/N double xx=xmin int NF=Number_of_Function nline=NF double xi[][]=new double[NF][N] double yi[][]=new double[NF][N] double yy[]=new double[NF] for(int j=0 j<N j++) { yy=f.func(xx) for(int i=0 i<NF i++) { yi[i][j]=yy[i] xi[i][j]=xx } xx+=dx } pp2(xi,yi,ipt,ir,ig,ib) } public Plot(fi_x f,double xm,double xma,int Number_of_Data,int Number_of_Function, int ipt[],int ir[],int ig[],int ib[]) { pp4(f,xm,xma,Number_of_Data,Number_of_Function,ipt,ir,ig,ib) } public Plot(fi_x f,double xm,double xma,int Number_of_Data,int Number_of_Function, int ipt[]) { int ir[] int ig[] int ib[] int nn=Number_of_Function ir=new int[nn] ig=new int[nn] ib=new int[nn] for(int i=0 i<nn i++) { ir[i]=0 ig[i]=0 ib[i]=0 } pp4(f,xm,xma,Number_of_Data,Number_of_Function,ipt,ir,ig,ib) } public Plot(fi_x f,double xm,double xma,int Number_of_Data,int Number_of_Function) { int ir[] int ig[] int ib[] int ipt[] int nn=Number_of_Function ir=new int[nn] ig=new int[nn] ib=new int[nn] ipt=new int[nn] for(int i=0 i<nn i++) { ir[i]=0 ig[i]=0 ib[i]=0 ipt[i]=0 } pp4(f,xm,xma,Number_of_Data,Number_of_Function,ipt,ir,ig,ib) } public void setPlabel(String ip) {label=ip } public void setXlabel(String ix) {xlabel=ix } public void setYlabel(String iy) {ylabel=iy } public void setXYlabel(String ix,String iy) {xlabel=ix ylabel=iy } public void set_plotwindow(int width,int height,double xip,double yip,double dxp,double dyp) { //sets rectangular plot window //function scale input variables //real scale plot window width //real scale plot window height //xip minimum real scale x //yip minimum real scale y //dxp real scale x width xmax=xip+dxp //dyp real scale y height ymax=yip+dyp // xabsmin absolute (pixel) scale minimum x // yabsmin absolute (pixel) scale minimum y //abswidth absolute (pixel) scale x width (maximum x=minimum x+abswidth) //absheight absolute (pixel) scale y height (maximum y=minimum y+absheight) xabsmin = yabsmin = abswidth = absheight = (int)(width*(xip+0.2)) (int)(height*(yip+0.2)) (int)(width*dxp) (int)(height*dyp) int ipt[]=new int[Number_of_Function] int ir[]=new int[Number_of_Function] int ig[]=new int[Number_of_Function] int ib[]=new int[Number_of_Function] addFunction(f,xmin,xmax,Number_of_Data,Number_of_Function,ipt,ir,ig,ib) } public void addFunction(fi_x f,double xmin,double xmax,int Number_of_Data,int Number_of_Function,int ipt[]) { int ir[]=new int[Number_of_Function] int ig[]=new int[Number_of_Function] int ib[]=new int[Number_of_Function] addFunction(f,xmin,xmax,Number_of_Data,Number_of_Function,ipt,ir,ig,ib) } public void addFunction(fi_x f,double xmin,double xmax,int Number_of_Data,int Number_of_Function, int ipt[],int ir[],int ig[],int ib[]) { int N=Number_of_Data double dx=(xmax-xmin)/N double xx=xmin int NF=Number_of_Function double xi[][]=new double[NF][N] double yi[][]=new double[NF][N] double yy[]=new double[NF] for(int j=0 j<N j++) { yy=f.func(xx) for(int i=0 i<NF i++) { yi[i][j]=yy[i] xi[i][j]=xx } xx+=dx } addData(xi,yi,ipt,ir,ig,ib) } public void setPlotType(int plot_type[]) { for(int i=0 i<plot_type.length i++) { setPlotType(i,plot_type[i]) } setMinMax() } public void setXlogScaleOn() {xlog=1 xminmaxlog=Math.log10(xmax-xmin+10.0)-1.0 } public void setYlogScaleOn() {ylog=1 yminmaxlog=Math.log10(ymax-ymin+10.0)-1.0 } public void setXlogScaleOff() {xlog=0 } public void setYlogScaleOff() {ylog=0 } public void setPlotType(int dataset,int plot_no) { // plottype = 0 continuous line // plottype = 1 dashed line // plottype = 2 // plottype = 3 // plottype = 10 variable character plot type // plottype = 10 ch[i]='*' //you can change character set by using setPlotType(0,'%') // plottype = 11 ch[i]='#' // plottype = 12 ch[i]='$' // plottype = 13 ch[i]='%' // plottype = 14 ch[i]='&' // plottype = 15 ch[i]='Â£' // plottype = 16 ch[i]='~' // plottype = 17 ch[i]='+' //plottype = 18 ch[i]='^' //plottype = 19 ch[i]='=' // plottype = 20 rectangle // plottype = 21 filled rectangle // plottype = 22 circle // plottype = 23 filled circle // plottype = 24 triangle // plottype = 25 diamond // plottype = 26 pentagon // plottype = 27 hexagon // plottype = 28 filled triangle // plottype = 29 filled diamond // plottype = 30 filled pentagon // plottype = 31 filled hexagon // plottype = 32 triangle star // plottype = 33 diamond star // plottype = 34 pentagon star // plottype = 35 hexagon star // plottype = 36 filled triangle star // plottype = 37 filled diamond star // plottype = 38 filled pentagon star // plottype = 39 filled hexagon star // plottype = 40 bar plot // plottype = 41 filled bar plot plottype[dataset]=plot_no if(plot_no==10) ch[dataset]='*' //user defined char is defined as * } public void setPlotType(int dataset,char plot_char) { // plottype = 10 user defined character plot plottype[dataset]=10 ch[dataset]=plot_char } public void setXgrid(int igx) { xgridon=igx } public void setYgrid(int igy) { ygridon=igy } public void setGrid(int igx,int igy) { xgridon=igx ygridon=igy } public void setXtic(int ixt) { xntic=ixt } public void setYtic(int iyt) { yntic=iyt } public void setXYtic(int ixt,int iyt) { xntic=ixt yntic=iyt } public void setColor(int dataset,int ired,int igreen,int iblue) { red[dataset]=ired green[dataset]=igreen blue[dataset]=iblue } public void setColor(int dataset,Color x) { red[dataset]=x.getRed() green[dataset]=x.getGreen() blue[dataset]=x.getBlue() } public void setColor(int ired[],int igreen[],int iblue[]) { for(int i=0 i<nline i++) { red[i]=ired[i] green[i]=igreen[i] blue[i]=iblue[i] } } public void setColor(Color x[]) { for(int i=0 i<nline i++) { red[i]=x[i].getRed() green[i]=x[i].getGreen() blue[i]=x[i].getBlue() } } public void setMinMax() { xmin=9.99e50 xmax=-9.99e50 ymin=9.99e50 ymax=-9.99e50 for(int i=0 i<nline i++) { for(int j=0 j<n[i] j++) { if(x[i][j]>xmax) xmax=x[i][j] if(x[i][j]<xmin) xmin=x[i][j] if(y[i][j]>ymax) ymax=y[i][j] if(y[i][j]<ymin) ymin=y[i][j] } } } public void setMinMax(double xi[][],double yi[][]) { xmin=9.99e50 xmax=-9.99e50 ymin=9.99e50 ymax=-9.99e50 for(int i=0 i<nline i++) { if(xi[i].length>nmax) {nmax=xi[i].length ni=i } for(int j=0 j<xi[i].length j++) { if(xi[i][j]>xmax) xmax=xi[i][j] if(xi[i][j]<xmin) xmin=xi[i][j] if(yi[i][j]>ymax) ymax=yi[i][j] if(yi[i][j]<ymin) ymin=yi[i][j] } } } public void setMinMax(double iminx,double imaxx,double iminy,double imaxy) { xmin=iminx ymin=iminy xmax=imaxx ymax=imaxy } public void plot() { PlotW.plot(this) } //==== B-Spline intrepolation============= public static double[] hi(double ti[]) { int n=ti.length-1 //ti 0..n int i for(i=0 i<(n-1) i++) { z[0][k]=xi[i] z[1][k]=funcSpline(S,z[0][k]) k++ for(int j=0 j<aradegersayisi j++) {dx=(xi[i+1]-xi[i])/((double)aradegersayisi+1.0) z[0][k]=z[0][k-1]+dx z[1][k]=funcSpline(S,z[0][k]) k++ } } z[0][k]=xi[i] z[1][k]=funcSpline(S,z[0][k]) return z } Plot pp=new Plot(ff1,xmin,xmax,n,pnumber) pp.plot() return pp } public static Plot func(fi_x ff1,double xmin,double xmax,int n) { Plot pp=new Plot(ff1,xmin,xmax,n,0) pp.plot() return pp } public static Plot func(fi_x ff1,double xmin,double xmax) { Plot pp=new Plot(ff1,xmin,xmax,300,0) pp.plot() return pp } public static Plot file(String ff1)throws IOException { Plot pp=new Plot(ff1) pp.plot() return pp } public static Plot file()throws IOException { Plot pp=new Plot() pp.plot() return pp } public static Plot file(String ff1,String ff2)throws IOException { String ff3[]={ff1,ff2} Plot pp=new Plot(ff3) pp.plot() return pp } public static Plot file(String ff1,String ff2,String ff3)throws IOException { String ff4[]={ff1,ff2,ff3} Plot pp=new Plot(ff4) pp.plot() return pp } public static Plot data(double x[],double y[]) { Plot pp=new Plot(x,y) pp.plot() return pp } public static Plot data(double a[][]) { Plot pp=new Plot(a) pp.plot() return pp } } */ import java.lang.Integer import java.awt. * import java.awt.event. * import java.awt.font. * import java.awt.geom. * import java.awt.image. * import javax.swing. * import java.io. { n=pi.nline lab1=new JLabel[n] c1=new JComboBox[n] red1=new JTextField[n] green1=new JTextField[n] blue1=new JTextField[n] col1=new JButton[n] //System.out.println( n= +n) for(int i=0 i<n i++) { Color color1=new Color(pi.red[i],pi.green[i],pi.blue[i]) lab1[i]=new JLabel( eÄri +i+ ) c1[i]=new JComboBox(pi.plotst) c1[i].setSelectedIndex(pi.plottype[i]) red1[i]=new JTextField( +pi.red[i]) green1[i]=new JTextField( +pi.green[i]) blue1[i]=new JTextField( +pi.blue[i]) col1[i]=new JButton( ) col1[i].setBackground(color1) } Container contentPane = getContentPane() JTabbedPane tabbedPane = new JTabbedPane() promptXmin=new JLabel( Xmin ) inputXmin=new JTextField(10) promptXmax=new JLabel( Xmax ) inputXmax=new JTextField(10) promptYmin=new JLabel( Ymin ) inputYmin=new JTextField(10) promptYmax=new JLabel( Ymax ) inputYmax=new JTextField(10) //******* promptLabel=new JLabel( Plot baÅlÄ±ÄÄ± ) promptXLabel=new JLabel( x ekseni baÅlÄ±ÄÄ± ) promptYLabel=new JLabel( y ekseni baÅlÄ±ÄÄ± ) inputLabel=new JTextField(40) inputXLabel=new JTextField(40) inputYLabel=new JTextField(40) //******* promptXntic=new JLabel( X tik no ) inputXntic=new JTextField(10) promptYntic=new JLabel( Y tik no ) inputYntic=new JTextField(10) promptXgridon=new JLabel( X grid (kÃ¼Ã§Ã¼k kare) ) if(pi.xgridon.=0) inputXgridon=new JCheckBox( ,true) else inputXgridon=new JCheckBox( ,false) promptYgridon=new JLabel( Y grid (kÃ¼Ã§Ã¼k kare) ) if(pi.ygridon.=0) inputYgridon=new JCheckBox( ,true) else inputYgridon=new JCheckBox( ,false) promptXlogon=new JLabel( x log ) promptYlogon=new JLabel( y log ) if(pi.xlog.=0) inputXlogon=new JCheckBox( ,true) else inputXlogon=new JCheckBox( ,false) if(pi.ylog.=0) inputYlogon=new JCheckBox( ,true) else inputYlogon=new JCheckBox( ,false) // check field xlogon //******* JPanel pane1 = new JPanel() { public Dimension getPrefferedSize() { Dimension size=super.getPreferredSize() size.width=800 return size } } JPanel mpane=new JPanel() mpane.setLayout(new GridLayout(5,4)) mpane.add(promptXmin) mpane.add(inputXmin) mpane.add(promptXmax) mpane.add(inputXmax) else if (e.getSource()==inputXmin ) {Double valXmin=new Double(inputXmin.getText()) jta.p1.xmin=valXmin.doubleValue() } else if (e.getSource()==inputXmax ) {Double valXmax=new Double(inputXmax.getText()) jta.p1.xmax=valXmax.doubleValue() } else if (e.getSource()==inputYmin ) {Double valYmin=new Double(inputYmin.getText()) jta.p1.ymin=valYmin.doubleValue() } else if (e.getSource()==inputYmax ) {Double valYmax=new Double(inputYmax.getText()) jta.p1.ymax=valYmax.doubleValue() } else if (e.getSource()==inputXntic ) {Integer valXntic=new Integer(inputXntic.getText()) jta.p1.xntic=valXntic.intValue() } else if (e.getSource()==inputYntic ) {Integer valYntic=new Integer(inputYntic.getText()) jta.p1.yntic=valYntic.intValue() } else if (e.getSource()==inputLabel ) {jta.p1.label=inputLabel.getText() } else if (e.getSource()==inputXLabel ) {jta.p1.label=inputXLabel.getText() } else if (e.getSource()==inputYLabel ) {jta.p1.label=inputYLabel.getText() } //***** for(int i=0 i<n i++) { Color color1=new Color(jta.p1.red[i],jta.p1.green[i],jta.p1.blue[i]) Color color2 if (e.getSource()==red1[i] ) {Integer valred=new Integer(red1[i].getText()) jta.p1.red[i]=valred.intValue() } else if (e.getSource()==green1[i] ) {Integer valgreen=new Integer(green1[i].getText()) jta.p1.green[i]=valgreen.intValue() } else if (e.getSource()==blue1[i] ) { Integer valblue=new Integer(blue1[i].getText()) } else if (e.getSource()==col1[i] ) { color2=JColorChooser.showDialog(null, grafik programÄ± eÄri +i,color1 ) jta.p1.red[i]=color2.getRed() jta.p1.green[i]=color2.getGreen() jta.p1.blue[i]=color2.getBlue() red1[i].setText( +jta.p1.red[i]) green1[i].setText( +jta.p1.green[i]) blue1[i].setText( +jta.p1.blue[i]) } color2=new Color(jta.p1.red[i],jta.p1.green[i],jta.p1.blue[i]) col1[i].setBackground(color2) } //***** jta.yenidenciz() } public void degerleriGir(String e,int x,int y) { s=e if(jta.p1.xlog.=0) {xi1=jta.p1.xmin+Math.pow(10.0,(double)((x-jta.p1.xabsmin)/(double)jta.p1.abswidth*(double)jta.p1.xminmaxlog+1.0))-10.0 } else {xi1=jta.p1.xmin+(double)(x-jta.p1.xabsmin)/(double)jta.p1.abswidth*(jta.p1.xmax-jta.p1.xmin) } if(jta.p1.ylog.=0) {yi1=jta.p1.ymin-10.0+Math.pow(10.0,((double)(1.0-(double)(y-jta.p1.yabsminjta.p1.absheight)/(double)jta.p1.absheight*(double)jta.p1.yminmaxlog))) } else {yi1=jta.p1.ymin-(double)(y-jta.p1.yabsmin-jta.p1.absheight)/(double)jta.p1.absheight*(jta.p1.ymax-jta.p1.ymin) } altbar.setText(e+ [ +xi1+ , +yi1+ ] ) //jta.yenidenciz() } public void mouseClicked(MouseEvent e) { degerleriGir( Kliklendi ,e.getX(),e.getY()) } public void mousePressed(MouseEvent e) { degerleriGir( BasÄ±ldÄ± ,e.getX(),e.getY()) } public void mouseReleased(MouseEvent e) { degerleriGir( BÄ±rakÄ±ldÄ± ,e.getX(),e.getY()) } public void mouseEntered(MouseEvent e) { setTitle( Fare applet alanÄ± iÃ§inde ) } public void mouseExited(MouseEvent e) { setTitle( Fare applet alanÄ± dÄ±ÅÄ±nda ) degerleriGir( Fare applet alanÄ± dÄ±ÅÄ±nda ,e.getX(),e.getY()) } //MouseMotionListener (fare hareket dinleyicisi) metotlari public void mouseDragged(MouseEvent e) { degerleriGir( basilip cekiliyor ,e.getX(),e.getY()) } public void mouseMoved(MouseEvent e) { degerleriGir( hareket halinde ,e.getX(),e.getY()) } public static void plot() { //takes plot sata from Plot.txt file PlotW pencere= new PlotW() pencere.addWindowListener(new BasicWindowMonitor()) pencere.setSize(1000,800) pencere.setVisible(true) } public static void plot(Plot pi) { //take plot data from pi object PlotW pencere= new PlotW(pi) pencere.addWindowListener(new BasicWindowMonitor()) pencere.setSize(1000,800) pencere.setVisible(true) } public static void main(String[] args) { PlotW pencere= new PlotW() pencere.addWindowListener(new BasicWindowMonitor()) pencere.setSize(1000,800) pencere.setVisible(true) } } * import java.awt. * import java.awt.event. * import java.awt.geom. * import javax.swing. * import java.awt.print.PrinterJob import java.awt.print. * public class Plot2D extends JPanel implements Printable { public Graphics2D g public Plot p1 final static Color bg = Color.white final static Color fg = Color.black final static Color red = Color.red final static Color white = Color.white final static BasicStroke stroke = new BasicStroke(1.0f) final static BasicStroke boldStroke = new BasicStroke(2.0f) PlotShapesSW ps double xx[],yy[] int xn public Plot2D(Plot pi) { //Initialize drawing colors setBackground(Color.white) setForeground(Color.black) //read data from file Plot data previously defined p1=pi xx=new double[200] yy=new double[200] xn=0 } public Plot2D() { //Initialize drawing colors setBackground(Color.white) setForeground(Color.black) //read data from file Plot data previously defined try{p1=new Plot() } catch(IOException ioe) {System.err.println( IOExceptionin opening plot ) } xx=new double[200] yy=new double[200] xn=0 } public Plot2D(String pl,String xl,String yl,int xnt,int ynt ,int xgo,int ygo,String ifn[],int ipt[],int ir[],int ig[] ,int ib[]) { //input variables // pl plot label // xl x axis label // yl y axis label //xnt x axis tic (0=off, any other on) //ynt y axis tic (0=off, any other on) //xgo x axis grid on (0=off, any other on) //ygo y axis grid on (0=off, any other on) //ifn file name array variable //ipt plot type array variable //ir color red component array variable //ig color green componenet array variable //Initialize drawing colors setBackground(Color.white) setForeground(Color.black) try{ p1=new Plot(pl,xl,yl,xnt,ynt,xgo,ygo,ifn,ipt,ir,ig,ib) } catch(IOException ioe) {System.err.println( IOExceptionin opening plot ) } xx=new double[200] yy=new double[200] xn=0 } public void setXY(double ixx[],double iyy[],int ixn) { xn=ixn for(int i=0 i<xn i++) {xx[i]=ixx[i] yy[i]=iyy[i] } } public void yenidenPlotDatasiOku() { try{ p1=new Plot() } catch(IOException ioe) {System.err.println( IOExceptionin opening plot ) } } public void yenidenPlotDatasiOku(Plot pi) { p1=pi } public void plotVerisiEkle(double xi[],double yi[],int iplottype,int ir,int ig,int ib) { p1.addData(xi,yi,iplottype,ir,ig,ib) } public void plotVerisiEkle(double xi[][],double yi[][],int iplottype[],int ir[],int ig[],int ib[]) { p1.addData(xi,yi,iplottype,ir,ig,ib) } public void plotVerisiEkle(f_x f,double xmin,double xmax,int N,int iplottype,int ir,int ig,int ib) { p1.addFunction(f,xmin,xmax,N,iplottype,ir,ig,ib) } public void yenidenPlotDatasiOku(String pl,String xl,String yl,int xnt,int ynt ,int xgo,int ygo,String ifn[],int ipt[],int ir[],int ig[] ,int ib[]) { //input variables // pl plot label // xl x axis label // yl y axis label //xnt x axis tic (0=off, any other on) //ynt y axis tic (0=off, any other on) //xgo x axis grid on (0=off, any other on) //ygo y axis grid on (0=off, any other on) //ifn file name array variable //ipt plot type array variable //ir color red component array variable //ig color green componenet array variable //Initialize drawing colors setBackground(Color.white) setForeground(Color.black) try{ p1=new Plot(pl,xl,yl,xnt,ynt,xgo,ygo,ifn,ipt,ir,ig,ib) } catch(IOException ioe) {System.err.println( IOExceptionin opening plot ) } } public void yenidenciz() { repaint() } public void yazdir() { PrinterJob printJob = PrinterJob.getPrinterJob() printJob.setPrintable(this) if (printJob.printDialog()) { try { printJob.print() } catch (Exception ex) {ex.printStackTrace() } } } * import java.awt.event. * import java.awt.geom. * import javax.swing. * import java.awt.font. { xx1=(int)(xabsmin+(x1-xmin)/(xmax-xmin)*abswidth) xx2=(int)(xabsmin+(x2-xmin)/(xmax-xmin)*abswidth) } if(ylog.=0) { yy1=(int)(yabsmin+absheight-((Math.log10(y1-ymin+10.0)-1.0)/yminmaxlog*absheight)) yy2=(int)(yabsmin+absheight-((Math.log10(y2-ymin+10.0)-1.0)/yminmaxlog*absheight)) } else { yy1=(int)(yabsmin+absheight-(y1-ymin)/(ymax-ymin)*absheight) yy2=(int)(yabsmin+absheight-(y2-ymin)/(ymax-ymin)*absheight) } g.draw(new Line2D.Double( xx1,yy1,xx2,yy2)) } //end of drawLine yvalues[2*i+1]= (int)(Math.floor(yabsmin+absheight-((Math.log10(y1-ymin+10.0)-1.0)/ yminmaxlog*absheight-r*Math.sin(teta2)))) } else { yvalues[2*i]= (int)(Math.floor(yabsmin+absheight-(y1-ymin)/ (ymax-ymin)*absheight-R*Math.sin(teta1))) yvalues[2*i+1]= (int)(Math.floor(yabsmin+absheight-(y1-ymin)/ (ymax-ymin)*absheight-r*Math.sin(teta2))) } if(i==side) { xvalues[2*i]=xvalues[0] yvalues[2*i]=yvalues[0] } } for(int i=0 i<=2*side i++) { if(i==0) { polygon.moveTo(xvalues[0],yvalues[0]) } else { polygon.lineTo(xvalues[i],yvalues[i]) } } g.fill(polygon) }//end of drawStar public void drawXTic(int ticNumber,double ticHeight,int ticSide) { //draw a series of x axis tics double dtic=(xmax-xmin)/ticNumber double x1=xmin double y1=ymin double dy dy=ticHeight int xx1,yy1,yy2,yy3 for(int i=0 i<=ticNumber i++) { if(xlog.=0) { xx1=(int)(xabsmin+((Math.log10(x1-xmin+10.0)-1.0)/xminmaxlog*abswidth)) } else { xx1=(int)(xabsmin+(x1-xmin)/(xmax-xmin)*abswidth) } yy1=(int)(yabsmin+absheight-(y1-ymin)/(ymax-ymin)*absheight) yy2=(int)(yabsmin+absheight-(y1-dy-ymin)/(ymax-ymin)*absheight) yy3=(int)(yabsmin+absheight-(y1+dy-ymin)/(ymax-ymin)*absheight) if(ticSide==0) {g.draw(new Line2D.Double( xx1,yy1,xx1,yy2)) } else {g.draw(new Line2D.Double( xx1,yy1,xx1,yy3)) } x1=x1+dtic } } public void drawYTic(int ticNumber,double ticWidth,int ticSide) { //draw a series of y axis tics double dtic=(ymax-ymin)/ticNumber double x1=xmin double y1=ymin double dx dx=ticWidth double xx1,xx2,xx3,yy1 for(int i=0 i<=ticNumber i++) { if(ylog.=0) public void drawYNumbers(int ticNumber) { // draw y numbers double dtic=(ymax-ymin)/ticNumber double x1=xmin double y1=ymin int xx1,yy1 String s s= for(int i=0 i<=ticNumber i++) { if(xlog.=0) VisAD Ã§ok Ã§eÅitli 3 boyutlu uygulamalar iÃ§in Java 3D grafik paketinikullanan bir program paketidir. Visad Paketini http //www.ssec.wisc.edu/~billh/visad.html veya Ã§eÅitli adreslerden indirebilirsiniz. Ä°sterseniz kendiniz kodlarÄ± derleyerek kurabilirsiniz, isterseniz, hazÄ±r visad.jar dosyasÄ±nÄ± javanÄ±n jre dosyasÄ± altÄ±ndaki lib dosyasÄ± altÄ±ndaki ext dosyasÄ±na kopyalÄ±yarak (Ã¶rneÄin benim bilgisayarÄ±mda c \co\java\jre\lib\ext) bilgisayarÄ±nÄ±zÄ± VisAD paketini direk kullanabilir hale getirebilirsiniz. 3 boyutlu grafikler iÃ§in aynÄ± zamanda Java 3D grafik paketine de ihtiyacÄ±nÄ±z olacaktÄ±r. bu paketin en son versiyonuna www.java.sun.com adresinden temin edebilirsiniz (benim Åu anda kullandÄ±ÄÄ±m versiyonu java3d-1_4_0_01-windows-i586) paket aÃ§tÄ±ÄÄ±nÄ±zda kendi kendine yÃ¼klenecektir. Java 3D paketi default olarak Windows ortamÄ±nda openGL kullanÄ±r (diÄer ortamlardaki grafik kullanÄ±mÄ± ile ilgili Java 3D paketini inceleyiniz). EÄer grafik kartÄ±nÄ±z openGL sistemini destekliyorsa bu bÃ¶lÃ¼mde verdiÄimiz programlarÄ± direk olarak kullanabilirsiniz. Bu durumda programÄ± Ã§alÄ±ÅtÄ±rÄ±rken Java 3D paketine default deÄer olan openGL yerine directX kullandÄ±ÄÄ±nÄ±zÄ± belirtmeniz gerekecektir. Bunun iÃ§in java programÄ±nÄ± Ã§alÄ±ÅtÄ±rÄ±rken java -Dj3d.rend=d3d sÄ±nÄ±fismi komutunu kullanmanÄ±z gerekir. directX'in Windows iÃ§in en son versiyonunu http //www.microsoft.com/windows/directx/ adresinden bulabilirsiniz. OluÅturduÄumuz 3D programÄ± Plot3D iÃ§in temel olarak VisAD paketinin Ã¶rnek problemlerini kullandÄ±k, bu Ã¶rnek programlarÄ± bizim iki boyutlu grafik ortamlarÄ±nda da kullandÄ±ÄÄ±mÄ±z fonksiyon abstract sÄ±nÄ±f ve veri yapÄ±larÄ±na uygun hale getirdik. Plot3D Program Ã§Ä±ktÄ±sÄ± Program 1.6-14-1 de verilmiÅtir. * import visad.java3d.DisplayImplJ3D import visad.java2d.DisplayImplJ2D import java.rmi.RemoteException import java.awt. * import javax.swing. * import java.awt.event. * class f1 extends f_xj { public double func(double x[]) { //Ã§Ã¶zÃ¼mÃ¼ istenen fonksiyon // The function (domain_tuple -> altitude ) FunctionType func_domain_alt // Our Data values for the domain are represented by the Set Set domain_set // The Data class FlatField FlatField vals_ff // The DataReference from data to display DataReferenceImpl data_ref // The 2D display, and its the maps // ...and put the altitude values above into it // Note the argument false, meaning that the array won't be copied vals_ff.setSamples( flat_samples , false ) // Create Display and its maps display = new DisplayImplJ3D( display1 ) // Get display's graphics mode control and draw scales GraphicsModeControl dispGMC = (GraphicsModeControl) display.getGraphicsModeControl() dispGMC.setScaleEnable(true) // Also enable Texture dispGMC.setTextureEnable(false) // Create a data reference and set the FlatField as our data data_ref = new DataReferenceImpl( data_ref ) data_ref.setData( vals_ff ) display.addReference( data_ref) // Set maps ranges latMap.setRange(x1min, x1max) altMap.setRange(zmin, zmax) // Create application window and add display to window JFrame jframe = new JFrame( VisAD Tutorial example 4_06 ) jframe.getContentPane().add(display.getComponent()) // Add the LabeledColorWidget to the frame // The function (domain_tuple -> altitude ) FunctionType func_domain_alt // Our Data values for the domain are represented by the Set Set domain_set display.addReference( data_ref) // Set maps ranges latMap.setRange(x1min, x1max) altMap.setRange(zmin, zmax) // Create application window and add display to window JFrame jframe = new JFrame(sz) jframe.getContentPane().add(display.getComponent()) // Add the LabeledColorWidget to the frame // The function (domain_tuple -> altitude ) FunctionType func_domain_alt // Our Data values for the domain are represented by the Set Set domain_set // The Data class FlatField FlatField vals_ff // The DataReference from data to display DataReferenceImpl data_ref // The 2D display, and its the maps DisplayImpl display ScalarMap latMap, lonMap ScalarMap altMap, altRGBMap ColorControl colCont // Our color table float[][] myColorTable // Code for slope data // Data in a FlatField FlatField slope_vals_ff // Get the funtionc from the FlatField for slope FunctionType func_domain_slope = ((FunctionType)slope_vals_ff.getType()) // slope is a RealType RealType slope = (RealType) func_domain_slope.getRange() // Create Display and its maps display = new DisplayImplJ3D( display1 ) // Get display's graphics mode control and draw scales GraphicsModeControl dispGMC = (GraphicsModeControl) display.getGraphicsModeControl() dispGMC.setScaleEnable(true) // Also enable Texture dispGMC.setTextureEnable(false) altMap = new ScalarMap( altitude, Display.ZAxis ) // Add maps to display display.addMap( latMap ) display.addMap( lonMap ) display.addMap( altMap ) display.addMap( altRGBMap ) // Create a data reference and set the FlatField as our data data_ref = new DataReferenceImpl( data_ref ) data_ref.setData( vals_ff ) // Data reference for slope DataReferenceImpl data_ref2 = new DataReferenceImpl( data_ref2 ) data_ref2.setData( slope_vals_ff ) // Add reference to display ConstantMap[] constAlpha_CMap = { new ConstantMap( 0.50f, Display.Alpha)} display.addReference( data_ref2, constZ_CMap ) display.addReference( data_ref, constAlpha_CMap ) // Set maps ranges latMap.setRange(x1min, x1max) altMap.setRange(x2min, x2max) // Create application window and add display to window JFrame jframe = new JFrame(sz) jframe.getContentPane().add(display.getComponent()) // Add the LabeledColorWidget to the frame // Tuple to pack longitude and latitude together, as the domain RealTupleType domain_tuple // The function (domain_tuple -> temperature ) // Remeber, range is only temperature FunctionType func_domain_temp // Our Data values for the domain are represented by the Set Set domain_set // ...and for the isocontours iso_vals_ff = new FlatField( func_domain_isoTemp, domain_set) // Get the values from the temperature FlatField // create flat_isoVals array for clarity's sake // false argument means don't copy float[][] flat_isoVals = vals_ff.getFloats(false) // ...and put the values above into it // Note the argument false, meaning that the array won't be copied again iso_vals_ff.setSamples( flat_isoVals , false ) // starting at this base value // ...and set the lines with the method isoControl.setContourInterval(interval, lowValue, highValue, base) isoControl.enableLabels(true) // Create data references and set the FlatField as our data data_ref = new DataReferenceImpl( data_ref ) iso_data_ref = new DataReferenceImpl( iso_data_ref ) data_ref.setData( vals_ff ) iso_data_ref.setData( iso_vals_ff ) // Add reference to display display.addReference( data_ref ) display.addReference( iso_data_ref ) // Create application window and add display to window JFrame jframe = new JFrame(s3) jframe.getContentPane().add(display.getComponent()) // Get the Set samples to facilitate the calculations float[][] set_samples = domain_set.getSamples( true ) // Add maps to display display.addMap( latMap ) display.addMap( lonMap ) display.addMap( tempIsoMap ) display.addMap( tempRGBMap ) // Create a data reference and set the FlatField as our data data_ref = new DataReferenceImpl( data_ref ) data_ref.setData( vals_ff ) // Add reference to display display.addReference( data_ref ) // Create application window and add display to window JFrame jframe = new JFrame(s3) jframe.getContentPane().add(display.getComponent()) jframe.setSize(300, 300) jframe.setVisible(true) } public static void main(String[] args) throws RemoteException, VisADException { f1 f=new f1() double a[][]=grid2D(f,-1,1,-1,1,20,20) Bu programÄ± ne Åekilde kullanabileceÄimizi Ã§eÅitli Ã¶rnek problemlerle gÃ¶relim.Kodu bir araya getirirken Plot programÄ±nda olduÄu gibi Ã§ok basit bir Åekilde kullanÄ±lÄ±r olmasÄ±nÄ± dÃ¼ÅÃ¼ndÃ¼k. KartÄ±nÄ±z openGL'i desteklemiyorsa(Windows sistemleri iÃ§in) programÄ± directX ile Ã§alÄ±ÅtÄ±rmak iÃ§in java komutunu java -Dj3d.rend=d3d Plot3DT1 Åeklinde kullanÄ±nÄ±z. * import visad.java3d.DisplayImplJ3D import visad.java2d.DisplayImplJ2D import java.rmi.RemoteException import java.awt. * import javax.swing. * import java.awt.event. GÃ¶rdÃ¼ÄÃ¼nÃ¼z gibi grafik Ã§Ä±ktÄ±sÄ±nÄ± alabilmek iÃ§in Ã§ok fazla bir bilgiye ihtiyacÄ±nÄ±z olmayacak, veriyi verip Ã§iz demeniz temel olarak yeterli olacaktÄ±r. Åimdi veriyi bir fonksiyondan alalÄ±m. * import visad.java3d.DisplayImplJ3D import visad.java2d.DisplayImplJ2D import java.rmi.RemoteException import java.awt. * import javax.swing. * import java.awt.event. * import visad.java3d.DisplayImplJ3D import visad.java2d.DisplayImplJ2D import java.rmi.RemoteException import java.awt. * import javax.swing. * import java.awt.event. * class f1 extends f_xj { public double func(double x[]) { //Ã§Ã¶zÃ¼mÃ¼ istenen fonksiyon double ff ff=(x[1]-x[0]*x[0])*(x[1]-x[0]*x[0])+0.01*(x[0]-1.0)*(x[0]-1.0) return -ff } } public class Plot3DT3 { public static void main(String[] args) throws RemoteException, VisADException { f1 f=new f1() Contour grafikleri 3 boyutlu eÄrinin ikiboyuta izdÃ¼ÅÃ¼mÃ¼dÃ¼r. Haritalarda da bu yÃ¶ntemi kullanmaktayÄ±z. * import visad.java3d.DisplayImplJ3D import visad.java2d.DisplayImplJ2D import java.rmi.RemoteException import java.awt. * import javax.swing. * import java.awt.event. Burada verdiÄimiz kadarÄ± size 3 boyutlu grafiklere bir giriÅ saÄlamak ve aynÄ± zamanda sayÄ±sal Ã§Ã¶zÃ¼mleme sonuÃ§larÄ±nÄ± gÃ¶zlemleyebileceÄimiz 3 boyutlu grafik ortamÄ±nÄ± oluÅturmak amacÄ± ileydi. EÄer daha detaylÄ± kullanÄ±mlara girmek isterseniz VisAD veya benzeri paketleri detaylÄ± inceleyerek bu konuda kendinizi rahatlÄ±kla geliÅtirebilirsiniz. JMath isimli bu paket yukarda verdiÄimiz ve genel 3 boyutlu grafik paketi kadar sofistike deÄil ama basitliÄi bazÄ± kullanÄ±cÄ±larÄ±mÄ±z iÃ§in rahatlÄ±k getirebilir diye bu paketi de nasÄ±l kullanacaÄÄ±mÄ±z ve 3 boyutlu rafik Ã§Ä±ktÄ±larÄ±nÄ± sayÄ±sal Ã§Ã¶zÃ¼mleme problemlerimize adapte edebilecek temel bir programÄ± burada sunuyoruz. Bu paketi sadece fonksiyon grafikleri iÃ§in adape ettim. Div. // turhan.coban@ege.edu.tr // ===================================================== // utilizes JMath 3D Plot // http //jmathtools.sourceforge.net/doku.php // to use this program please add to javahome/jre/lib/ext // jmathio.jar jmathplot.jar ve jmatharray.jar jar files import javax.swing. * import org.math.plot. * import static java.lang.Math. * import static org.math.array.DoubleArray. * import java.awt. * import java.awt.event. * class f2 extends f_xj { public double func(double x[]) { //Ã§Ã¶zÃ¼mÃ¼ istenen fonksiyon double ff ff=7.9+0.13*x[0]+0.21*x[1]-0.05*x[0]*x[0]-0.016*x[1]*x[1]-0.007*x[0]*x[1] //ff=sin(x[0])*cos(x[1]) return ff } } public class Plot3D_JM{ Plot3DPanel plot ProgramÄ± verilen fonksiyonu deÄiÅtirerek tek baÅÄ±na kullanabileceÄiniz gibi baÅka bir programdan da Ã§aÄÄ±rarak grafiÄi Ã§izdirebilirsiniz. Program hoÅunuza gidebilecek bir Ã§ok Ã¶zellikler barÄ±ndÄ±rÄ±yor(benim yazdÄ±ÄÄ±m deÄil bizzat paketten hazÄ±r olarak gelen) Bunlardan birkaÃ§Ä±na bakalÄ±m Program deÄiÅkenlerinin maksimum-minimum deÄerlerini deÄiÅtirerek detaylarÄ± inceleyebiliriz. Verileri direk olarak JTable sÄ±nÄ±fÄ± tablolardan alarak kullanabiliriz . GÃ¶rÃ¼leceÄi gibi b programda VisAD paketi iÃ§in yazdÄ±ÄÄ±mÄ±z Plot3D setindekifonksiyon Ã§izme metod formatlarÄ± aynen korunmaya Ã§alÄ±ÅÄ±lmÄ±ÅtÄ±r. 3 boyutlu fonksiyon grafik programÄ±mÄ±zÄ± kendi programÄ±mÄ±z iÃ§inde de Ã§aÄÄ±rabiliriz. * import javax.swing. * import java.awt.event. GUI, USER KullanÄ±cÄ±ya sunulan programÄ±n onun rahatlÄ±kla anlayabileceÄi bir formata sahip olmasÄ± gÃ¼nÃ¼mÃ¼z programlamacÄ±lÄ±ÄÄ±nda oldukÃ§a Ã¶nemlidir. Reklamlarla bÃ¼yÃ¼yen bir kuÅak iÃ§in paket bazen paketin iÃ§indekinden bile Ã¶nemli hale gelebilmektedir. Grafik KullanÄ±cÄ±sÄ± Arabirim programlarÄ± kullanÄ±cÄ±ya sunduÄumuz paketi oluÅturmaktadÄ±r. Java'da temel grafik arabirim kÃ¼tÃ¼phaneleri java.awt sÄ±nÄ±fÄ±nda yer almaktadÄ±r. Bu bÃ¶lÃ¼mde awt ve swing yapÄ±larÄ±nÄ± paralel olarak vermeye Ã§alÄ±ÅacaÄÄ±z.. YalnÄ±z swing kÃ¼tÃ¼phanesi kapsam olarak Ã§ok daha geniÅ olduÄundan swing ile yapÄ±lan tÃ¼m iÅlemlerin ve grafik arabirim alt programlarÄ±nÄ± awt'de karÅÄ±lÄ±klarÄ± mevcut deÄildir. Bir Ã¶nceki grafik Ã§iziminde olduÄu gibi grafik arabirim elemanlarÄ±nÄ±n tanÄ±tÄ±mÄ± da oldukÃ§a geniÅ bir yelpaze oluÅturduÄuundan mÃ¼mkÃ¼n olduÄunca detay verilmeye Ã§alÄ±ÅÄ±lsa bile tÃ¼m kapsamÄ± burada iÅlemek mÃ¼mkÃ¼n deÄildir. ÃrneÄin java swing konusundaki kapsamlÄ± bir kitap olan Java Swing , O'Reily basÄ±m evi kitabÄ± yaklaÅÄ±k 1200 sayfalÄ±k bir kitabÄ± sadece bu konuya ayÄ±rmÄ±ÅtÄ±r. GUI metotlarÄ± java.awt (Abstract windowing toolkit) paketinde yer almaktadÄ±r. Bu pakette Container ve Component isimli iki alt pakette yer almaktadÄ±r. Her zaman kullandÄ±ÄÄ±mÄ±z Applet sÄ±nÄ±fÄ± Component sÄ±nÄ±fÄ±ndan tÃ¼riyen Panel sÄ±nÄ±fÄ±nÄ±n alt sÄ±nÄ±fÄ±dÄ±r. Yani Component Appletlerin sÃ¼per sÄ±nÄ±fÄ±dÄ±r. Burada Component sÄ±nÄ±fÄ±nÄ±n ï· TextComponent ï· TextField ï· TextArea ï· Button ï· Label ï· Checkbox ï· List ï· Choice ï· Canvas ï· Scrollbar ï· Container ï· Panel Java.applet.Applet sÄ±nÄ±fÄ±nÄ±n ï· ScrollPane ï· Window ï· Frame ï· Dialog SÄ±nÄ±flarÄ±nÄ± incelemeye calÄ±ÅacaÄÄ±z. Paralel olarak javax.swing paketinde yer alan grafik arayÃ¼z programlarÄ±nda yer alan Ã¼st seviye paketler Japplet, JDialog, JFrame,JWindow ve JComponent'dir JComponent sÄ±nÄ±fÄ±nÄ±n altÄ±nda yer alan sÄ±nÄ±flarÄ±n bazÄ±larÄ± ï· JcomboBox ï· JLabel ï· JList ï· JMenuBar ï· JPanel ï· JPopupMenu ï· JScrollBar ï· JScrollPane ï· JTable ï· ï· ï· ï· ï· ï· ï· ï· ï· ï· ï· ï· ï· ï· ï· ï· ï· ï· ï· ï· ï· ï· ï· ï· ï· ï· ï· ï· ï· ï· JTree JInternalFrame JOptionPane JProgressBar JRootPane JSeperator JSlider JSplitPane JTabbedPane JToolBar JToolTip JViewePort JColorChooser JTextComponent JTextArea JTextField JPasswordField JEditorPAne JTextPane JFileChooser JLayeredPane AbstractButton JToggleButton JCheckBox JRadioButton JButton JMenuItem JMenu JRadioButtonMenuItem JCheckButtonMenuItem Yine yineleyelim, swing sÄ±nÄ±fÄ±ndaki tÃ¼m alt metodlarÄ± kapsamak bu kitabÄ±n kapsamÄ±nÄ± oldukÃ§a bÃ¼yÃ¼tecektir, bu yÃ¼zden Åimdilik buna imkan gÃ¶remiyoruz, fakat pratikte ne olduklarÄ± hakkÄ±nda iyi bir fikir verebilecek geniÅlikte bir spektrum vermeye Ã§alÄ±ÅacaÄÄ±z. Burada Ã¶zellkle awt ve swing sÄ±nÄ±fÄ± grafik iÅlemcilerini bir arada vermeye Ã§alÄ±ÅtÄ±k. KullanÄ±cÄ± her iki tip grafik ortamÄ±yla da karÅÄ±laÅacaÄÄ± iÃ§in (Kendi yazmasa bile hazÄ±r programlar karÅÄ±sÄ±na Ã§Ä±kacaktÄ±r), her ikisini de bilmesi gereklidir. Zaten bu kitabÄ±n tÃ¼m konularÄ±nda da hem awt hem de swing ile yazÄ±lmÄ±Å program Ã¶rnekleri vermeye Ã§alÄ±ÅtÄ±k. Bu konudan sonra geriye dÃ¶nÃ¼p tÃ¼m program Ã¶rneklerini grafik ortamÄ± gÃ¶zÃ¼yle inceliyebilirsiniz. Label sÄ±nÄ±fÄ±nda tanÄ±mlanan metotlar ÅunlardÄ±r ï· Kurucu Metotlar public Label() // Label sÄ±nÄ±fÄ± nesneyi olusturur herhangi bir yazÄ± gÃ¶stermez public Label(String s) // Label sÄ±nÄ±fÄ± nesneyi olusturur ve s stringini gÃ¶sterir public void Label(String s,int pozisyon) // Label sÄ±nÄ±fÄ± nesneyi olusturur ve s stringi gÃ¶sterir aynÄ± zamanda Labeli pozisyonda verilen deÄere gÃ¶re istenilen yere yerleÅtirir. ï· GiriÅ Ã§Ä±kÄ±Å metotlarÄ± public String getText() // Label sÄ±nÄ±fÄ±nÄ±n String deÄiÅkenini okur. public void setText(String s) // Label sÄ±nÄ±fÄ±nÄ±n String deÄiÅkenine yeni deÄer girer. public void setAlignment(int pozisyon) Label pozisyon deÄiÅkeninde verilen deÄere gÃ¶re istenilen yere yerleÅtirir. Swing sÄ±nÄ±fÄ± Jlabel Lable sÄ±nÄ±fÄ±ndandan farklÄ± olarak bize sadece yazÄ± deÄil aynÄ± zamanda gÃ¶rÃ¼ntÃ¼ ekleme olasÄ±lÄ±klarÄ± da sunar. Jlabel sÄ±nÄ±fÄ±nÄ±n Ã§ok kullanacaÄÄ±mÄ±z bazÄ± metotlarÄ±nÄ± sayacak olursak Jcomponent sÄ±nÄ±fÄ±ndan gelen metodlar void setBackground(Color c) arkaplan rengini deÄiÅtiri Color getBackground() arkaplan rengini okur void setForeground(Color c) Ã¶npaln rengini deÄiÅtiri Color getForeground() Ã¶n plan rengini okur. void setFont(Font f) yazÄ± fontunu seÃ§er Font getFont() yazÄ± fontunu okur Boolean isVisible gÃ¶rÃ¼nÃ¼r olup olmadÄ±ÄÄ±nÄ± kontrol eder Void setVisible(Boolean b) gÃ¶rÃ¼nÃ¼r veya gÃ¶rÃ¼nmez yapar. Jlabel sÄ±nÄ±fÄ±nda tanÄ±mlanmÄ±Å bazÄ± alt sÄ±nÄ±flar void setText(String s) JLabel'Ä±n text deÄiÅkeninin deÄerine yeni verilen deÄeri atar String getText() JLabel'Ä±n String text deÄiÅkenini okur. int getVerticalAlignment() void setVerticalTextPosition(int dÃ¼Åey_pozisyon) Label'in iÃ§indeki yazÄ±nÄ±n Label iÃ§indeki dÃ¼Åey pozisyonunu ayarlar. Sabitler Ã¼sttekilerin aynÄ±dÄ±r. int getVerticalTextPosition() Label'in iÃ§indeki yazÄ±nÄ±n Label iÃ§indeki dÃ¼Åey pozisyonunu okur. void setHorizontalTextPosition(int dÃ¼Åey_pozisyon) Label'in iÃ§indeki yazÄ±nÄ±n Label iÃ§indeki yatay pozisyonunu ayarlar. int getHorizontallTextPosition() Label'in iÃ§indeki yazÄ±nÄ±n Label iÃ§indeki yatay pozisyonunu okur. void setIcon(Icon resim) Label iÃ§indeki resmi deÄiÅtirir veya eÄer yoksa ilk defa atar Icon getIcon() Label iÃ§indeki resmi okur. void setDisplayedMnemonic(int c) Mnemoic alt harf kontrolunu kullanarak belli bir giriÅe ulaÅmayÄ± saÄlar. (Ã¶rneÄin âm' harfine set edilmiÅse alt-m bu komuta gider. Ãrnek problemlerle bu kavram aÃ§Ä±lacaktÄ±r. int getDisplayedMnemonic(int c) Mnemonic deÄerini okur. Åimdi Ã¶rnek problemlerle swing JLabel kullanÄ±mÄ±na daha detaylÄ± olarak bakalÄ±m. Birinci Ã¶rneÄimizde basit bir Åekilde String label yazdÄ±racaÄÄ±z. ÃerÃ§eve olarak JFrame kullandÄ±k. * public class label1SW { public static void main(String[] args) { JLabel etiket=new JLabel( JLabel sÄ±nÄ±fÄ±na hoÅ geldiniz ) JFrame cerceve=new JFrame() cerceve.addWindowListener(new BasicWindowMonitor()) cerceve.getContentPane().add(etiket) cerceve.pack() cerceve.setVisible(true) } } Bu programÄ±n aynÄ± zamanda main metodu da olduÄundan hem applet hem de frame olarak Ã§aÄÄ±rÄ±lmasÄ± mÃ¼mkÃ¼ndÃ¼r. ÃerÃ§eve olarak JFrame kullandÄ±k. * import java.awt.event. * import java.awt.geom. * import javax.swing. * public class LabelTestiSW extends JApplet { protected String iconname1= images/kuÅ.gif ImageIcon icon1 public static void main(String s[]) { JFrame f = new JFrame( Label testi ) f.addWindowListener(new WindowAdapter() { public void windowClosing(WindowEvent e) {System.exit(0) } }) JApplet applet = new LabelTestiSW() f.getContentPane().add( Center , applet) applet.init() f.pack() f.setSize(new Dimension(550,200)) f.show() } } images/middle.gif middle.gif dosyasÄ±nÄ±n images alt direktorysinde yer aldÄ±ÄÄ±nÄ± belirtir. Burada Icon interphase'ine biraz daha yakÄ±ndan gÃ¶z atalÄ±m. Icon interphase sÄ±nÄ±fÄ± olduÄundan tanÄ±mlanan sÄ±nÄ±fÄ± iÃ§erisinde public int getIconWidth() public int getIconHeight() public void paintIcon(Component c, Graphics g, int x,int y) metodlarÄ± tanÄ±mlanmak zorundadÄ±r. * import java.awt.geom. * import java.awt. * * import java.awt. Bu sÄ±nÄ±fÄ±n Ã§Ä±ktÄ±sÄ± DiÄer bir deyimle kullanÄ±cÄ±nÄ±n baÅlatacaÄÄ± iÅlemleri yapar ve kullanÄ±cÄ±nÄ±n yeni bir iÅlem tanÄ±mlamasÄ±nÄ± beklerler. Bu iÅlemleri yapan sÄ±nÄ±flar java.awt.event kÃ¼tÃ¼phanesinde tanÄ±mlanmÄ±ÅtÄ±r. Bu kÃ¼tÃ¼phanede en Ã§ok kullanacaÄÄ±mÄ±z sÄ±nÄ±flar hiyerarÅi dÃ¼zeninde ÅÃ¶yle verilebilir ï· AdjustmentEvent // asaÄÄ± yukarÄ± kaydÄ±rma cubugunda (scroll bar) bir iÅlem yapÄ±ldÄ±ÄÄ±nda kullanÄ±lÄ±r. ï· ItemEvent // List veya CheckBox kliklendiginde (bir kere) kullanÄ±lÄ±r ï· ComponentEvent //appletteki elemanlarÄ±n gizlenmesi, boylarÄ±nÄ±n deÄiÅtirilmesi, veya deÄiÅik yerlere alÄ±nmasÄ± amacÄ±yla kullanÄ±lÄ±r. ï· ContainerEvent //Containera(applete) yeni bir eleman eklenilir veya Ã§Ä±karÄ±lÄ±rken kullanÄ±lÄ±r. ï· FocusEvent//herhangi bir applet elemanÄ± kullanÄ±lmaya baslandÄ±gÄ±nda on plana cÄ±karÄ±lmakk, ve kullanÄ±lmadÄ±gÄ±nda arka plana atÄ±lmak istendiÄinde kullanÄ±lÄ±r. ï· PaintEvent ï· WindowEvent //pencere acÄ±lÄ±p kapandÄ±ÄÄ±nda,kÃ¼cÃ¼ltÃ¼lÃ¼p bÃ¼yÃ¼tÃ¼ldÃ¼ÄÃ¼nde vb kullanÄ±lÄ±r. Dinleme iÅlemini yapan metotlar ÅunlardÄ±r Java.util.EventListener ï· ActionListener ï· AdjustmentListener ï· ComponentListener ï· ContainerListener ï· FocusListener ï· ItemListener ï· KeyListener ï· MouseListener ï· MouseMotionListener ï· TextListener ï· WindowListener Bu metotlarÄ±n bir Ã§oÄunu ilgili Ã¶rneklerde yeri geldiÄinde kullanacaÄÄ±z. * import java.awt.event. class B2Basilinca implements ActionListener { Applet applet public B2Basilinca(Applet a) {applet=a } public void actionPerformed(ActionEvent e) { applet.showStatus( +e.paramString()+ dugmesine basildi ) } } * import java.awt.event. Birinci programda dÃ¼Ämelere basÄ±ldÄ±ÄÄ±nda oluÅan eylemler (showStatus kÃ¶Åesine basÄ±lan dÃ¼Ämeyi yazdÄ±rma) ayrÄ± sÄ±nÄ±flarda yaptÄ±rÄ±lmÄ±Å ve Applet sÄ±nÄ±fÄ± Ã¼zerinden bizim ButtonTesti sÄ±nÄ±fÄ±na aktarÄ±lmÄ±ÅtÄ±r. Ä°kinci programda ise aynÄ± iÅlemler tek bir sÄ±nÄ±fÄ±n iÃ§erisinde yer almÄ±ÅtÄ±r. Programdan da gÃ¶rÃ¼lecegi gibi dÃ¼Äme basma eylemi ActionEvent sÄ±nÄ±fÄ± Ã¼zerinden aktarÄ±lmÄ±ÅtÄ±r. JButton sÄ±nÄ±fÄ± ile Button sÄ±nÄ±fÄ± arasÄ±nda kullanÄ±m aÃ§Ä±sÄ±ndan Label ve Jlabel sÄ±nÄ±fÄ±nÄ±n arasÄ±ndakilere benzer farklar vardÄ±r. JButton sÄ±nÄ±fÄ±nÄ±n sÄ±nÄ±f tanÄ±mÄ± public class JButton extends AbstractButton implements Accessible { public JButton() public JButton(Icon resim) public JButton(String yazÄ±) public JButton(String yazÄ±, Icon resim) public AccessibleContext getAccessibleContext() public String getUIClassID() public boolean isDefaultButton() public boolean isDefaultCapable() public void setDefaultCapable(boolean b) pubkic void updateUI() } Åeklindedir. GÃ¶rÃ¼ldÃ¼ÄÃ¼ gibi JButton fazla metod barÄ±ndÄ±rmaz bir Ã§ok Ã¶nemli metodu Abstract button ve onun tepe sÄ±nÄ±fÄ± JComponent sÄ±nÄ±flarÄ±ndan alÄ±r. JButton sÄ±nÄ±fÄ±nda Jlabel sÄ±nÄ±fÄ±nda da kullandÄ±ÄÄ±mÄ±z JComponent sÄ±nÄ±fÄ±ndan gelen metodlar public void setBackground(Color c) arkaplan rengini deÄiÅtiri public Color getBackground() arkaplan rengini okur public void setForeground(Color c) Ã¶npaln rengini deÄiÅtiri public Color getForeground() Ã¶n plan rengini okur. public void setFont(Font f) yazÄ± fontunu seÃ§er public Font getFont() yazÄ± fontunu okur public Boolean isVisible() gÃ¶rÃ¼nÃ¼r olup olmadÄ±ÄÄ±nÄ± kontrol eder public Void setVisible(Boolean b) gÃ¶rÃ¼nÃ¼r veya gÃ¶rÃ¼nmez yapar. AbstractButton sÄ±nÄ±fÄ±nda tanÄ±mlanmÄ±Å bazÄ± alt sÄ±nÄ±flar public void setText(String s) JLabel'Ä±n text deÄiÅkeninin deÄerine yeni verilen deÄeri atar public String getText() AbstractButton'Ä±n String text deÄiÅkenini okur. public int getVerticalAlignment() public void setVerticalTextPosition(int dÃ¼Åey_pozisyon) AbstractButtonâÄ±n iÃ§indeki yazÄ±nÄ±n Label iÃ§indeki dÃ¼Åey pozisyonunu ayarlar. Sabitler Ã¼sttekilerin aynÄ±dÄ±r. public int getVerticalTextPosition() AbstractButtonâÄ±n iÃ§indeki yazÄ±nÄ±n AbstractButton iÃ§indeki dÃ¼Åey pozisyonunu okur. public void setHorizontalTextPosition(int dÃ¼Åey_pozisyon) AbstractButtonâÄ±n iÃ§indeki yazÄ±nÄ±n AbstractButton iÃ§indeki yatay pozisyonunu ayarlar. Public void setIcon(Icon resim) AbstractButtonâÄ±n iÃ§indeki resmi deÄiÅtirir veya eÄer yoksa ilk defa atar public Icon getIcon() AbstractButton iÃ§indeki resmi okur. public void setDisplayedMnemonic(int c) Mnemoic alt harf kontrolunu kullanarak belli bir giriÅe ulaÅmayÄ± saÄlar. (Ã¶rneÄin âm' harfine set edilmiÅse alt-m bu komuta gider. Ãrnek problemlerle bu kavram aÃ§Ä±lacaktÄ±r. Public int getDisplayedMnemonic(int c) Mnemonic deÄerini okur. Listener (pencere dinleme) metod ve neslerinden ise protected ActionListener actionListener protected Itemlistener itemListener protected ChangeListener changeListener public void addActionListener(ActionListener l) public void addChangeListener(ChangeListener l) public void addItemListener(ItemListener l) public void removeActionListener(ActionListener l) public void removeChangeListener(ChangeListener l) public void removeItemListener(ItemListener l) public String getActionCommand() public void setActionCommand(String com) gibi metodlar mevcuttur. * import java.awt. * import java.awt.event. * Not isimler aynÄ± olduÄundan bu iki programÄ± aynÄ± dosyalarda saklÄ±yamayÄ±z. Åekil 8. */ import javax.swing. JPanel pane = new JPanel() pane.add(b1) pane.add(b2) pane.add(b3) //Add JPanel to this applet, using the default BorderLayout. Åekil 9. ButtonDemoApplet.java sonuÃ§larÄ±nÄ±n swing JApplet olarak Appletviewer browserÄ±nda gÃ¶rÃ¼ntÃ¼sÃ¼ Programdan da gÃ¶rÃ¼ldÃ¼ÄÃ¼ gibi bu program bir Ã¶nce verilmiÅ olan programÄ±n swing frame benzeridir. Ä°ki program da Applet olarak verilmiÅtir. Programlarda setEnabled(Boolean b) metodu kullanÄ±larak dÃ¼Ämenin Ã§alÄ±ÅmasÄ± etkisisz hale getirilmiÅtir. URL network ortamÄ±nda bilgi aktarmaya yarayan bir sÄ±nÄ±ftÄ±r. Resim dosyasÄ± baÅka bir bilgisayarda olabilirdi. TextField'in metotlarÄ± aÅaÄÄ±da verilmiÅtir ï· Kurucu Metotlar public TextField() public TextField(int satÄ±rsayÄ±sÄ±) // satÄ±r sayÄ±sÄ± uzunluÄunda bir yazÄ± kutusu aÃ§ar. public TextField(String s) // s uzunluÄunda bir yazÄ± kutusu aÃ§r ve s yi iÃ§ine yazar public TextField(String s,int satÄ±rsayÄ±sÄ±) ) // satÄ±r sayÄ±sÄ± uzunluÄunda bir yazÄ± kutusu aÃ§r ve s yi iÃ§ine yazar ï· DiÄer Metotlar Public void setEchoChar(char c) // kutudaki gerÃ§ek yazÄ±yÄ± gizleyerek onun yerine c karacter deÄiÅkenini yazar. Public void setEditable(boolean b) //kutunun iÃ§ine yazÄ±lan yazÄ±nÄ±n degiÅtirileblmesini saÄlar veya engeller b=true yazÄ± yazÄ±labilir b=false yazÄ± yazÄ±lamaz. * import java.awt.event. TextField sÄ±nÄ±fÄ±nÄ±n java swing eÅdeÄeri JTextField sÄ±nÄ±fÄ±dÄ±r. JTextField sÄ±nÄ±fÄ± kurucu metotlarÄ± JTextField() JTextField(String) JTextField(String, int) JTextField(int) JTextField(Document, String, int) Åeklindedir. TextFielde Paralel olarak Ãzel bir TextField tÃ¼rÃ¼ olan PasswordField de swingde tanÄ±mlanmÄ±ÅtÄ±r. PassWord fieldin kurucu metod tanÄ±mlarÄ± JPasswordField() JPasswordField(String) JPasswordField(String, int) JPasswordField(int) JPasswordField(Document, String, int) Åeklinde tanÄ±mlanmÄ±ÅtÄ±r. Bu iki sÄ±nÄ±fÄ±n Text deÄerini girmak veya okumak iÃ§in void setText(String) String getText() metodlarÄ± tanÄ±mlanmÄ±ÅtÄ±r. void setEditable(boolean) boolean isEditable() metodlarÄ± YazÄ± alanÄ±ndaki yazÄ±yÄ± kullanÄ±cÄ±nÄ±n deÄiÅtirp deÄiÅtiremeyaceÄini saptar veya bu mÃ¼sadeyi deÄiÅtirir. void setColumns(int) int getColumns() int getColumnWidth() metodlarÄ± yazÄ± alanÄ±nÄ±n byutunu deÄiÅtirmek veya saptamak amacÄ±yla kullanÄ±labilir. void setHorizontalAlignment(int) int getHorizontalAlignment() metodlarÄ± yazÄ±Ä± alanÄ±ndaki yazÄ±nÄ±n ne Åekilde yerleÅtirildiÄini saptar veya isteÄe gÃ¶re yerleÅtirir. void addActionListener(ActionListener) metodlarÄ± ise TextFieldin dinlenmesini ve giriÅ tuÅu basÄ±ldÄ±ÄÄ±nda yapÄ±lacak eylemlerin verildiÄi ActionListener implement'inden gelen public void actionPerformed(ActionEvent e) metodunu Ã§alÄ±ÅtÄ±rmaya yarar. void removeActionListener(ActionListener) ise ActionListener dinleme metodunu iptal eder. JTextField ve JPasswordField metodlarÄ±nÄ±n kullanÄ±lmasÄ±nÄ± bir Ã¶rnek problemle inceleyelim. Bu bir Ã¶nceki problemin hemen hemen aynÄ± iÅlemleri yapan JFrame ortamÄ±nda yazÄ±lmÄ±Å bir Ã¶rnek problemdir. * import java.awt. * import java.awt.event. En onemli farkÄ± bir satÄ±r yerine birden fazla satÄ±r girdi alabilme olasÄ±lÄ±ÄÄ±dÄ±r. TextField ve TextArea sÄ±nÄ±flarÄ± TextComponent sÄ±nÄ±fÄ±nÄ±n alt sÄ±nÄ±flarÄ±dÄ±r. Bu yÃ¼zden Ã¼stte belirttiÄimiz Public void setEchoChar(char c) // kutudaki gerÃ§ek yazÄ±yÄ± gizleyerek onun yerine c karacter deÄiÅkenini yazar. Public void setEditable(boolean b) //kutunun iÃ§ine yazÄ±lan yazÄ±nÄ±n degiÅtirileblmesini saÄlar veya engeller b=true yazÄ± yazÄ±labilir b=false yazÄ± yazÄ±lamaz. MetotlarÄ± burada da aynen geÃ§erlidir.TextArea'nÄ±nkurucu metotlarÄ±da ÅÃ¶yledir public TextArea() public TextArea(int sÃ¼tun,int satÄ±r) sÃ¼tun x satÄ±r boyutunda yazÄ± alanÄ± tanÄ±mlar public TextArea(String s) String deÄiÅkeni s nin boyuna gÃ¶re yazÄ± alanÄ± tanÄ±mlar ve s yi iÃ§ine yazar. Alt satÄ±ra geÃ§ ve gelecek tab noktasÄ±na git anlamÄ±na gelir Bu komutlar aslÄ±nda c dilinden alÄ±nmadÄ±r ve c dilindeki tÃ¼m \ komutlarÄ± java stringlerinde de geÃ§erlidir. * import java.awt.event. Buradaki metot birinci kutuya yazÄ±lan yazÄ±yÄ± ikinci kutuya kopyalamaktadÄ±r. Kopye dÃ¼Ämesine basÄ±lÄ±nca ise sadece T1.getSelectedText() metotuyla secilmiÅ olan text actionPerforned metotu Ã¼zerinden T2 YazÄ±m AlanÄ±na (TextArea) aktarÄ±lmaktadÄ±r. Java swing JTextArea sÄ±nÄ±fÄ± awt deki TextArea sÄ±nÄ±fÄ±nÄ±n benzeridir. SÄ±nÄ±fÄ±n kurucu metodlarÄ±nÄ±n tanÄ±mÄ± public JTextArea() public JTextArea(int rows,int cols) public JTextArea(Document doc) public JTextArea(Document doc, String Text, int satÄ±rsayÄ±sÄ± int sÃ¼tun sayÄ±sÄ±) public JTextArea(String Text) public JTextArea(String Text,int satÄ±rsayÄ±sÄ± int sÃ¼tun sayÄ±sÄ±) Åeklindedir. * import java.awt. * import java.awt.event. Choice sÄ±nÄ±fÄ±nÄ±n kurucu metotu ve diger metotlarÄ±nÄ±n listesi aÅaÄÄ±da verilmiÅtir public Choice() // Kurucu metot public String getItem(int indeks) Ä°ndeksteki seÃ§imi verir public synchronised void add(String s) verilen Stringi Choice listesine ekler. * import java.applet.Applet import java.awt.event. Choice seÃ§imlerini yukarÄ±daki ChoiceTesti.html de de gÃ¶rÃ¼leceÄi gibi aktarÄ±lÄ±rken ItemListener ve ItemEvent kullanÄ±lmÄ±ÅtÄ±r. Bu metotla kullanÄ±lmasÄ± gereken method ItemStateChanged metotudur. Onun yerini JComboBox sÄ±nÄ±fÄ± almÄ±ÅtÄ±r JComboBox sÄ±nÄ±fÄ±nÄ±n Kurucu metodlarÄ± public JComboBox() public JComboBox(ComboBoxModel m) public JComboBox(Object obj[]) public JComboBox(Vector v) Åeklindedir. Vector geliÅmiÅ bir boyutlu deÄiÅken tÃ¼rÃ¼dÃ¼r detaylarÄ± 11 inci bÃ¶lÃ¼m, geliÅmiÅ java bilgi iÅleme yapÄ±larÄ± kÄ±smÄ±nda verilmiÅtir. ComboBox Jcomponent sÄ±nÄ±fÄ±ndan tÃ¼retilmiÅtir. ActionListener, ItemSelectable, ListDataListener ve Accessible sÄ±nÄ±flarÄ±nÄ± implement eder. JComboBox sÄ±nÄ±fÄ±, seÃ§ilen sÄ±nÄ±fÄ± size veren veya seÃ§ilme opsiyonunu tanÄ±mlayan Åu sÄ±nÄ±flarÄ± barÄ±ndÄ±rÄ±r getSelectedItem() bu noktadaki Object deÄerini Ã§aÄÄ±rÄ±r. getSelectedIndex() bu noktanÄ±n indeks deÄerini Ã§aÄÄ±rÄ±r getSelectedObjects() birden fazla seÃ§im yapÄ±ldÄ±ÄÄ±nda tÃ¼m seÃ§ilen object listesini iletir. * import javax.swing. * import java.awt.event. public void itemStateChanged(ItemEvent e) { C.setFont(new Font(e.getItem().toString(), C.getFont().getStyle(), C.getFont().getSize())) } } class TextFieldKontrolu implements ItemListener { private JTextField T public TextFieldKontrolu(JTextField T) { this.T=T } public void itemStateChanged(ItemEvent e) { JComboBox C=(JComboBox)e.getItemSelectable() T.setText( Indeks + C.getSelectedIndex()+ Font +e.getItem()) }} Kurucu metotlarÄ± Public CheckBox(String s) Tek bir kare kontrol kutusu oluÅturur. Kontrol kutusu baÅta boÅtur Public CheckBox(String s, CheckBoxGroup c,boolean durum) Tekbir daire Åeklinde kontrol kutusu oluÅturur ve bu kontrol kutusunu CheckBoxGroup nesnesine ilave eder. * import java.awt.event. * public class CheckBoxTesti extends Applet implements ItemListener { private TextField T private Checkbox Kalin,Italic public void init() { setBackground(Color.lightGray) //bos textField T=new TextField( Buradaki yazinin degismesini izleyiniz ) add(T) Kalin=new Checkbox( Kalin ) Kalin.addItemListener(this) add(Kalin) Italic=new Checkbox( Italik ) Italic.addItemListener(this) add(Italic) } public void itemStateChanged(ItemEvent e) Burada guruplanmÄ±Å olan checkbox'lardan sadece bir tanesini seÃ§me izni verilmiÅtir. * import java.awt.event. else if(e.getSource()== Italic) {T.setFont(ItalicFont) } else if(e.getSource()== KalinItalic) {T.setFont(KalinItalicFont) } } } JCheckBox sÄ±nÄ±fÄ±nÄ±n kurucu metodlarÄ± public JCheckBox() public JCheckBox(Icon resim) public JCheckBox(Icon resim,boolean kutuiÅareti) public JCheckBox(String yazÄ±) public JCheckBox(String yazÄ±, boolean kutuiÅareti) public JCheckBox(String yazÄ±, Icon resim) public JCheckBox(String yazÄ±, , Icon resim ,boolean kutuiÅareti) Burada da daha Ã¶nceki JLabel, JButton gibi sÄ±nÄ±flarda gÃ¶rdÃ¼ÄÃ¼mÃ¼z gibi yazÄ±nÄ±n yanÄ±nda resim yerleÅtirme seÃ§imimiz de mevcuttur. Buradaki Ã¶rnek problemde bir Ã¶nceki problemin aynÄ±sÄ± JcheckBox ile Ã§Ã¶zÃ¼lmÃ¼ÅtÃ¼r. * import java.awt. * import java.awt.event. Kurucu metodlarÄ± public JRadioButton() public JRadioButton(Icon resim) public JRadioButton(Icon resim,boolean kutuiÅareti) public JRadioButton(String yazÄ±) public JRadioButton(String yazÄ±, boolean kutuiÅareti) public JRadioButton(String yazÄ±, Icon resim) public JRadioButton(String yazÄ±, , Icon resim ,boolean kutuiÅareti) Burada JRadioButton sÄ±nÄ±fÄ±na ilave olarak bir tane daha ilave olarak bir tane daha yardÄ±mcÄ± sÄ±nÄ±f kullanacaÄÄ±z. Bu sÄ±nÄ±f ButtonGroup sÄ±nÄ±fÄ±dÄ±r. Bu sÄ±nÄ±f dÃ¼Ämeleri bir gurup altÄ±nda toplayarak sadece bir tanesinin basÄ±lÄ± durumda olmasÄ± iÅlevini kontrol eder. Bu sÄ±nÄ±fÄ±n tanÄ±mÄ± public class ButtonGroup extends Object implements Serializable { protected Vector dÃ¼Ämeler public ButtonGroup() public void add(AbstractButton ab) public Enumeration getElements() public ButtonModel getSelection() public boolean isSelected(ButtonModel bm) public void remove(AbstractButton ab) public void setSelected(ButtonModel bm,boolean b) } Åeklindedir. Åimdi yine bir Ã¶ncekine benzer bir Ã¶rnekte JradioButton ve ButtonGroup sÄ±nÄ±flarÄ±nÄ±n birarada kullanÄ±mÄ±nÄ± gÃ¶relim. * import java.awt. * import java.awt.event. * public class RadioButtonTestiSWF extends JFrame implements ItemListener } public static void main(String[] args) { RadioButtonTestiSWF pencere= new RadioButtonTestiSWF() pencere.addWindowListener(new BasicWindowMonitor()) pencere.setSize(400,100) pencere.setVisible(true) } } JToggleButton sÄ±nÄ±fÄ± iÅlevsel olarak JcheckBox sÄ±nÄ±fÄ±nÄ±n aynÄ±dÄ±r. Sadece basÄ±lÄ±m alanÄ± dÃ¼Äme(button) Åeklindedir. JcheckBox iÃ§in verdiÄimiz programÄ±n JToggleButton'a dÃ¶nÃ¼ÅtÃ¼rÃ¼lmÃ¼Å Åekli aÅaÄÄ±da verilmiÅtir. * import java.awt. * import java.awt.event. Javada gurubunda temel fare kontrollarÄ±nÄ± saÄlayan sÄ±nÄ±flar MouseListener ve MouseMotionListener sÄ±nÄ±flarÄ±dÄ±r. Bu sÄ±nÄ±flarÄ±n en Ã§ok kullanÄ±lan metotlarÄ± ÅunlardÄ±r 1. MouseListener MetotlarÄ± public void mousePressed(MouseEvent e) bir mouse dÃ¼Ämesi basÄ±lÄ±nca Ã§aÄÄ±rÄ±lÄ±r public void mouseClicked(MouseEvent e) bir mouse dÃ¼Ämesi basÄ±lÄ±p bÄ±rakÄ±lÄ±rsa Ã§aÄÄ±rÄ±lÄ±r. public void mouseReleased(MouseEvent e) Bir mouse dÃ¼Ämesi basÄ±lÄ± olarak mouse Ã§ekildikten sonra dÃ¼Äme bÄ±rakÄ±lÄ±nca Ã§aÄÄ±rÄ±lÄ±r. public void mouseEntered(MouseEvent e) mouse pencere iÃ§ine girince Ã§aÄÄ±rÄ±lÄ±r. public void mouseExited(MouseEvent e) mouse pencere Ã§erÃ§evesinin dÄ±ÅÄ±ndaysa Ã§aÄÄ±rÄ±lÄ±r. 2. MouseMotionListener MetotlarÄ± public void mouseDragged(MouseEvent e) Mouse dÃ¼Ämesi basÄ±lÄ± iken mouse hareket ettirilirse Ã§aÄÄ±rÄ±lÄ±r public void mouseMoved(MouseEvent e) Mouse hareket ederse Ã§aÄÄ±rÄ±lÄ±r. Bu metotlarÄ±n kullanÄ±mlarÄ±nÄ± gÃ¶stermek amacÄ±yla FareTesti.java programÄ± aÅaÄÄ±da verilmiÅtir. Bu program awt Applet programÄ± olarak hazÄ±rlanmÄ±ÅtÄ±r. * import java.awt.event. * public class FareTesti extends Applet implements MouseListener, MouseMotionListener { private int nx,ny=-10 private String s= public void init() { addMouseListener(this) addMouseMotionListener(this) } public void paint(Graphics g) { g.drawString(s+ [ +nx+ , +ny+ ] ,nx,ny) } public void degerleriGir(String e,int x,int y) { s=e nx=x ny=y repaint() } //fare dinleyicisinin dinledikleriyle ilgili cikti metotlari public void mouseClicked(MouseEvent e) { degerleriGir( Kliklendi ,e.getX(),e.getY()) } public void mousePressed(MouseEvent e) { degerleriGir( Basildi ,e.getX(),e.getY()) } public void mouseReleased(MouseEvent e) { degerleriGir( Birakildi ,e.getX(),e.getY()) } public void mouseEntered(MouseEvent e) { showStatus( Fare applet alani icinde ) } public void mouseExited(MouseEvent e) { showStatus( Fare applet alani disinda ) } //MouseMotionListener (fare hareket dinleyicisi) metotlari public void mouseDragged(MouseEvent e) { degerleriGir( basilip cekiliyor ,e.getX(),e.getY()) } public void mouseMoved(MouseEvent e) { degerleriGir( hareket halinde ,e.getX(),e.getY()) } } * import java.awt. * import java.awt.event. public void mouseEntered(MouseEvent e) { setTitle( Fare applet alanÄ± iÃ§inde ) } public void mouseExited(MouseEvent e) { setTitle( Fare applet alanÄ± dÄ±ÅÄ±nda ) degerleriGir( Fare applet alanÄ± dÄ±ÅÄ±nda ,e.getX(),e.getY()) } //MouseMotionListener (fare hareket dinleyicisi) metotlari public void mouseDragged(MouseEvent e) { degerleriGir( basilip cekiliyor ,e.getX(),e.getY()) } public void mouseMoved(MouseEvent e) { degerleriGir( hareket halinde ,e.getX(),e.getY()) } public static void main(String[] args) { FareTestiSWF pencere= new FareTestiSWF() pencere.addWindowListener(new BasicWindowMonitor()) pencere.setSize(350,150) pencere.setVisible(true) } } JTable sÄ±nÄ±fÄ±nÄ±n kurucu sÄ±nÄ±flarÄ± public JTable() public JTable(TableModel tm) public JTable(TableModel tm, TableColumnModel tcm) public JTable(TableModel tm, TableColumnModel tcm, ListSelectionModel lm) public JTable(int satÄ±rsayÄ±sÄ±,int sÃ¼tunsayÄ±sÄ±) public JTable(Object[][] tablogirdisi ,Object[] tablobaÅlÄ±ÄÄ±girdisi) public JTable(Vector tablogirdisi ,Vector tablobaÅlÄ±ÄÄ±girdisi) Åeklindedir. Kurucu metodlarda girdi olarak gÃ¶rÃ¼nen TableModel sÄ±nÄ±fÄ± public interface TableModel{ public abstract void addTableModelListener(TableModelListener l) public abstract Class getColumnClass(int sÃ¼tun) public abstract int getColumnCount() public abstract String getColumnName(int Column) public abstract int getRowCount() public abstract Object getValueAt(int satÄ±r, int sÃ¼tun) public abstract boolean isCellEditable(int satÄ±r, int sÃ¼tun) public abstract void removeTableModelListener(TableModelListener l) public abstract void setValueAt(Object o.int satÄ±r,int sÃ¼tun) } gÃ¶rÃ¼ldÃ¼ÄÃ¼ gibi bu sÄ±nÄ±f interface olduÄundan bu sÄ±nÄ±ftan tÃ¼retilen sÄ±nÄ±flarÄ±n bu sÄ±nÄ±ftaki tÃ¼m metodlarÄ± tanÄ±mlamalarÄ± gerekir. Bu yÃ¼zden AbstractTableModel gibi Table Model'den tÃ¼retilen sÄ±nÄ±flar Ã¼zerinden yeni sÄ±nÄ±fÄ±n tÃ¼retilmesine gidilebilir. public abstract class AbstractTableModel implements TableModel { public AbstractTableModel() public abstract void addTableModelListener(TableModelListener l) public int findColumn(String ColumnName) public void fireTableCellUpdated(int satÄ±r,int sÃ¼tun) public void fireTableChanged(TableModelEvent e) public void fireTableDataChanged() public void fireTableRowsDeleted(int satÄ±r,int sÃ¼tun) public void fireTableRowsInserted(int satÄ±r,int sÃ¼tun) public void fireTableRowsUpdated(int satÄ±r,int sÃ¼tun) public void fireTableStructureChanged() public abstract Class getColumnClass(int sÃ¼tun) public abstract String getColumnName(int Column) public abstract boolean isCellEditable(int satÄ±r, int sÃ¼tun) public abstract void removeTableModelListener(TableModelListener l) public abstract void setValueAt(Object o.int satÄ±r,int sÃ¼tun) } Ãrnek problemlerde Ã¶nce AbstractTableModel'den tÃ¼retilen ve Tablonun giriÅ deÄerlerini veren TableModel sÄ±nÄ±fÄ± yaratÄ±lmÄ±Å, sonra bu sÄ±nÄ±f tabloda girdi olarak kullanÄ±lmÄ±ÅtÄ±r. * import java.awt.event. * import javax.swing. * import javax.swing.table. * import javax.swing.event. //===================================================== public static void main(String[] args) { tableSWF_2000 pencere= new tableSWF_2000() pencere.setVisible(true) } } * import java.awt.event. * import javax.swing. * import javax.swing.table. * import javax.swing.event. List ve Jlist sÄ±nÄ±flarÄ± bir listeden seÃ§im yapmaya ve bu seÃ§im sonucu gerekli iÅlemleri oluÅturmaya yarar. List sÄ±nÄ±fÄ± ItemListener ve ActionListener sÄ±nÄ±f implementlerini kullanÄ±r. Ãrnek programÄ±mÄ±zda Listeden seÃ§ilen renge gÃ¶re arkaplan rengi deÄiÅmektedir. * import java.awt.event. * public class ListTesti extends Applet implements ActionListener,ItemListener { private List renkListesi private String renkIsmi[]={ Siyah , Mavi , Cam Gobegi , Koyu Gri , Gri , Yesil , Acik gri , Mor , Portakal , Pembe , Kirmizi , Beyaz , Sari } private Color C[]={Color.black,Color.blue,Color.cyan,Color.darkGray, Color.gray,Color.green,Color.lightGray,Color.magenta,Color.orange, Color.pink,Color.red,Color.white,Color.yellow} public void init() { //Ekranda 5 isim g rÂlebilecel bir liste ac //aynÂ ismi birden fazla tekrarlama renkListesi=new List(5,false) renkListesi.addActionListener(this) renkListesi.addItemListener(this) //listeye ekle for(int i=0 i<renkIsmi.length i++) { renkListesi.add(renkIsmi[i]) } add(renkListesi) } public void actionPerformed(ActionEvent e) { setBackground(C[renkListesi.getSelectedIndex()]) repaint() } public void itemStateChanged(ItemEvent e) { showStatus(renkListesi.getSelectedItem()+ indeks + renkListesi.getSelectedIndex()) } } Jlist metodu pencereye ilave edilirken direk olarak ilave edilmez, JscrollPane alt pencere programÄ± Ã¼zerinden ilave edilir. AynÄ± zamanda dinleme metodu olarak ListSelectionListener metodu kullanÄ±lÄ±r. Bu metod java swing kÃ¼tÃ¼phanesi javax.swing.event de tanÄ±mlanmÄ±ÅtÄ±r. JList metoduyla bir seÃ§im yapÄ±ldÄ±ÄÄ± gibi birden fazla seÃ§im yapmakta mÃ¼mkÃ¼ndÃ¼r. JList metodunun kurucu metodlarÄ± public JList() public JList(ListModel lm) public JList(Object o[]) public JList(Vector v) dir. SeÃ§imde kullanÄ±lan bazÄ± Ã¶nemli metodlarÄ± public int GetSelectedIndex() seÃ§ilen (veya en son seÃ§ilen) elemanÄ±n indisini verir public int[] getSelectedIndices() seÃ§ilen elemanlarÄ±n (birden fazla olabilir) indislerini boyut Ã¼zerinden aktarÄ±r public Object getSelectedValue() son seÃ§ilen elemandaki deÄeri Object olarak aktarÄ±r. public object[] getSelectedValues() seÃ§ilen elemanlardaki deÄerleri boyutlu object olarak aktarÄ±r void setSelectionMode(int mode) tek eleman mÄ± seÃ§ileceÄini yoksa Ã§ok sayÄ±da eleman mÄ± seÃ§ileceÄini belirler. Public void setVisibleRowCount(int sayÄ±) listenin kaÃ§ elemanÄ±nÄ±n gÃ¶rÃ¼ntÃ¼leneceÄini verir. Listenin kenar kayma Ã§ubuklarÄ±, listenin iÃ§inde yer alacaÄÄ± JScrollPane penceresi tarafÄ±ndan oluÅturulur. JScrollPane metodunun kurucu metodlarÄ± public JScrollPane() public JScrollPane(int dÃ¼ÅeyÃ§ubukÃ§eÅidi,int yatayÃ§ubukÃ§eÅidi) public JScrollPane(Component pencere) public JScrollPane(Component pencere ,int dÃ¼ÅeyÃ§ubukÃ§eÅidi,int yatayÃ§ubukÃ§eÅidi) Buradaki pencere JScrollPane'in iÃ§inde yeralacaÄÄ± container'Ä± gÃ¶sterir. YatayÃ§ubukÃ§eÅidi ise JScrollPane. BirkaÃ§ Ã¶rnek problemle Jlist sÄ±nÄ±fÄ±nÄ± vermetye Ã§alÄ±ÅalÄ±m. Ä°lk Ã¶rnek yukarÄ±daki JcomboBox problemlerin aynÄ± iÅlemini yapmaktadÄ±r. Listeden yapÄ±lan seÃ§ime gÃ¶re JtextField alanÄ±ndaki fontu deÄiÅtirecektir. Listenin iki elemanÄ±nÄ±n gÃ¶rÃ¼lmesi mÃ¼sadesi verilmiÅtir. Liste tek seÃ§imli listedir. * import javax.swing. * import java.awt.event. * import javax.swing.event. Bu Ã¶rnekte ise listeden yapacaÄÄ±mÄ±z seÃ§ime gÃ¶re arka plan rengini deÄiÅtiriyoruz. Bu program yukarÄ±da verilen List programÄ±nÄ±n oldukÃ§a benzeridir. Listede dÃ¶rt elemanÄ±n gÃ¶rÃ¼lmesi izni verilmiÅtir. Liste tek seÃ§imli bir listedir. * // java swing sinifini cagir import javax.swing.event. * import java.awt. * // java pencere kullanma sinifini cagir import java.awt.event. DiÄer bir Liste kullanma Ã¶rneÄi Bu Ã¶rnekte Listeye JtextField Ã¼zerinden ilave yapabiliyoruz ve Ã§Ä±karabiliyoruz. Ãrnek Java dÃ¶kÃ¼man kÃ¼tÃ¼phanesinden alÄ±nÄ±p adapte edilmiÅtir. * import java.awt.event. * import javax.swing. * import javax.swing.event. int index = list.getSelectedIndex() listModel.remove(index) int size = listModel.getSize() //Listede eleman kalmadÄ± iÅten atmayÄ± durdur if (size == 0) { fireButton.setEnabled(false) //seÃ§imi dÃ¼zenle } else { if (index == listModel.getSize()) index-- list.setSelectedIndex(index) } } } class HireListener implements ActionListener { public void actionPerformed(ActionEvent e) { //EÄer yeni isim girilmemiÅse if (employeeName.getText().equals( )) { Toolkit.getDefaultToolkit().beep() return } int index = list.getSelectedIndex() int size = listModel.getSize() if (index == -1 || (index+1 == size)) { listModel.addElement(employeeName.getText()) list.setSelectedIndex(size) } else { listModel.insertElementAt(employeeName.getText(), index+1) list.setSelectedIndex(index+1) } } } public void valueChanged(ListSelectionEvent e) { if (e.getValueIsAdjusting() == false) { if (list.getSelectedIndex() == -1) { fireButton.setEnabled(false) employeeName.setText( ) } else { fireButton.setEnabled(true) String name = list.getSelectedValue().toString() employeeName.setText(name) } } } public static void main(String s[]) { JFrame frame = new ListDemoSWF() frame.addWindowListener(new BasicWindowMonitor()) frame.pack() frame.setVisible(true) } } AÅaÄÄ±daki Ã¶rnekte listeden Liste tÃ¼rÃ¼ deÄiÅkeninde yaptÄ±ÄÄ±mÄ±z deÄiÅikliÄe gÃ¶re bir veya birden fazla seÃ§im yapabiliyoruz . Bu program hem JFrame hem de Japplet olarak Ã§alÄ±Åabilmektedir. * import javax.swing.event. * import javax.swing.table. * import java.util. * import java.awt. * import java.awt.event. * public class ListSelectionDemo extends JApplet { JTextArea output JList list JTable table String newline = \n ListSelectionModel listSelectionModel private boolean inAnApplet = true //bazÄ± sistemlerde ana kurucu metod olmayÄ±nca hata verebileceÄi // iÃ§in tanÄ±mlandÄ±. // Find out which indexes are selected. int minIndex = lsm.getMinSelectionIndex() int maxIndex = lsm.getMaxSelectionIndex() for (int i = minIndex i <= maxIndex i++) { if (lsm.isSelectedIndex(i)) { output.append( + i) } } } output.append(newline) } } } Menuler pencerenin tepesinden aÃ§Ä±lan ve Ã§eÅitli gÃ¶revler yÃ¼klenen komponentlerdir. Java swing menu'leri temel olarak JMenuBar, JMenu ve JMenuItem sÄ±nÄ±flarÄ±ndan oluÅur. AyrÄ±ca menulerde JcheckBoxMenuItem, JradioButtonMenuItem gibi alt elemanlar da bulunabilir. JmenuBar kurucu metodu Public JmenuBar() Åeklindedir. BazÄ± Ã¶nemli metodlarÄ± public JMenu add(JMenu menu) menu ilave eder public Component getComponent() public Component getComponentAtIndex(int indeks) public Insets getMargin() public Jmenu getMenu(int) public int getMenuCount() public SingleSelectionModel getSelectionModel() public MenuElement[] getSubElements() protected void paintBorder(Graphics g) public void processMouseEvent(MouseEvent e,MouseElement path[],MouseSelectionManager mgr) public void setBorderPainted(boolean b) public void setHelpMenu(Jmenu menu) public void setMargin(Insets in) pubic void setSelected(Component c) Jmenu kurucu metodlarÄ± public JMenu() public JMenu(String Label) public JMenu(String label,boolean menudenayÄ±r) BazÄ± Ã¶nemli JMenu metodlarÄ± public JMenuItem add(Action act) public JMenuItem add(JMenuItem item) public Component add(Component c) public void add(String Jlabel) public void addMenuListener(MenuListener l) public void addSeperator() public JMenuItem getItem(int pos) public int getItemCount() public Component getMenuComponent(int pos) public int getMenuComponentCount() public Component[] getMenuComponents(public MenuElement[] getSubElements() public JMenuItem insert(JMenuItem item,int pos) public void insert(String etiket,int pos) public void remove(int pos) public void remove(MenuItem item) public void removeAll() public void removeMenuListener(MenuListener l) public void setAccelerator(KeyStroke s) public void setDealy(int delay) public void setMenuLocation(int x,int y) public void setPopUpMenuVisible(boolean b) public void setSelected(boolean b) JMenuItem kurucu metodlarÄ± public JMenuItem() public JMenuItem(Icon resim) public JMenuItem(String Label) public JMenuItem(String Label,int mnemonic) public JMenuItem(String Label,Icon resim) bazÄ± metodlarÄ± publci Component getComponent() public menuElement[] getSubElements() JCheckBoxMenuItem, JMenuItem sÄ±nÄ±fÄ±nÄ±n bir alt sÄ±nÄ±fÄ± olarak oluÅturulmuÅtur. DavranÄ±ÅÄ± JCheckBox sÄ±nÄ±fÄ± gibidir. Kurucu metodlarÄ± public JCheckBoxMenuItem() public JCheckBoxMenuItem(Icon resim) public JCheckBoxMenuItem(String Label) public JCheckBoxMenuItem(String Label,Icon resim) public JCheckBoxMenuItem(String Label,Boolean seÃ§ildimi) public JCheckBoxMenuItem(String Label,Icon resim, Boolean seÃ§ildimi) JRadioButtonMenuItem' da JMenuItem'Ä±n alt sÄ±nÄ±fÄ± olarak oluÅturulmuÅtur. Kurucu metodlarÄ± public JRadioButtonMenuItem () public JRadioButtonMenuItem (Icon resim) public JRadioButtonMenuItem (String Label) public JRadioButtonMenuItem (String Label,Icon resim) Åimdi bu metodlarÄ± kullanan bir Ã¶rnek menu oluÅturalÄ±m. Ãrnek menu sadece menu yapÄ±sÄ±nÄ± gÃ¶stermek amaÃ§lÄ± olduÄundan fazla bir eyem yamamaktadÄ±r. GerÃ§ek programlarÄ±nÄ±zda gerekli eylemleri yereÅtirebilirsiniz. * import java.awt.event. * import javax.swing.JMenu import javax.swing.JMenuItem import javax.swing.JCheckBoxMenuItem import javax.swing.JRadioButtonMenuItem import javax.swing.ButtonGroup import javax.swing.JMenuBar import javax.swing.KeyStroke import javax.swing.ImageIcon import javax.swing.JTextArea import javax.swing.JScrollPane import javax.swing.JFrame /* * Menu Demo */ public class MenuDemo extends JFrame implements ActionListener, ItemListener { JTextArea output JScrollPane scrollPane String newline = \n public MenuDemo() { JMenuBar menuBar JMenu menu, submenu JMenuItem menuItem JRadioButtonMenuItem rbMenuItem JCheckBoxMenuItem cbMenuItem addWindowListener(new BasicWindowMonitor()) //Add regular components to the window, using the default BorderLayout. menuBar = new JMenuBar() setJMenuBar(menuBar) //Build the first menu. menu = new JMenu( Ä°knci bir Menu ) menu.setMnemonic('n') menu.getAccessibleContext().setAccessibleDescription( Bu menu hiÃ§ bir Åey yapmaz ve alt elemanÄ± yoktur ) menuBar.add(menu) } public void actionPerformed(ActionEvent e) { JMenuItem source = (JMenuItem)(e.getSource()) String s = Action event kaydedildi + newline + Event kaynaÄÄ± + source.getText() + (sÄ±nÄ±fÄ±n adÄ± + getClassName(source) + ) output.append(s + newline) } public void itemStateChanged(ItemEvent e) { JMenuItem source = (JMenuItem)(e.getSource()) String s = Item event kaydedildi. seÃ§ildi seÃ§im iptal edildi ) output.append(s + newline) } // SÄ±nÄ±fÄ±n adÄ±nÄ± verir protected String getClassName(Object o) { String classString = o.getClass().getName() int dotIndex = classString.lastIndexOf( . ) return classString.substring(dotIndex+1) } public static void main(String[] args) { MenuDemo window = new MenuDemo() window.setTitle( MenuDemo ) window.setSize(450, 260) window.setVisible(true) } } * import java.awt. * import yildizSW import java.awt.geom. * import renk public class ovalPanelSWP extends JPanel { int xi,yi,yaricap public ovalPanelSWP(int xi1, int yi1,int yaricap1) { xi=xi1 yi=yi1 yaricap=(yaricap1 >= 0 . yaricap1 10) } public void setOvalPanelSWP(int xi1, int yi1,int yaricap1) { xi=xi1 yi=yi1 yaricap=(yaricap1 >= 0 . * // java swing sinifini cagir import java.awt. * // java pencere kullanma sinifini cagir import java.awt.event. * // java pencereyi dinleme sinifini cagir import BasicWindowMonitor import ovalPanelSWP import javax.swing.event. Daire JPanel sÄ±nÄ±fÄ±nda Ã§izilmiÅtir. Daireyi Ã§izmek iÃ§in ovalPanelSWP sÄ±nÄ±fÄ±nÄ± yarattÄ±k. JPanel sÄ±nÄ±fÄ±nda kurucu metodlarÄ±mÄ±zÄ± herhangi bir sÄ±nÄ±fta olduÄu gibi tanÄ±mladÄ±k ve public void paintComponent(Graphics g) metodu ve Graphics sÄ±nÄ±fÄ± Ã¼zerinden Ã§izimimizi tanÄ±mladÄ±k. Tekrar Ã§izdirmek iÃ§in repaint() metodunu kullandÄ±k. Ä°kinci JFrame proramÄ±mÄ±zda StateChanged event metodundaki p.setOvalPanelSWP(30, 30,cap.getValue()) komutuyla da Ã§apÄ±nÄ± deÄiÅtirip repaint() komutuyla tekrar Ã§izdirdik. awt grafik interface'inde default deÄer olarak kullanÄ±lan Layout sÄ±nÄ±fÄ± FlowLayout sÄ±nÄ±fÄ±dÄ±r. Swing arayÃ¼z programlarÄ±nda ise BorderLayout sÄ±nÄ±fÄ± default olarak kullanÄ±lar. Flow layout sÄ±nÄ±fÄ± grafik ortamÄ±na (Panel, Applet, Frame, Jpanel, Japplet, JFrame vs.) alt elemanlarÄ± yerleÅtirirken soldan saÄa doÄru akleme (add) sÄ±rasÄ±yla yerleÅtirir. Penceredeki yer bittiyse bir alt satÄ±ra geÃ§er. Bu deÄerlere gÃ¶re iÃ§erdiÄi elemanlarÄ± saÄa ortaya veya sola yerleÅtirir. Yatay_bosluk pixel olarak yatay posisyonda elemanlar arasÄ±nda kalan boslugu gosterir. Dikey bosluk ise dikey dogrultudaki pixel olarak boÅluktur. KÃ¼Ã§uk bir Ã¶rnek problemle FlowLayout kullanÄ±mÄ±nÄ± daha aÃ§Ä±k hale getirebiliriz. * import java.awt.event. * public class FlowLayoutTesti extends Applet implements ActionListener { private Button B[] public void init() { B=new Button[3] B[0]=new Button( Sol ) B[1]=new Button( Orta ) B[2]=new Button( Sag ) for(int i=0 i<B.length i++) * import java.awt. * import java.awt.event. Bu sÄ±nÄ±f swing grafik kÃ¼tÃ¼phanesinde default formatlama sÄ±nÄ±fÄ± olarak seÃ§ilmiÅtir. BorderLayout sÄ±nÄ±fÄ±nÄ±n kurucu metotlarÄ± ÅunlardÄ±r public BorderLayout() public BorderLayout(int yatay_bosluk,int dikey_bosluk) yatay_bosluk ve dikey_basluk pixel olarak alÄ±nÄ±r. GUI elemanlarÄ±nÄ±n arasÄ±ndaki bosluk miktarÄ±nÄ± tanÄ±mlar. Åimdi bir Ã¶rnekle sÄ±nÄ±fÄ± aÃ§Ä±klamaya Ã§alÄ±ÅalÄ±m. * import java.awt.event. * import java.awt. * import java.awt.event. GridLayout sÄ±nÄ±fÄ±nÄ±n kurucu metotlarÄ± ÅÃ¶yledir public GridLayout(int satÄ±rlar,int sÃ¼tunlar) publicGridLayout(int satÄ±rlar,int sÃ¼tunlar,int yatay_bosluk,int dikey_bosluk) yatay_bosluk ve dikey_basluk pixel olarak alÄ±nÄ±r. GUI elemanlarÄ±nÄ±n arasÄ±ndaki bosluk miktarÄ±nÄ± tanÄ±mlar. Åimdi bir Ã¶rneklerle bu sÄ±nÄ±fÄ± aÃ§Ä±klamaya Ã§alÄ±ÅalÄ±m. * import java.awt.event. * import java.awt. * import java.awt.event. } public void actionPerformed(ActionEvent e) { for(int i=0 i<B.length i++) { if(e.getSource()==B[i]) B[i].setVisible(false) else B[i].setVisible(true) } c.validate() } public static void main(String[] args) { GridLayoutTestiSWF_2000 pencere= new GridLayoutTestiSWF_2000() pencere.addWindowListener(new BasicWindowMonitor()) pencere.setSize(400,200) pencere.setVisible(true) } } DeÄiÅik sayfalar halinde bir grafik arayÃ¼zÃ¼ Ã§aÄÄ±rÄ±r. Bu sayfalardan istenilen seÃ§ilerek kullanÄ±labilir. Her sayfa baÄÄ±msÄ±z bir grafik ortamÄ± oluÅturur. * import java.awt. * import java.awt.event. * public class JTabbedPaneTestiSWF_2000 extends JFrame implements ActionListener { private JButton B[] private String S[]={ DÃ¼Äme 1 , DÃ¼Äme 2 , DÃ¼Äme 3 , DÃ¼Äme 4 , DÃ¼Äme 5 , DÃ¼Äme 6 } private Container c public JTabbedPaneTestiSWF_2000() { super( JTabbedPane formatlama Grafik ara yÃ¼z (GUI) testi ) c=getContentPane() c.setLayout(new BorderLayout(5,5)) B=new JButton[6] JTabbedPane jtp=new JTabbedPane() for(int i=0 i<B.length i++) { B[i]=new JButton(S[i]) B[i].addActionListener(this) jtp.addTab(S[i],B[i]) } c.add(jtp) } public void actionPerformed(ActionEvent e) { for(int i=0 i<B.length i++) { if(e.getSource()==B[i]) B[i].setText(S[i]+ dÃ¼Ämeye basÄ±ldÄ± ) else B[i].setText(S[i]) } c.validate() } public static void main(String[] args) { JTabbedPaneTestiSWF_2000 pencere= new JTabbedPaneTestiSWF_2000() pencere.addWindowListener(new BasicWindowMonitor()) pencere.setSize(400,200) pencere.setVisible(true) } } Bu ikiye bÃ¶lme iÅlemlerini yineleyerek istediÄimiz alt parÃ§alarÄ± oluÅturabiliriz. JSplitPane ile bÃ¶lÃ¼nen alt parÃ§alar fare ile Ã§ekilerek bÃ¼yÃ¼tÃ¼lÃ¼p kÃ¼Ã§Ã¼ltÃ¼lebilir. BÃ¶ylece birbirinden baÄÄ±msÄ±z dÃ¶rt ayrÄ± alt parÃ§a (split) oluÅturuyoruz. * import java.awt. * import java.awt.event. public void actionPerformed(ActionEvent e) { for(int i=0 i<B.length i++) { if(e.getSource()==B[i]) B[i].setText(S[i]+ dÃ¼Ämeye basÄ±ldÄ± ) else B[i].setText(S[i]) } c.validate() } public static void main(String[] args) { JSplitPaneTestiSWF_2000 pencere= new JSplitPaneTestiSWF_2000() pencere.addWindowListener(new BasicWindowMonitor()) pencere.setSize(400,200) pencere.setVisible(true) } } Bu formatlama sÄ±nÄ±fÄ± Scrollbar adÄ±nÄ± verdiÄimiz yatay ve dÃ¼Åey kaydÄ±rma Ã§ubuklarÄ± yardÄ±mÄ±yla kÃ¼Ã§Ã¼k bir pencereye sÄ±Ämayacak kadar bÃ¼yÃ¼kolan grafiklerin kullanÄ±lmasÄ±nÄ± saÄlar. * import java.awt. * import java.awt.event. } c.validate() } public static void main(String[] args) { JScrollPaneTestiSWF_2000 pencere= new JScrollPaneTestiSWF_2000() pencere.addWindowListener(new BasicWindowMonitor()) pencere.setSize(400,200) pencere.setVisible(true) } } Panel sÄ±nÄ±fÄ± applete yerleÅtirebileceÄimiz alt bolgeler oluÅturur. Hemen bir ornekle paneli nasÄ±l kulandÄ±ÄÄ±mÄ±zÄ± aÃ§Ä±klamaya Ã§alÄ±ÅalÄ±m. * import java.awt.event. JPanel'i formatlama iÅleminde aynÄ± Panel sÄ±nÄ±fÄ±nda olduÄu gibi bir alt formatlama elemanÄ± olarak kullanabiliriz. Zaten bÃ¼tÃ¼n swing programlarÄ±nÄ±n temeli de JPanel sÄ±nÄ±fÄ±dÄ±r. Swing gurubunda bir Ã¼stteki problemin aynÄ±sÄ±nÄ± JApplet olarak yineledik. Awt penceresi ve swing penceresi arasÄ±ndaki en Ã¶nemli farkÄ±n awt de add terimini appletin bir alt terimi gibi kullanabilirken, swingde getContentPane() deyimiyle ana JPanel'i Ã§aÄÄ±rmak ve Ã§izimleri bunun Ã¼zerine yapmak olduÄunu bir kere daha yineleyelim. * import java.awt. * import java.awt.event. * import java.applet.Applet import java.awt.event. * import javax.swing. * import java.awt.event. Java swing gurubunda aynÄ± zamanda kullanÄ±lmaya hazÄ±r bir Ã§ok grafik arayÃ¼zleri tanÄ±mlanmÄ±ÅtÄ±r. BunlarÄ±n en Ã§ok kullanÄ±lanÄ±, ve bu kitapta da Åu ana kadar yoÄun olarak kullanageldiÄimiz JOPtionPane sÄ±nÄ±fÄ±dÄ±r. Bu sÄ±nÄ±fÄ±n ana gayesi pop-up mesaj ve girdi ortamÄ± saÄlamaktÄ±r. JoptionPane sÄ±nÄ±fÄ±nÄ± programÄ±mÄ±zda kurucu metod kullanarak kurmamÄ±z gerekmez. Temel olarak direk statik metodlarÄ±nÄ± Ã§aÄÄ±rÄ±rÄ±z. JoptionPane panelinde genellikle bir resim,bir yazÄ± alanÄ±, bir girdi alanÄ± (JtextField alanÄ±), birde SeÃ§ilebilen dÃ¼Ämeler bulunur. JoptionPane'in girdi/Ã§Ä±ktÄ± olarak kullanÄ±labilen baÅlÄ±ca metodlarÄ± ÅunlardÄ±r public static String showInputDialog(Object mesaj) public static String showInputDialog(Component anapencere,Object mesaj) public static String showInputDialog(Component anapencere,Object mesaj,String baÅlÄ±k,int mesajtÃ¼rÃ¼) public static String showInputDialog(Component anapencere,Object mesaj,String baÅlÄ±k,int mesajtÃ¼rÃ¼, Icon resim, Object[] listeseÃ§medeÄerleri, Object giriÅdeÄeri) public static String showInternalInputDialog(Component anapencere,Object mesaj) public static String showInternalInputDialog(Component anapencere,Object mesaj, String baÅlÄ±k,int mesajtÃ¼rÃ¼) public static String showInternalInputDialog(Component anapencere,Object mesaj,String baÅlÄ±k,int mesajtÃ¼rÃ¼, Icon resim, Object[] listeseÃ§me deÄerleri,, Object giriÅdeÄeri) public static void showMessageDialog(Component anapencere,Object mesaj) public static void showMessageDialog(Component anapencere,Object mesaj,String baÅlÄ±k,int mesajtÃ¼rÃ¼) public static void showMessageDialog(Component anapencere,Object mesaj,String baÅlÄ±k,int mesajtÃ¼rÃ¼, Icon resim) public static void showInternalMessageDialog(Component anapencere,Object mesaj) public static void showInternalMessageDialog(Component anapencere,Object mesaj,String baÅlÄ±k,int mesajtÃ¼rÃ¼) public static void showInternalMessageDialog(Component anapencere,Object mesaj,String baÅlÄ±k,int mesajtÃ¼rÃ¼, Icon resim) public static int showConfirmDialog(Component anapencere,Object mesaj) public static int showConfirmDialog(Component anapencere,Object mesaj,String baÅlÄ±k,int mesajtÃ¼rÃ¼) * import java.awt. Renk seÃ§meye yarar ve renk seÃ§ilmesi gereken her yerde kullanÄ±labilir. Bir Ã¶nceki bÃ¶lÃ¼mdeki bir alÄ±ÅtÄ±rmada bu Ã¶zelliÄi kullanmÄ±ÅtÄ±k. * import java.awt.event. * import javax.swing. * import javax.swing.event. * import javax.swing.colorchooser. * public class ColorChooserDemo extends JFrame { public ColorChooserDemo() { super( ColorChooser Renk seÃ§ici ) //Pencerenin tepesinde bir JLabel aÃ§alÄ±m final JLabel etiket = new JLabel( Java Programlama diline HoÅ geldiniz. Bilgisayardan bir dosyayÄ± seÃ§me ileminde yararlanÄ±lÄ±r. Dosya prosesleri konusunda Java Girdi Ã§Ä±ktÄ± programlanmasÄ± bÃ¶lÃ¼mÃ¼ne bakÄ±nÄ±z. * import java.awt. * import java.awt.event. * import javax.swing. * import javax.swing.filechooser. log.append( Dosya aÃ§Ä±lÄ±yor + file.getName() + . + newline) } else { log.append( DosyanÄ±n aÃ§Ä±lmasÄ± kullanÄ±cÄ± tarafÄ±ndan iptal edildi. //gerÃ§ek dosyanÄ±n kaydedilme yeri.. log.append( Kaydediliyor + file.getName() + . + newline) } else { log.append( DosyanÄ±n kaydedilmesi kullanÄ±cÄ± tarafÄ±ndan iptal edildi + newline) } } }) //GÃ¼zel bir gÃ¶rÃ¼nÃ¼m iÃ§in aÃ§ ve kapa dÃ¼Ämelerini ayrÄ± bir panele yerleÅtir. JAR teknolojisi peogramlarÄ±n taÅÄ±nmasÄ±nÄ± ve yeniden yÃ¼klenmesini daha kolay bir hale getirir. jar dosyasÄ±nÄ±n iÃ§indeki dosyalara bakmak iÃ§in jar tf isim.jar jar dosyasÄ± iÃ§indeki dosyalarÄ±n listesini almak iÃ§in jar xf isim.jar jar dosyasÄ±nÄ± applet iÃ§inden Ã§alÄ±ÅtÄ±rmak iÃ§in html iÃ§inde <applet code=AppletClassIsmi.class archive= JarDosyasiIsmi.jar width=width height=height </applet komutu kullanÄ±lÄ±r. Ãrnek olarak yine alÄ±ÅtÄ±rma 5 de kullanÄ±lan jar dosyasÄ±nÄ±n html dosyasÄ±nÄ± verebiliriz. eÄer listede sadece bir isim varsa bunu jar dosyasÄ± olarak alÄ±r ve iÃ§indeki tÃ¼m dosyalarÄ± listeler, eÄer ilk simden sonra komutta baÅka isimler yer alÄ±yorsa, sadece bu isimleri (eÄer jarda mevcutsa) listeler. 0 sÄ±kÄ±ÅtÄ±rma kullanma Veri akÄ±ÅÄ±nÄ± bir su akÄ±ÅÄ± veya bir kablolu sistem Ã¼zerinden bilgi akÄ±ÅÄ± gibi dÃ¼ÅÃ¼nebiliriz. Javada sadece dosya deÄil yazÄ±cÄ±, scanner gibi herhangi bir kaynaÄa veri iletmek istediÄimizde bu veri akÄ±Å sistemini kullanÄ±rÄ±z. Javada oldukÃ§a geniÅ bir veri akÄ±Å kÃ¼tÃ¼phanesi bulunmaktadÄ±r. java.io kÃ¼tÃ¼phanesinde yer alan girdi Ã§Ä±ktÄ± programlama sÄ±nÄ±flarÄ± ÅunlardÄ±r InputStream FilterInputStream LineNumberInputStream BufferedInputStream DataInputStream PushbackInputStream ByteArrayInputStream FileInputStream ObjectInputStream PipedInputStream SequenceInputStream StringBufferInputStream OutputStram ByteArrayOutputStream FileOutputStream FilterOutputStream BufferedOutputStream DataOutputStream PrintStream ObjectOutputStream PipedOutputStream ObjectStreamClass StreamTokenizer Reader FileReader BufferedReader LineNumberReader CharArrayReader FilterReader PushbackReader InputStreamReader FileReader PipedReader StringReader Writer BufferedWriter CharArrayWriter FilterWriter OutputStreamWriter PipedWriter PrintWriter StringWriter File FileDescriptor RandomAccessFile Bu sÄ±nÄ±flarÄ±n hepsinin genel gÃ¶revi javaya girdi saÄlamak ve Ã§Ä±ktÄ± almaktÄ±r. Burada bunlardan bir kÄ±smÄ±nÄ±n iÅlevlerini ve nasÄ±l Ã§alÄ±ÅtÄ±klarÄ±nÄ± inceleyeceÄiz. Ãnce temel ana sÄ±nÄ±flarÄ±n bazÄ±larÄ±nÄ±n tanÄ±mlarÄ±na daha detaylÄ± bakalÄ±m. InputStream sÄ±nÄ±fÄ± byte tÃ¼rÃ¼ yazÄ± okuma sÄ±nÄ±fÄ±dÄ±r. TÃ¼m byte tÃ¼rÃ¼ bilgi akÄ±Å kanalÄ± sÄ±nÄ±flarÄ±nÄ±n ana sÄ±nÄ±fÄ±dÄ±r. TanÄ±mÄ± public abstract class InputStream extends Object { public InputStream() public int available() throws IOException public void close() throws IOException public synchronized void mark(int readlimit) public boolean markSupported() public abstract int read() throws IOException public int read(byte b[]) throws IOException public int read(byte b[],int off,int len) throws IOException public synchronized void reset() throws IOException public long skip(long n) throws IOException } InputStream sÄ±nÄ±fÄ±nÄ±n byte tÃ¼rÃ¼ yazma pareleli olan OutputStream sÄ±nÄ±fÄ±nÄ±n tanÄ±mÄ± ise public abstract class OutputStream extends Object { public outputStream() public void close() throws IOException public void flush() throws IOException public abstract void write(int b) throws IOException public void write(byte b[]) throws IOException public void write(byte b[],int baÅlamanoktasÄ±,int uzunluk) throws IOException } Abstract sÄ±nÄ±f Reader, InputStream sÄ±nÄ±fÄ±na olduÃ§a yakÄ±ndÄ±r, yalnÄ±z data transferinde byte yerine char kullanÄ±r, bÃ¶ylece girdi Ã§Ä±ktÄ±da unicode stream kullanabilme olasÄ±lÄ±ÄÄ± yakalar. public abstract class Reader extends Object { protected Reader() protected Reader(Object o) public abstract void close() throws IOException public void mark(int readlimit) throws IOException public boolean markSupported() public abstract int read() throws IOException public int read(char c[]) throws IOException public int read(char c[],int baÅlamanoktasÄ±,int uzunluk) throws IOException public boolean ready() throws IOException public void reset() throws IOException public long skip(long n) throws IOException } Abstract sÄ±nÄ±f Writer da Output straem sÄ±nÄ±fÄ±na eÅdeÄerdir. Fakat aynÄ± readerda olduÄu gibi bu sÄ±nÄ±f da veri akÄ±ÅÄ±nda char ve string kullanÄ±r. public abstract class Writer extends Object { public outputStream() public void close() throws IOException public void flush() throws IOException public abstract void write(int b) throws IOException public void write(char c[]) throws IOException public void write(char c[],int baÅlamanoktasÄ±,int uzunluk) throws IOException public void write(String s) throws IOException public void write(String s,int baÅlamanoktasÄ±,int uzunluk) throws IOException } Bu sÄ±nÄ±flar temel sÄ±nÄ±flardÄ±r. BunlarÄ±n altÄ±nda yer alan Ã§eÅitli sÄ±nÄ±flara aÅaÄÄ±daki bÃ¶lÃ¼mlerde daha detaylÄ± bakacaÄÄ±z. File sÄ±nÄ±fÄ±nÄ±n tanÄ±mÄ± Public class File extends Object implements Serializable, Comparable { public static final String pathSeperator public static final char pathSeperatorChar public static final String seperator public static final char seperatorChar public File(String dosya_ismi) public File(String dizin_ismi, String dosya_ismi) public File(File file_tipi_nesne,String dosya_ismi) File sÄ±nÄ±fÄ±nda tanÄ±mlanmÄ±Å olan Metotlardan bazÄ±larÄ±nÄ±n tanÄ±mlarÄ± ÅunlardÄ±r. canRead() TanÄ±mlanan dosyadan bilgi okunulabilirliÄini test eder. canWrite() TanÄ±mlanan dosyaya bilgi yazÄ±labilirliÄini test eder. delete() DosyayÄ± siler equals(Object) Dosya ismini Object te verilen dosya ismiyle karÅÄ±laÅtÄ±rÄ±r. exists() DosyanÄ±n mevcut olup olmadÄ±ÄÄ±nÄ± kontrol eder. getAbsolutePath() DosyanÄ±n tam dizin ismini ve dosya ismini verir( co/java/prog/Hosgeldiniz.java). getName() DosyanÄ±n ismini verir. (Hosgeldiniz.java) getParent() DosyanÄ±n iÃ§inde bulunduÄu dizinin ismini verir. (prog) getPath() dosyanÄ±n ismini ve iÃ§inde bulunduÄu dizinin ismini verir. (prog/Hosgeldiniz.java) isAbsolute() Dosya isminin mutlak isim olup olmadÄ±ÄÄ±nÄ± kontrol eder. (EÄer dosya ismi co/java/prog/Hosgeldiniz.java olarak verilmiÅse true deÄeri verir.) isDirectory() verilen isimin bir dizin ismi olup olmadÄ±ÄÄ±nÄ± kontrol eder. isFile() verilen isimin