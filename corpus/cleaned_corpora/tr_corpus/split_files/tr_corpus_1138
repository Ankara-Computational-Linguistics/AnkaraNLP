of integration (integral) // and differentiation (derivative) functions // Dr. Turhan Coban // ===================================================== import java.io. * > Terminated with exit code 0. Oluşan Romberg tablosunu verirsek 3 Çıktı 7.2-2 Romberg integrali I   2 dx tablo değerleri 1  2x 2 3 6.3157895 8.2105263 4.2488038 3.5598086 3.2497608 3.8058295 3.6581714 3.664729 3.6713158 3.7866756 3.7802909 3.7884322 3.7903958 3.7908628 3.7877768 3.7881439 3.7886674 3.7886711 3.7886644 3.7886622 3.7880687 3.788166 3.7881675 3.7881596 3.7881576 3.7881571 3.7881569 3.7881417 3.7881661 3.7881661 3.7881661 3.7881661 3.7881661 3.7881661 3.7881661 3.78816 3.7881661 3.7881661 3.7881661 3.7881661 3.7881661 3.7881661 3.7881661 3.7881661  Şimdi de I   sin( x)dx  2 integralini Romberg integral formülü kullanarak çözelim 0  Çıktı 7.2-3 Romberg integrali I   sin( x)dx  2 0 ---------- Capture Output ---------> C \co\java\bin\java.exe integ7A integral of class f1 1.9999999999999993  Çıktı 7.2-4 Romberg integrali I   sin( x)dx  2 tablo değerleri 0 1.5707963267948900 2.0943951023931900 1.8961188979370300 2.0045597549844200 1.9985707318238300 1.9742316019455500 2.0002691699483800 1.9999831309459800 2.0000055499796700 1.9935703437723300 2.0000165910479300 1.9999997524545700 2.0000000162880400 1.9999999945872900 1.9983933609701400 2.0000010333694100 1.9999999961908400 2.0000000000596700 1.9999999999960300 2.0000000000013200 1.9995983886400300 2.0000000645300000 1.9999999999407000 2.0000000000002200 1.9999999999999900 1.9999999999999900 1.9999999999999900 1.9998996001842000 2.0000000040322500 1.9999999999990700 2.0000000000000000 2.0000000000000000 2.0000000000000000 2.0000000000000000 2.0000000000000000 1.9999749002350500 2.0000000002520000 1.9999999999999800 1.9999999999999900 1.9999999999999900 1.9999999999999900 1.9999999999999900 1.9999999999999900 Diğer bir interpolasyon formülü de Aitken interpolasyon formülüdür. Temel olarak Euler-McLaurin formülünden türetilen Aitken interpolasyon formülü şeklindedir. Program 7.2-2 Aitken interpolasyonlu simpson integrali //====================================================== // Numerical Analysis package in java // example to show utilisation of integration (integral) // and differentiation (derivative) functions // Dr. Turhan Coban // ===================================================== import java.io. * class f1 extends f_x { double func(double x) {return x*Math.sqrt(x) } } class integ11 { public static double newton_cotes3(f_x ff,double a,double b, int n) { Şekil 7.3-1 polinom ile eşdeğer alana sahip doğru problemi Eğer doğrunun polinomu alt ve üst tarafta eşit alan bırakacak şekilde kestiği x1 ve x2 noktaları bilinir ise integral yerini bir toplama işlemi alabilir. Genel tanım olarak n I w (1,1)  1 f ( x) w( x)dx   ck f ( xk ) 1 k 1 şeklinde yazabiliriz. Burada w(x) ağırlık fonksiyonudur. Gauss-Legendre integral formülü için değerini 1 olarak alabiliriz. n I w (1,1)  1 f ( x)dx   ck f ( xk ) 1 k 1 integrali genel polinom için çözersek k 1 x dx  1 1  (1) k 1 k 1 c1 x1k  c2 x2k  .... cn xnk  2 olur. Bu denklemi yukarıdaki integral denklemi için açık yazarsak 1  (1) k 1 , k 1 0  k  2n olur. Grafikte gösterilen n=2 durumu için 3 f(x)=a0+a1x+a2x +a3x 1 1 1 1 1 1 1 1 1 1 3 2 3 1 Programin genel çözümü Legendre polinomları ile tanımlanabilir. Burada P0(x)=1 ve P1(x)=x olarak tanımlanmıştır. Legendre polinomunun kökleri Gauss integral denkleminin de köklerini verir. Kök değerleri bulunduktan sonra katsayılar c1 x12 j  c2 x22 j  .... cn xn2 j  0  j  n formülünden hesaplanabilir. veya ck  2(1  xk2 ) ifadesinden katsayıyı hesaplayabiliriz. [nPn1 ( xk )]2 Son olarak burada integral sınırlarının -1 ile 1 aralığında olmasına dikkati çekelim. x=[-1,1] aralığı z=[a,b] aralığına değişken dönüşümü ile rahatlıkla çevrilebilir. ba ba z  x     x  2   2  ba ba        2   2  bu durumda integral formülü I w ( a, b)   b a n f ( z )dx    ck f ( xk   ) k 1 formunu alır. Gauss-Legendre integral formulünün katsayıları ve kök değerleri n=2 den n=10 a kadar Tablo 7.31 de verilmiştir. Tablo 7.3-1 Gauss – Legendre integral katsayıları N xk ck 2 -0.577350269189625 1.000000000000000 3 4 5 6 7 8 9 10 0.577350269189625 1.000000000000000 -0.774596669241483 0.555555555555552 0.000000000000000 0.888888888888888 0.774596669241483 0.555555555555552 -0.861136311594052 0.347854845137447 -0.339981043584856 0.652145154862546 0.339981043584856 0.652145154862546 0.861136311594052 0.347854845137447 -0.906179845938664 0.236926885056181 -0.538469310105683 0.478628670499366 0.000000000000000 0.568888888888888 0.538469310105683 0.478628670499366 0.906179845938664 0.236926885056181 -0.932469514203152 0.171324492379162 -0.661209386466264 0.360761573048138 -0.238619186083196 0.467913934572691 0.238619186083196 0.467913934572691 0.661209386466264 0.360761573048138 0.932469514203152 0.171324492379162 -0.949107912342758 0.129484966168862 -0.741531185599394 0.279705391489276 -0.405845151377397 0.381830050505119 0.000000000000000 0.417959183673469 0.405845151377397 0.381830050505119 0.741531185599394 0.279705391489276 0.949107912342758 0.129484966168862 -0.960289856497536 0.101228536290369 -0.796666477413626 0.222381034453374 -0.525532409916329 0.313706645877887 -0.183434642495649 0.362683783378362 0.183434642495649 0.362683783378362 0.525532409916329 0.313706645877887 0.796666477413626 0.222381034453374 0.960289856497536 0.101228536290369 -0.968160239507626 0.081274388361569 -0.836031107326635 0.180648160694857 -0.613371432700590 0.260610696402935 -0.324253423403808 0.312347077040002 0.000000000000000 0.330239355001259 0.324253423403808 0.312347077040002 0.613371432700590 0.260610696402935 0.836031107326635 0.180648160694857 0.968160239507626 0.081274388361569 -0.973906528517171 0.066671344308684 -0.865063366688984 0.149451349150580 -0.679409568299024 0.219086362515982 -0.433395394129247 0.269266719309996 -0.148874338981631 0.295524224714752 0.148874338981631 0.295524224714752 0.433395394129247 0.269266719309996 0.679409568299024 0.219086362515982 0.865063366688984 0.149451349150580 0.973906528517171 0.066671344308684 Bu bölümdeki ilk programımız Gauss-Legendre integral denkleminin toplam 10 katsayı için olan bir formunu kullanmaktadır. Program 7.3-1 10 noktalı Gauss-Legendre integrasyonu /====================================================== // Numerical Analysis package in java // example to show utilisation of integration (integral) // and differentiation (derivative) functions // Dr. Turhan Coban // ===================================================== import java.io. * Çıktı 7.3-1 10 noktalı Gauss-Legendre integrasyonu ---------- Capture Output ---------> C \co\java\bin\javaw.exe integ8 integral of class f1 0.3999993424028001 > Terminated with exit code 0. İkinci programımızda ise katsayılar Legendre polinomları kullanılarak hesaplanmaktadır. Bu ikinci programımızda yer alan gauss_legendre_coefficiens metodunu kullanarak istediğimiz büyüklükteki gausslegendre integral katsayılarını da elde edebiliriz. Program 7.3-2 değişken nokta sayılı Gauss-Legendre integrasyonu //====================================================== // Numerical Analysis package in java // example to show utilisation of integration (integral) // and differentiation (derivative) functions // Dr. Turhan Coban // ===================================================== import java.io. * class f1 extends f_x { public double func(double x) { return x*Math.sqrt(x) } } Çıktı 7.3-2 değişken nokta sayılı Gauss-Legendre integrasyonu (toplam 50 nokta için, tam çözüm 0.4) ---------- Capture Output ---------> C \co\java\bin\javaw.exe integ9 integral 0.39999999974904343 Gauss-Legendre formülünde , genel integral formülündeki n I w (1,1)  1 f ( x) w( x)dx   ck f ( xk ) 1 k 1 w(x) ağırlık fonksiyonunu 1 olarak almıştık. Şimdi de ağırlık fonksiyonunun birden farklı olduğu bazı formüllere göz atalım. Gauss-Chebychev formülünde ağırlık fonksiyonu w( x)  1 1  x2 I w (1,1)  1  1 şeklinde tanımlanmıştır. Bu durumda integral formülü f ( x) w( x)dx  1  1 n 1 1  x2 f ( x)dx   ck f ( xk ) formunu alır. k 1 Buradaki xk değerleri sabit olarak değişmez, Chebychev polinomlarının kökleridir. Bu polinomun kökleri ise Formülümüzdeki ck katsayıları ise xk  cos n ck   n Gauss-Chebychev formülünde de. x=[-1,1] aralığı z=[a,b] aralığına değişken dönüşümü ile rahatlıkla çevrilebilir. 1 Örnek problem olarak I 1 ex (1  x ) 2 dx integralini çözelim Program 7.3-3 değişken nokta sayılı Gauss-Chebychev integrasyonu import java.util. * import java.awt. * import javax.swing. * import java.awt.event. Çıktı 7.3-3 değişken nokta sayılı Gauss-Chebychev integrasyonu ---------- Capture Output ---------> C \co\java\bin\javaw.exe integ_gauss_chebychev integral 3.9774632605064237 > Terminated with exit code 0. Gauss-Jacobi (Mehler ) formülü I w (1,1)  1  1 f ( x) w( x)dx  1  1 n 1 (1  x) (1  x)  f ( x)dx   ck f ( xk ) k 0 formundadır. Bu denklemde xk Jacobi polinomlarının kökleridir. Jacobi polinomları n Buradaki katsayılar i 0 An  1 (n    1)(n    1) şeklinde tanımlanır. 2n (n      1) Denklemin katsayıları ise ck   (2n      2)(n    1)(n    1) 2   şeklinde tanımlanır. (n      1)(n      1)(n  1). Buradaki gamma fonksiyonudur. Denklemin iki özel haline dikkatinizi çekelim. =0 ve =0 Gauss-Legendre formülünü verir. . =-0.5 ve =-0.5 Gauss-Chebychev formülünü verir. Görüldüğü gibi Gauss-Jacobi denklemi çok daha genel bir form oluşturur. Örnek problemimizde bir önceki problemde kullandığımız 1 I 1 dx integralini tekrar Gauss-legendre seti katsayılarını kullanarak çözelim. Program 7.3-4 değişken nokta sayılı Gauss-Jacobi integrasyonu =0 ve =0 import java.util. * import java.awt. * import javax.swing. * import java.awt.event. * class f1 extends f_x { public double func(double x) { return Math.exp(x)/Math.sqrt(1-x*x) } } public class integ_gauss_jacobi { public static double [] lngamma(double x) {//logaritmik hata fonksiyonu //xx[0] hata fonksiyonunun logaritmasının değerini //xx[1] hata fonksiyonunun kendisinin işaretini verir double xx[]=new double[2] double result double a double b double c double p double q double u double w double z int i double logpi double ls2pi double tmp double sgngam = 1 logpi = 1.14472988584940017414 ls2pi = 0.91893853320467274178 if( x<-34.0 ) { q = -x double yy[]=lngamma(q) w = yy[0] tmp=yy[1] p = Math.floor(q) i = (int)Math.round(p) if( i%2==0 ) { sgngam = -1 } else { sgngam = 1 } z = q-p if( z>0.5 ) public static double gauss_jacobi_integral(f_x f_xnt,int n,double alpha,double beta) { //n number of integral coefficients // this routine first generates gauss legendre coefficients // for [x1,x2] band // then calculates gauss hermite integral double a[][]=new double[2][n] a=gauss_jacobi_coefficients(n,alpha,beta) System.out.println(Matrix.toString(a)) double z=0 for(int i=0 i<n i++) { z+=a[1][i]*f_xnt.func(a[0][i]) } return z Çıktı 7.3-4 5 nokta sayılı Gauss-Jacobi integrasyonu ---------- Capture Output ---------> C \co\java\bin\javaw.exe integ_gauss_jacobi 0.906179845938664 0.538469310105683 0.236926885056189 0.478628670499367 0.000000000000000 0.568888888888889 -0.538469310105683 0.478628670499367 -0.906179845938664 0.236926885056189 3.4865363609790476 > Terminated with exit code 0. Görüldüğü gibi burada Gauss_legendre katsayılarını doğru olarak elde ettik,yalnız sadece 5 katsayı aldığımızdan integral doğruluğunu tam sağlayamadık. Katsayıyı artırarak çözersek 5 nokta sayılı Gauss-Jacobi integrasyonu =0 ve =0 Çıktı 7.3-4 ---------- Capture Output ---------> C \co\java\bin\javaw.exe integ_gauss_jacobi n=20 integral = 3.8463361175531756 > Terminated with exit code 0. 50 nokta sayılı Gauss-Jacobi integrasyonu =0 ve =0 Çıktı 7.3-5 ---------- Capture Output ---------> C \co\java\bin\javaw.exe integ_gauss_jacobi n=50 integral = 3.9242400049441444 > Terminated with exit code 0. 100 nokta sayılı Gauss-Jacobi integrasyonu =0 ve =0 Çıktı 7.3-6 ---------- Capture Output ---------> C \co\java\bin\javaw.exe integ_gauss_jacobi n=100 integral = 3.9506992376105177 > Terminated with exit code 0. Fonksiyonu değiştirerek =-0.5 ve =-0.5 (Gauss-Chebychev formülü) için çözersek Program 7.3-4 (değiştirilmiş form) değişken nokta sayılı Gauss-Jacobi integrasyonu =-0.5 ve =-0.5 class f1 extends f_x { public double func(double x) { return Math.exp(x) } } ……… System.out.println( n= +n+ integral = +gauss_jacobi_integral(b1,n,-0.5,-0.5)) ……… =-0.5 ve =-0.5 (Gauss-Chebychev formülü) için çözersek Çıktı 7.3-7 10 nokta sayılı Gauss-Jacobi integrasyonu =-0.5 ve =-0.5 ---------- Capture Output ---------> C \co\java\bin\javaw.exe integ_gauss_jacobi n=10 integral = 3.97746265002148 > Terminated with exit code 0. Görüldüğü gibi Gauss-Jacobi integral formülü çok daha genel bir format oluşturmaktadır. Gauss-Hermit formülü w( x)  e x 2 I w ( , )     f ( x) w( x)dx     n1 c k 0 k f ( xk ) formundadır. Bu denklemde xk Hermit polinomlarının kökleridir. Katsayılar, 2 n1 n.  formülünden hesaplanabilir. Tablo 7.3-2 Gauss – Hermit integral katsayıları N xk ck 2 +/-0.707167811 0.886226926 3 0 1.181635901 +/- 1.224744871391589 0.295408975 +/- 0.524647623275290 0.80491409 +/- 1.650680123885784 0.081312835 0 0.945308721 +/-0.9585724646 0.393619323 +/-2.0201828705 0.019953242 +/- 2.350604973674492 0.00453001 +/- 1.335849074013697 0.15706732 +/- 0.436077411927616 0.724629595 +/- 2.651961356835233 0.000971781 +/- 1.673551628767471 0.054515583 +/- 0.816287882858965 0.425607253 0 0.810264618 4 5 6 7 Bir örnek programla Gauss_Hermite integral denkleminin örneğini verelim Program 7.3-5 Gauss-Hermite integrasyonu İmport java.util. * import java.awt. * import javax.swing. * import java.awt.event. Çıktı 7.3-8 Gauss-Hermite integrasyonu ---------- Capture Output ---------> C \co\java\bin\java.exe integ_gauss_hermite integral 2.9965945890817665 > Terminated with exit code 0. Gauss-Laguerre formülü w( x)  x e x I w (0, )    0 f ( x) w( x)dx    0  x n1 c k 0 k f ( xk ) formundadır. Bu denklemde xk Laguerre polinomlarının kökleridir. Katsayılar, 1 formülünden hesaplanabilir. İlk 5 açılım için katsayı değerleri tablo 7.4-3(=0), tablo 7.4dPn ( xk ) 2 xk [ ] dxk ck  4(=1) ve tablo 7.4-5(=2) verilmiştir. Gauss-Laguerre integral formülünde =0 için integral alt şartını değiştirebiliriz. Bu durumda denklem I w (a, )    a f ( x) w( x)dx    a n1 e ( xa ) f ( x  a)dx  e a  ck f ( xk  a) k 0 halini alır. Tablo 7.3-3 2 Gauss – Laquerre integral katsayıları (=0) 0.585786437626905 0.853553390592534 3.414213562373090 0.146446609406723 0.415774556783479 0.711093009915089 2.294280360279040 0.278517733568676 6.289945082937470 0.010389256497354 0.322547689619392 0.603154104288259 1.745761101158340 0.357418692437802 4.536620296921120 0.038887908507759 9.395070912301130 0.000539294705556 0.263560319718141 0.521755610467045 1.413403059106510 0.398666821407258 3.596425771040720 0.075942449681708 7.085810005858830 0.003611758663878 12.640800844275700 0.000023369972386 3 4 5 Tablo 7.3-4 Gauss – Laquerre integral katsayıları (=1) N xk ck 2 1.267949192431120 0.788675133123411 4.732050807568870 0.211324865405185 0.935822227524088 0.588681472855445 3.305407289332270 0.391216059222280 7.758770483143630 0.020102459732679 0.743291927981432 0.446870579513482 2.571635007646270 0.477635774492073 5.731178751689090 0.074177784726293 3 4 5 10.953894312683100 0.001315849683447 0.617030853278271 0.348014523429866 2.112965958578520 0.502280674138866 4.610833151017530 0.140915919102187 8.399066971204840 0.008719893025972 Tablo 7.3-5 Gauss – Laquerre integral katsayıları (=2) N xk ck 2 2.000000000000000 1.500000000000000 6.000000000000000 0.500000000000000 1.517387080677410 1.037494961490390 4.311583133719520 0.905750004703039 9.171029785603060 0.056755033772202 1.226763263500300 0.725524997698604 3.412507358696940 1.063424292391060 3 4 5 6.902692605851610 0.206696130999709 12.458036771951100 0.004354579188558 1.031109144093380 0.520917396835042 2.837212823953820 1.066705933159050 5.620294272598700 0.383549720007093 9.682909837664020 0.028564233510280 15.828473921690000 0.000262712802303 Gauss-Laguerre integral formülünü bir program ve örnek problemle görelim.  x dx e  1 0 I  x integralinin türevini hesaplayacağız. İntegralin değeri I= 0.822467 dir. Program 7.3-6 Gauss-Laguerre integrasyonu İmport java.util. * import java.awt. * import javax.swing. * import java.awt.event. * class f1 extends f_x { public double func(double x) { return x/(Math.exp(x)+1.0) } } public class integ_gauss_laguerre { public static double [] lngamma(double x) {//logaritmik hata fonksiyonu //xx[0] hata fonksiyonunun logaritmasının değerini //xx[1] hata fonksiyonunun kendisinin işaretini verir double xx[]=new double[2] double result double a double b double c double p double q double u double w double z int i double logpi Çıktı 7.3-9 Gauss-Laguerre integrasyonu ---------- Capture Output ---------> C \co\java\bin\javaw.exe integ_gauss_laguerre integral 0.8224670275951408 tam = 0.822467 > Terminated with exit code 0. İntegrali alınabilecel bir gerçek fonksiyon için integral b I   f ( x)dx a şeklinde yazılabilir. Eğer integral için bir alt bölge tanımlarsak, örneğin integralimizi iki alt integrale bölerek tanımlıyabiliriz. m ( a  b) tanımını yaparsak, 2 m b a m I   f ( x)dx   f ( x)dx Bu durumda genel bir kavram olarak hata miktarının azalacağını söyleyebiliriz. Aynı işlemi her integrali de alt integrallere bölerek de sürdürmemiz mümkündür. Burada önemli olam kavram integral hata limiti belli bir değerin altına indiğinde prosesi durdurmaktır. Bu altbölümümüzde ayarlanabilir hata miktarlı çeşitli integral yaklaşımlarını inceleyeceğiz. h5 f ( 4 ) ( d1 ) denklemdeki hata miktarını verir. hata denklemindeki f(4) fonksiyonun 4. türevidir. 90 Şimdi integrali hesapladığımız bölgeyi iki alt bölgeye bölelim. Bu durumda denklem x2 x4 x0 x2  f ( x)dx   f ( x)dx  I ( x0 , x2 )  I ( x2 , x4 )  halini alacaktır. d2 değeri yine a ile b arasında bir değerdir. Eğer f ( 4) (d1 )  f ( 4) (d 2 ) kabul edersek f ( 4 ) (d1 ) 16  [ I ( x0 , x2 )  I ( x2 , x4 )  I ( x0 , x4 )] olur. Bu denklemi integral denklemine koyarsak x4  f ( x)dx  I ( x0 , x2 )  I ( x2 , x4 )  x0 1 I ( x0 , x2 )  I ( x2 , x4 )  I ( x0 , x4 ) 15 Eğer bu şart gerçekleşiyorsa x4  f ( x)dx  I ( x0 , x2 )  I ( x2 , x4 ) yazılabilir. Eğer bu şart gerçekleşmiyorsa, integrasyon bölgesi ikiye x0 bölünerek her bölge tekrar kontrol edilir, bölme işlemi istenilen hata şartı gerçekleşene kadar devam ederiz. * class f1 extends f_x { double func(double x) {return x*Math.sqrt(x) } } Aynı programın grafik üzerinde hesaplama noktalarını gösteren bir versiyonunu daha verelim. } Buradaki temel fikir Gauss Legendre polinom formülünün katsayılarını birer birer arttırmak ve iki katsayı arasındaki hata miktarı istenilen düzeyin altına indiğinde iterasyon prosesini durdurmaktan ibarettir. Program 7.4-2 Ayarlanabilir hata miktarlı Gauss-Legendre integrasyonu ///====================================================== // Numerical Analysis package in java // example to show utilisation of integration (integral) // and differentiation (derivative) functions // Dr. Turhan Coban // ===================================================== import java.io. * class f1 extends f_x { public double func(double x) {return x*Math.sqrt(x) } } Çıktı 7.4-2 Ayarlanabilir hata miktarlı Gauss-Legendre integrasyonu ---------- Capture Output ---------> C \co\java\bin\java.exe integ13 integral 0.3999999999829868 > Terminated with exit code 0. I w (1,1)  1  1 f ( x)dx  n n 1 k 1 k 1 Gauss-Kronrod integrasyon formülü integral hesabında iki toplama terimi kullanır, Birinci terim standart gauss formülünden oluşur. İkinci terimde ise katsayılar gauss katsayılarının aynı olarak alınır, ancak kök değerleri değişiktir. Örnek problemimizde sabit kök değerleri kullanacağız n = 15 için (+ ve – değerlerle 30 terim) programımız ilk terim olarak Gauss-Legendre terimini, ikinci terim olarak Kronroad terimini kullanmaktadır. Hassasiyeti artırmak için her iterasyondan sonra iterasyon bölgesi yarıya bölünerek iterasyolara devam edilir. Gauss-Kronrod integral formülü günümüzde bir çok modern sayısal analiz paketi tarafından tercih edilen integrasyon yöntemi olarak kullanılmaktadır. } } Bu tür döngüden çıkış prosesi her integralde başarılı olmıyabilir. Bu durumda genelde maksimum iterasyon sayısına ulaşıldığında döngüden bir uyarı mesajı vererek çıkılabilir. integral of class f1 0.6666663569478286 > Terminated with exit code 0. Sonuç Maksimum iterasyon sayısına ulaşıldı mesajını verecektir. Hata miktarını daha azaltmak hatta çalıştığımız makinenin hata sınırına ulaştırmak istersek daha değişik bir kontrol sistemi kullanabiliriz. Önce farklı kaba bir integral değeri olarak is değerini bulduğumuzu varsayalım. if(is+(I1-I2)==is) gibi bir yaklaşım kullanırsak bu yaklaşım ancak I1 ve I2 sonuçları makine hassaslığında birbirine eşit olduğunda çıkış verecektir. Bu yaklaşımı m ( a  b) 2 tanımı için ek bir sınır değer kontrolu ile daha da iyi çalışacak bir forma getirebiliriz [a,b] integral bölgesi için if( (is+(I1-I2)==is) || (m<=a) || (b<=m) ) bize çok daha garantili bir çıkış kriteri oluşturabilir. Şimdi bu kavramı kullanan bir ayarlanabilir Simpson integral formülüne bakalım. is ilk kaba integral değeri için sekizinci derece polinom formülü n=8, 9 noktalı Newton-Cotes formülünü kullanacağız. (b  a) [989 f ( x0 )  5888 f ( x1 )  928 f ( x2 )  10496 f ( x3 )  4540 f ( x4 ) 28350  10496 f ( x5 )  928 f ( x6 )  5888 f ( x7 )  989 f ( x8 )] b is   f ( x)dx  a m b a m Program kodu Program 7.4-4 de verilmiştir. * class f1 extends f_x { double func(double x) {return Math.sin(x) } } I   sin( x)dx  2 0 I w (1,1)  1  1 f ( x)dx  n1 c k 0 k f ( xk ) Çeşitli n değerleri için integral formülünün kök ve katsayı değerleri Tablo 7.4-1 de verilmiştir. 5 -1.00000000000000000000000 1.00000000000000000000000 -0.65465367070797700000000 0.65465367070797700000000 0.00000000000000000000000 0.10000000000000000000000 0.10000000000000000000000 0.54444444444444400000000 0.54444444444444400000000 0.71111111111111100000000 6 -1.00000000000000000000000 1.00000000000000000000000 -0.76505532392946500000000 0.76505532392946500000000 -0.28523151648063500000000 0.28523151648063500000000 0.06666666666666660000000 0.06666666666666660000000 0.37847495629784700000000 0.37847495629784700000000 0.55485837703548600000000 0.55485837703548600000000 7 -1.00000000000000000000000 1.00000000000000000000000 -0.81649658092772600000000 0.81649658092772600000000 -0.44721359549995800000000 -0.44721359549995800000000 0.00000000000000000000000 0.05238095238095240000000 0.05238095238095240000000 0.29387755102040800000000 0.29387755102040800000000 0.42517006802721100000000 0.42517006802721100000000 0.45714285714285700000000 12 -1.00000000000000000000000 1.00000000000000000000000 -0.94288241569547900000000 0.94288241569547900000000 -0.81649658092772600000000 0.81649658092772600000000 -0.64185334234578100000000 0.64185334234578100000000 -0.44721359549995800000000 0.44721359549995800000000 -0.23638319966214900000000 0.23638319966214900000000 0.00000000000000000000000 0.01582719197348010000000 0.01582719197348010000000 0.09427384021885000000000 0.09427384021885000000000 0.15507198733658500000000 0.15507198733658500000000 0.18882157396018200000000 0.18882157396018200000000 0.19977340522685800000000 0.19977340522685800000000 0.22492646533333900000000 0.22492646533333900000000 0.24261107190140700000000 Bu ayarlanabilir integral programında da Gander ve Gautschi[31] yaklaşımı yaklaşımını kullanarak döngü sonlandırması yapacağız. [a,b] integral bölgesi için if( ( is+( I1 - I2 ) == is ) || (m<=a) || (b<=m) ) şartını kullanacağız. Buradaki m değeri daha önce de belirttiğimiz gibi m is  ( a  b) 2  b a şeklindedir. . is ilk kaba integral değeri için 12. derece Lobato integral formülünü kullanacağız. f ( x)dx  (b  a ) * {0.0158271919734801* [f(a)  f(b)]  iterasyon integrasyon formülleri olarak ta 4. ve 7. derece Gauss-Lobatto açılımlarından yararlanacağız. I1   b a f ( x)dx  (b  a) *{0.166666666666667 * [f(a)  f(b)]   b a f ( x)dx  (b  a) *{0.0523809523809524 * [f(a)  f(b)]  Program 7.4-5 Gander ve Gautschi hata Ayarlanabilir Gauss-Lobatto integral formülü //====================================================== // Numerical Analysis package in java // example to show utilisation of integration (integral) // and differentiation (derivative) functions // Dr. Turhan Coban // ===================================================== import java.io. Isı transferi ve diğer çözümlerde kulanılan hata fonksiyonun(erf) temel tanımı erf ( )  1   e  2 d formülüyle yapılır ancak bu integral hesaplanması çok zor olan bir integral olduğundan 0 genelde bu formül seri çözümlerle hesaplanır. Örnek programımızda seri çözüm ve Gauss-Lobatto integralinden hesaplanmaktadır. Program 7.4-6 Gauss-Lobatto integral formülü ile erf fonksiyonun hesaplanması //====================================================== // Numerical Analysis package in java // error function calculation by using // Adaptive Gauss-Lobatto integral and serial solution // Referans Adapted Quadrature - Revisited // Walter Gander - Walter Gautchi // ftp.inf.ethz.ch // Dr. Turhan Coban // ===================================================== import java.io. * import javax.swing. Çıktı 7.4-6 Gauss-Lobatto integral formülü ile erf fonksiyonun hesaplanması erf(0.1) = 0.1124629159993309 integral erf=0.1124629160182849 erf(0.4) = 0.4283923519241598 integral erf=0.42839235504666845 erf(1.0) = 0.8427007900291826 integral erf=0.8427007929497149 erf(2.0) = 0.995322264754383 integral erf=0.9953222650189527 Bu transformasyon gerçekleştirildiğinde -1,1 aralığında integral denklemi formunu alır. Bir fonksiyonun cos serisine açılma denklemi şeklindedir. Bu açılım yapıldığında, seri üzerinden integral açılımını kolaylıkla gerçekleştirebiliriz. buradaki katsayılar denkleminden hesaplanabilir. Bu denklemi seriye açacak olursak, katsayıları hesaplamak için denklemini elde ederiz. Bu denklemi kullanarak üstteki formülden integral değerini hesaplayabiliriz. Program 7.5-1 Clenshaw-Curtis integrasyonu ///====================================================== // Numerical Analysis package in java // example to show utilisation of integration (integral) // and differentiation (derivative) functions // Dr. Turhan Coban // ===================================================== import java.io. * Çıktı 7.5-1 Clenshaw-Curtis integrasyonu ---------- Capture Output ---------> C \co\java\bin\javaw.exe integ12 integral 0.40015015740404086 > Terminated with exit code 0. b  f ( x)dx  (b  a) * f ortalama a x  a  (b  a) * tesadüfi _ sayı(0,1) n  f ( x) f ortalama  i0 n , n  1 a ve b arasında tesadüfi bir x noktası bularak fonksiyonu bu noktada değerlendiririz. Bu işlemi çok yüksek sayılar için tekrarladığımızda toplamın toplam sayıya bölümü ortalama fonksiyon değerini verecektir. Bu değerin bölge genişliğine çarpımı integrali verir. Denklemden ve programlardan görüldüğü gibi bu yöntem çok fazla sayıda fonksiyon değerlendirilmesini gerektirir. Bu yüzden birinci dereceden integraller için pek pratik bir formül değildir. Ancak katlı integrallerde, oldukça pratik hale gelir. Program 7.6-1 tek değişkenli Monte-carlo integrasyonu //====================================================== // Numerical Analysis package in java // example to show utilisation of integration (integral) // and differentiation (derivative) functions // Dr. Turhan Coban // ===================================================== import java.io. Çıktı 7.6-1 tek değişkenli Monte-carlo integrasyonu ---------- Capture Output ---------> C \co\java\bin\java.exe integ_monte_carlo integral of class f1 0.9990028422107341 > Terminated with exit code 0. İki değişkenli integral için monte karlo denklemlerini yazarsak x  ax  (bx  ax) * tesadüfi _ sayı(0,1) y  ay  (by  ay) * tesadüfi _ sayı(0,1) n f ortalama  i0 n , n  1 integralin alt alanı by bx ( x )  ( D)    dy dx ay ax ( x ) I   ( D) f ortalama halini alır, görüldüğü gibi iki değişkenli monte-carlo integrali bir değişkenli örneği ile hemen hemen aynı işlemlerle gerçekleştirilmektedir. Bu da n boyutlu integrale geçtiğimizde bu metodu cazip kılan önemli bir avantaj sağlar. Program 7.6-2 iki değişkenli Monte-carlo integrasyonu //====================================================== // Numerical Analysis package in java // example to show utilisation of integration (integral) // and differentiation (derivative) functions // Dr. Turhan Coban // ===================================================== import java.io. Çıktı 7.6-2 iki değişkenli Monte-carlo integrasyonu ---------- Capture Output ---------> C \co\java\bin\java.exe integ_monte_carlo2 integral of class f1 3.9945397938584297 > Terminated with exit code 0. I(D)   D f ( x, y)dydx D nin xy düzleminde bir bölge olduğunu varsayalım. Bu bölgeyi a  x  b ve olarak tanımlıyalım. İki boyutlu integrali hesaplamanın bir yolu iki stepte hesap yapmaktır. Birinci stepte g(x) fonksiyonunu hesaplarız. d ( x)  f ( x, y)dy, g(x)  a xb c( x) ikinci stepte g(x) fonksiyonunu kullanarak tam integrali hesaplarız. b I(D)   g ( x)dx a Gauss-legendre integrasyon formülü çok katlı integrallerin hesaplanması içinde kullanılabilir. Burada yapmamız gereken temel işlem integrali iç içe iki kere değerlendirmekten ibarettir. Örnek olarak 2 boyutlu Gauss-Legendre integrasyonunu problem 7.7-1 ve 7.7-2 de veriyoruz. İlk programımızda katsayılar sabit verilmiştir. İkinci programımızda Legendre polinomları üzerinden katsayılar hesaplanmaktadır. b d ( x) I   f ( x, y)dydx a c( x) iki boyutlu(değişkenli) integralde x boyutu sınırları yine bir boyutlu integral gibi iki nokta olarak verilirken , yboyutu sınırları x'in fonksiyonu olarak tanımlanabilir. Bu durumda x integral sınırları a ve b ve y integral sınırları c(x) ve y(x) bilinmelidir. Bu sınırlar temel olarak değişken fonksiyonlar olduklarından programımızda fonksiyon olarak tanımlanmışlardır. Gauss Legendre integralinde aynı zamanda değişkenleri de dönüştürmemiz gerekir. b d ( x) a c( x) I   buradaki rn,j kök değerleri, cn,j katsayılardır. Bu değerler Legendre polinomlarından hesaplanırlar. Program 7.7-1 60 sabit noktalı 2 değişkenli Gauss-Legendre integrasyonu //====================================================== // Numerical Analysis package in java // gauss integration of two dimensional function // and differentiation (derivative) functions // Dr. Turhan Coban // ===================================================== import java.io. f1 +I(ff)) } } Çıktı 7.7-1 60 sabit noktalı 2 değişkenli Gauss-Legendre integrasyonu ---------- Capture Output ---------> C \co\java\bin\javaw.exe integ_gauss2 integral of class f1 0.429554527548266 > Terminated with exit code 0. Yukardaki problem 60 noktalı sabit katsayılar üzerinden tanımlanmıştır, aynı programı değişken nokta sayısı üzerinden, katsayılar program tarafından hesaplanacak şekilde de yazabiliriz. Program 7.7-2 2 boyutlu değişken integrasyon sabit sayılı Gauss-Legendre integrasyonu //====================================================== // Numerical Analysis package in java // gauss integration of two dimensional function // and differentiation (derivative) functions // Dr. Turhan Coban // ===================================================== import java.io. Çıktı 7.7-2 2 boyutlu Gauss-Legendre integrasyonu ---------- Capture Output ---------> C \co\java\bin\javaw.exe integ_gauss3 integral of class f1 0.4295545275482747 > Terminated with exit code 0. İki değişkenli integrasyon için Newton-cotes (simpson) formüllerinden de yararlanabiliriz. I  a f ( x)dx  b şeklinde idi. Aynı formülü kompozit olarak yazarsak (alt parçalara ayrılmış şekilde) yazacak olursak b I   f ( x)dx  a Bu denklemi Gauss   2j 3 j 1 j 1  Legendre 2 boyutlu integralinde olduğu gibi bu formülü de 2 boyuta açabiliriz. b d ( x) I   f ( x, y)dydx a c( x) k formunu alır. Buradan dış integrale geçebiliriz. b d I   a c aynı denklem ikinci kere dış integrale uygulanarak iki boyutlu integral çözülmüş olur. Fonksiyon olarak GaussLegendre örneğinde aldığımız aynı fonksiyon alınmıştır. Program 7.7-3 iki boyutlu simpson integrasyonu //====================================================== // Numerical Analysis package in java // simpson integration of two dimensional function // and differentiation (derivative) functions // Dr. Turhan Coban // ===================================================== import java.io. public static void main(String args[]) throws IOException { f1 +I(ff,20,20)) } } Çıktı 7.7-3 iki boyutlu simpson integrasyonu ---------- Capture Output ---------> C \co\java\bin\javaw.exe integ_simpson integral of class f1 0.4295545273061155 > Terminated with exit code 0. Şimdi de aynı prensibi üç boyutlu integraller için kullanalım. I   şeklinde verilebilir. Burada çözüm metodu olarak Gauss-Legendre integrali kullanacağız. İlk örnek integral olarak 11 y integralini çözelim Program 7.7-4 üç boyutlu Gauss-Legendre integrasyonu //====================================================== // Numerical Analysis package in java // gauss integration of three dimensional function // and differentiation (derivative) functions // Dr. Turhan Coban // ===================================================== import java.io. ---------- Capture Output ---------> C \co\java\bin\java.exe integ_3D İntegral=0.08333333333333286 > Terminated with exit code 0. Bu yaklaşımlardan birincisi veriye bir eğri uydurmak ve uydurulan eğrinin integralini almak, diğeri de veri noktalarına örneği Newton-Cotes integral formülleri gibi bir yaklaşımla direk olarak verilen noktaları kullanarak integral hesaplamak olabilir. Ancak Newton cotes integral formülünde belli nokta sayısı olması gerektiğiden eğer bu gerçekleşiyorsa birden fazla formülü beraber kullanmamız gerekebilir. Eğri uydurma metoduna örnek olarak kübik şerit interpolasyonlu eğri uydurma formüllü integral hesaplamaya göz atalım. Eğer kübik polinomumuz sk(x)=ak(x-xk)+ bk(xk+1-x)+ [(x-xk)3 ck+1 +(xk+1-x)3 ck]/(6hk) 1 k  n şeklinde verilmiş ise, bu polinomu kullanarak eğri uydurma (katsayıları hesaplama) prosesi eğri uydurma bölümümüzde tanımlanmıştı. Bu formülün integralini alacak olursak b b a x a a, xn , xn1 ,...,b bö lg eleri için şerit interpolasyon formülleri kısmi devamlı formül olduğundan aynı kısmi devamlılığı integral işleminde kullanmamız gerekir. Bu yaklaşımın kullanıldığı örnek program aşağıda verilmiştir. programda kullanılan veri f(x)=x2 fonksiyonundan türetilmiştir. Program 7.8-1 Kübik şerit interpolasyon formülü kullanan direk veri integrasyonu İmport java.io. * import javax.swing. * class SCO11FB { public static double [] thomas(double a[][],double r[]) { // int n=a.length double f[]=new double[n] double e[]=new double[n] double g[]=new double[n] double x[]=new double[n] for(int i=0 i<n i++) {f[i]=a[i][i] } for(int i=0 i<(n-1) i++) {g[i]=a[i][i+1] } for(int i=0 i<(n-1) i++) {e[i+1]=a[i+1][i] } for(int k=1 k<n k++) {e[k]=e[k]/f[k-1] f[k]=f[k]-e[k]*g[k-1] } for(int k=1 k<n k++) {r[k]=r[k]-e[k]*r[k-1] } x[n-1]=r[n-1]/f[n-1] for(int k=(n-2) k>=0 k--) {x[k]=(r[k]-g[k]*x[k+1])/f[k] } return x } public static double [] thomas(double f[],double e[],double g[],double r[]) { int n=f.length double x[]=new double[n] for(int k=1 k<n k++) {e[k]=e[k]/f[k-1] f[k]=f[k]-e[k]*g[k-1] } for(int k=1 k<n k++) {r[k]=r[k]-e[k]*r[k-1] } x[n-1]=r[n-1]/f[n-1] for(int k=(n-2) k>=0 k--) {x[k]=(r[k]-g[k]*x[k+1])/f[k] } return x } {S[0][k]=(6. Çıktı 7.8-1 Kübik şerit interpolasyon formülü kullanan direk veri integrasyonu ---------- Capture Output ---------> C \co\java\bin\java.exe SCO11FB s=333.3333333333334 > Terminated with exit code 0. Kübik şerit interpolasyonu kullandığımızda dikkat etmemiz gereken bir husus da uç noktalarda ikinci türev değerlerini bilme zorunluluğudur. Bu değerler yanlış tahmin edildiğinde ve integral iki uç noktaya kadar tüm veri bölgesini kapsadığında yanlış ikinci türev değerleri belli bir hatanın oluşmasına sebep olacaktır. Örneğin test fonksiyonumuzdaki veri f(x)=x2 fonksiyonundan türetilmişti. Bu yüzden f''(x)=2 (sabit) ikinci türevin alması gereken değerdir. Bu degerle integrali aldığımızda, kübik polinom üçüncü derece polinomu tam olarak integre edebildiği için tam sonuç aldık. Şimdi uç şartları olarak f''(x)=0 değeri (doğal kübik şerit) alarak aynı işlemi yapalım. Verimiz 0-10 bölgesini kapsamaktaydı integral sınirları olarak da 0-10 bölgesini alırsak bu durumda sonuç Çıktı 7.8-2 Kübik şerit interpolasyon formülü kullanan direk veri integrasyonu, kübik şerit sınır şarları f''(0)=0 ve f''(10)=0 olarak alınmış, veri 0 dan 10 a kadar. ---------- Capture Output ---------> C \co\java\bin\java.exe SCO11FB s=333.3334295583782 > Terminated with exit code 0. Görüldüğü gibi sonuçta hata payında belli bir artma oldu, ancak sonuç yine de oldukça iyi. Bu hata payını uç noktalarda ek veri alarak integre ettiğimiz bölgeden uzaklaştırarak azaltabiliriz. ---------- Capture Output ---------> C \co\java\bin\java.exe SCO11FB s=333.33333148216684 > Terminated with exit code 0. Şimdi de Newton_cotes integral yaklaşımı kullanan bir örnek verelim.Yukarda da değindiğimiz gibi Newton_Cotes yaklaşımında eğri formülü elde etme zorunluluğu olmadan integrali direk olarak alabiliriz. Program 7.8-2 9. derece polinom yaklaşımlı(n=8) Newton-Cotes integral formülü kullanan direk veri integrasyonu //====================================================== // Numerical Analysis package in java // example to show utilisation of integration (integral) // and differentiation (derivative) functions // Dr. Turhan Coban // ===================================================== import java.io. Çıktı 7.8-4 9. derece polinom yaklaşımlı(n=8) Newton-Cotes integral formülü kullanan direk veri integrasyonu ---------- Capture Output ---------> C \co\java\bin\java.exe integData s=333.33333333333337 > Terminated with exit code 0. Newton-Cotes yaklaşımında eğri uydurma olmadığından (fonksiyon değerleri direk olarak verilerden alındığından) veri bölgesi ve integral bölgesi aynı olmak zorundadır. Elimizde daha fazla veri olduğunda sadece integral alacağımız bölgenin verisini alarak geri kalan veriyi silmemiz gerekir, veya daha düşük bir Newtoncotes yaklaşımıyla geri kalan bölgenin integrali alınabilir. Fark denklemleri temel olarak Taylor formülü açılımlarını kullanır. 4. 4. bulunur. Veya f ( xi 1 )  f ( xi ) f ' ( xi )   O(h) h O(h) terimi hata miktarını bildirmektedir. Hata h ile orantılıdır. Yani h küçüldükçe hata h ile orantilı olarak küçülecektir. 2h Fark denklemlerini ileriye doğru veya geriye doğru oluşturabiliriz. Geriye doğru fark denklemini f ( xi )  f ( xi 1 ) f ' ( xi )   O(h) şeklinde yazabiliriz. İleri ve geriye doğru fark denklemlerinden merkezi fark h denklemini oluşturabiliriz. i+3 i+2 -0.500000 İ+1 i 1.000000 -1.000000 ileri 2.000000 -1.500000 ileri 1.000000 -1.000000 1.500000 -2.000000 0.500000 1.000000 1.000000 -1.500000 7.000000 f' f' f' f' -0.166667 0.666667 1.000000 -2.000000 1.000000 -0.666667 4.000000 -5.000000 2.000000 i-4 geri geri merkezi 0.083333 merkezi ileri ileri -2.000000 1.000000 2.000000 -5.000000 4.000000 -0.500000 1.333333 geri -1.000000 geri 0.250000 merkezi -0.083333 merkezi -0.083333 1.333333 -2.500000 -3.000000 12.000000 3.000000 -1.000000 ileri 9.000000 -2.500000 ileri 1.000000 -3.000000 3.000000 -1.000000 2.500000 -9.000000 12.000000 -7.000000 0.500000 -1.000000 0.000000 -1.000000 -0.500000 2.000000 6.500000 9.333333 -6.500000 2.000000 //====================================================== // Numerical Analysis package in java // example to show utilisation of integration (integral) // and differentiation (derivative) functions // Dr. Turhan Coban // ===================================================== import java.io. * class dif1 i-3 0.500000 1.000000 Tablo 7.9-1 Türev (fark denklemleri kullanılması) i-2 0.500000 -0.083333 0.250000 i-1 geri 1.500000 geri merkezi 0.166667 merkezi System.out.println( turev dfdx +dfdx_richardson(b1,1.0)) } } Burada h2, h1 den küçük olmalıdır. Aynı formülü türev için yazacak olursak 3 3 D 4 1 D(h2 )  D(h1 )] 3 3 İnterpolasyon başlangıcı için türev yaklaşımlarından birisi kullanılabilir. İteratif formülümüz genel olarak yazılırsa haline gelir. Bu yaklaşımlardan birincisi veriye bir eğri uydurmak ve uydurulan eğrinin türevini almak, diğeri de veri noktalarına tablo 7.9-1 Türev fark denklemleri gibi bir yaklaşımla direk olarak verilen noktaları kullanarak türev hesaplamak olabilir. Önce fonksiyon tanımlama prosesinde interpolasyon formüllerini kullanabiliriz. Örneğin İkinci derece Lagrange interpolasyonu kullanırsak Fonksiyon f 2 ( x)  ( x  xi )( x  xi 1 ) ( x  xi 1 )( x  xi 1 ) ( x  xi 1 )( x  xi ) f ( xi 1 )  f ( xi )  f ( xi 1 ) ( xi 1  xi )( xi 1  xi 1 ) ( xi  xi 1 )( xi  xi 1 ) ( xi 1  xi 1 )( xi 1  xi ) türev fonksiyonu ise f 2' ( x)  (2 x  xi  xi 1 ) (2 x  xi 1  xi 1 ) (2 x  xi 1  xi ) f ( xi 1 )  f ( xi )  f ( xi 1 ) ( xi 1  xi )( xi 1  xi 1 ) ( xi  xi 1 )( xi  xi 1 ) ( xi 1  xi 1 )( xi 1  xi ) formunu alır. Bu formulasyonu başka dereceler ve başka interpolasyon formülleri kullanarak ta uygulayabiliriz. Fonksiyon tanımlama (eğri uydurma) metodlarına diğer bir örnek olarak kübik şerit interpolasyonlu eğri uydurma formüllü türev hesaplamaya göz atalım. Eğer kübik polinomumuz sk(x)=ak(x-xk)+ bk(xk+1-x)+ [(x-xk)3 ck+1 +(xk+1-x)3 ck]/(6hk) 1 k  n şeklinde verilmiş ise, bu polinomu kullanarak eğri uydurma (katsayıları hesaplama) prosesi eğri uydurma bölümümüzde tanımlanmıştı. Bu formülün türevini alacak olursak s'k(x)=ak- bk+ [(x-xk)2 ck+1 -(xk+1-x)2 ck]/(2hk) 1 k  n şeklini alır. Şerit interpolasyon formülleri kısmi devamlı formül olduğundan aynı kısmi devamlılığı türev işleminde de kullanmamız gerekir. Bu yaklaşımın kullanıldığı örnek program aşağıda verilmiştir. programda kullanılan veri f(x)=x2 fonksiyonundan türetilmiştir. Program 7.9-2 Şerit interpolasyon formülü kullanan Türev programı import java.io. * import javax.swing. * class SCO11FA { public static double [] thomas(double a[][],double r[]) { // int n=a.length double f[]=new double[n] double e[]=new double[n] double g[]=new double[n] double x[]=new double[n] for(int i=0 i<n i++) {f[i]=a[i][i] } for(int i=0 i<(n-1) i++) {g[i]=a[i][i+1] } for(int i=0 i<(n-1) i++) {e[i+1]=a[i+1][i] } for(int k=1 k<n k++) {e[k]=e[k]/f[k-1] f[k]=f[k]-e[k]*g[k-1] } for(int k=1 k<n k++) {r[k]=r[k]-e[k]*r[k-1] } x[n-1]=r[n-1]/f[n-1] for(int k=(n-2) k>=0 k--) {x[k]=(r[k]-g[k]*x[k+1])/f[k] } return x } public static double [] thomas(double f[],double e[],double g[],double r[]) { int n=f.length double x[]=new double[n] for(int k=1 k<n k++) {e[k]=e[k]/f[k-1] f[k]=f[k]-e[k]*g[k-1] } for(int k=1 k<n k++) {r[k]=r[k]-e[k]*r[k-1] } x[n-1]=r[n-1]/f[n-1] for(int k=(n-2) k>=0 k--) {x[k]=(r[k]-g[k]*x[k+1])/f[k] } return x } public static double [][] cubic_spline(double xi[],double yi[],double c0,double cn) { // c0 ilk noktadai ikinci türev // cn son oktadaki ikici türev int n=xi.length double h[]=new double[n] double w[]=new double[n] double f[]=new double[n] double e[]=new double[n] double g[]=new double[n] double d[]=new double[n] double x[]=new double[n] double S[][]=new double[4][n] int k for(k=0 k<(n-1) k++) {h[k]=xi[k+1]-xi[k] w[k]=(yi[k+1]-yi[k])/h[k] } d[0]=c0 x0 0.774596669241483 c1 0.888888888888889 x1 0.000000000000000 c2 0.555555555555553 x2 0.774596669241483 2  1  2x 2 dx integralini n=2 adım büyüklüğü için Bole kuralı kullanarak çözünüz 3 f 0   c1 T dx c  x 0 5   x exp( 2 )  1 x    fonksiyonu radyasyon ısı değişiminde siyah cisim radyasyon fonksiyonu olarak bilinir. Gauss-Legendre integral formülünü kullanarak verilen bir T değeri için siyah cisim radyasyon faktörünü hesaplayacak bir metod yazınız. T nin 5000 ile sonsuz arasındaki değerleri için bir tablo oluşturunuz. dy dx 2 x0 y 0 (1  y ) 1 1 I   integralini a) monte-carlo metodu kullanarak çözünüz. I  integralinin a) tam değerini analitik metod kullanarak çözünüz. b) Trapez kuralı ile n=2 için çözünüz (iki alt parçaya ayırınız). Yüzde hatayı hesaplayınız. c) Trapez kuralı ile n=4 için çözünüz (dört alt parçaya ayırınız). Yüzde hatayı hesaplayınız. 1 x 0 1 x I  2 dx integralini Gauss-Legendre integrali ile hesaplayınız.  1  f ( x)  ln  2  1 x  a) b) c) d) fonksiyonunu göze alınız bu fonksiyonun x=1 noktasındaki analitik türevini hesaplayınız. 3 noktalı merkezi fark denklemi ve h=0.1 için türev değerini hesaplayınız 3 noktalı merkezi fark denklemi ve h=0.05 için türev değerini hesaplayınız Richardson interpolasyonu h1=0.5 ve h2=0.05 kullanarak türev değerini hesaplayınız f ( x)   x. exp( x) dx 1 fonksiyonunu göze alınız fonksiyonunu göze alınız e) Trapez integrali f) boole integrali g) Gauss_legendre integrali h) Romberg inregrali integrali Denklemlerini kullanarak integralini hesaplayınız. f ( x)   1 dx fonksiyonunu göze alınız X f(x) Bu veriyle tanımlanan fonksiyonun 0 ile 10 aralığındaki integralini bulunuz. 9.98 4.79 kanalın derinlik ve su hızı verisi aşağıdaki tabloda verilmiştir. 0 0 0 20 0 0 Kanalın kesit alanı bulunmak istenilir ise B Ac   H ( x)dx olacaktır. Kanalın debisi bulunmak istenilir ise 0 B Q   U ( x) H ( x)dx olacaktır. Burada U suyun x noktasında ölçülen hızıdır(m/s). Tüm kanal için suyun 0 debisini (Q) ve kesit alanını (Ac) hesaplayınız. Not veriyi arttırmak için kübik şerit interpolasyonu uygulanabilir. 0 0 5 10 15 20 25 -1 derinlik m -2 -3 Seri 2 -4 -5 -6 -7 sol kıyıdan uzaklık m dT  k (T  Ta ) dt denklemiyle ifade edilebilir. Olarak verilmiştir. 0 90 5 55 10 40 15 28 20 24 25 22 30 21.5 Tablosundaki değerlere göre değişmektedir. k değerini hesaplayınız. Not k değeri sabit mi olacaktır. yoksa zamana göre değişecek midir. Verilen şeklin alanınını bulunuz. Xi 241 258 283 307 322 333 334 Yi 127 107 96 97 106 120 138 xi 331 323 312 298 283 267 241 yi 157 178 197 217 232 246 258 xi 215 199 184 170 159 151 148 yi 246 232 217 197 178 157 138 xi 149 160 175 199 224 241 Yi 120 106 97 96 107 127 I  e y/x dydx integralini Gauss-Legendre Metodu kullanarak çözünüz. 0.1 x3 dy dx 2 x0 y 0 (1  y ) 1 1 I   35 20.6 integralini monte-carlo metodu kullanarak çözünüz, 2 boyutlu Gauss-Legenre integrali kullanarak sonucu kontrol ediniz. 0 analitik sonuçla karşılaştırınız. Motorun durdurulduğu t=0 anında hareket denklemi Burada v(m/sn), t anında otomobilin hızıdır. Hız 15 m/sn olana dek aracın gideceği yolu 4 nokta Gauss yöntemiyle hesaplayınız. Bu sürede aracın kaç metre yol alacağını çoklu yamuk yöntemi ile hesaplayınız. t(dk) 0 0,5 1,0 1,5 2,0 2,5 3,0 3,5 4,0 4,5 5,0 v (km/h) 0 4 7 11 15 21 25 30 32 35 40 Not v dx dt t x  x0   v(t )dt t0 Eğer U = 2000 m/s, mo = 150 000 kg, q = 2600 kg/s ise 30 saniyede roketin çıkacağı z yüksekliği Romberg integralini kullanarak k=4 için [O(h8)] hata mertebesi ile hesaplayınız. Zaman, t (s) Konum, x (m) 0 0 1 0.7 2 1.8 3 3.4 4 5.1 5 6.5 6 7.3 7 8.0 8 8.4 x -3 -1 1 3 5 7 9 11 f(x) 1 -4 -9 2 4 2 6 -3 Nehirde su köprü tabanına temas ederek akmaktadır.  f ( x)dx integralini aşağıda veri olarak verilen değerleri kullanarak tahmin ediniz. 0 X f(x) 0.99 4.90 2.10 5.70 3.22 4.20 4.40 7.04 5.70 8.31 7.12 7.82 8.01 5.97 8.37 7.01 9.32 6.68 9.98 4.79 Sonucu 2 41  x 4 Gauss-Legendre integral denklemi kullanarak I   tam değeriyle karşılaştırınız. dx integralini 2 41  x 4 1 cos( x)dx 1 Gauss-Chebychev integral denklemi kullanarak I   = 2.40394 integralini çözünüz ve tam değeriyle karşılaştırınız. 1 Trapezoidal integral denklemi kullanarak I   Burada v akışkanın hızı, A borunun akış kesit alanıdır. Dairesel kesitli bir boruda A = (2  r) ve dA = (2  r dr)'dir. Buradan Q = v(2r) dr eşitliği elde edilir. Burada r boru merkezinden dışa doğru yarıçap doğrultusunda uzaklıktır. Not En az 10 aralık seçilecektir. 1 a) I1   b) 1 0 1 c) I 3   x dx  0 2 7 2 3 1 d) I 4   log( x)dx  1 0 1 e) f) I 6   e  x sin(50 x)dx  0 10000 g) I6   dx 9 50 (1  e 2 ) 2501  206 x Düz bir duvardaki rüzgar basıncı diyagramda görüldüğü gibi ölçülmüştür. Bu duvardaki basınç etki merkezini bulmak istiyoruz. Basınç etki merkezi 112 _ h  hp(h)dh 0 112 formülüyle hesaplanır.  p(h)dh 0 Eğer arabanın kütlesi m=2000 kg ise, arabanın 0 m/s2 den 6 m/s2 ye hızlanması için gerekli olan süreyi hesaplayınız. 6s Not t  m  (v / P)dv 0s kayarak hareket edebilen bir m kütlesi şekilde görüldüğü gibi yay katsayısı k olan bir yayla bağlanmıştır. M, k ve L değerleri değişken olarak tanımlanacaktır.     I     e x y  z dzdydx integralini 3 boyutlu Gauss-Legendre integrali kulanarak çözünüz. 0 1 0 x C2 14387.69 mK  T T F (0  T )  1  x İntegral formülü ile hesaplanır. Bu değer aynı zamanda F (0  T )  15 4   n 1 serisiyle de hesaplanabilir. Bu seri ve integral formülünü hesaplayan metodlar yazınız. Çıktı değerlerini seri ve integral çözümüyle ve tablo değerleriyle karşılaştırınız. İntegral yöntemi size bırakılmıştır.  T F(0-T)  mK  T F(0-T)  mK  T F(0-T)  mK  T F(0-T)  mK  T F(0-T)  T  mK  mK F(0-T) 1000 0.00032 2900 0.25056 4800 0.60754 6900 0.8022 10700 0.92709 18000 0.98081 1050 0.00056 2950 0.26191 4850 0.61428 7000 0.80808 10800 0.92872 18200 0.98137 1100 0.00091 3000 0.27323 4900 0.62089 7100 0.81374 10900 0.93031 18400 0.98191 1150 0.00142 3050 0.28453 4950 0.62737 7200 0.81918 11000 0.93185 18600 0.98243 1200 0.00213 3100 0.29578 5000 0.63373 7300 0.82443 11200 0.9348 18800 0.98293 1250 0.00308 3150 0.30697 5050 0.63996 7400 0.82949 11400 0.93758 19000 0.98341 1300 0.00432 3200 0.3181 5100 0.64608 7500 0.83437 11600 0.94021 19200 0.98387 1350 0.00587 3250 0.32915 5150 0.65207 7600 0.83907 11800 0.9427 19400 0.98431 1400 0.00779 3300 0.34011 5200 0.65795 7700 0.8436 12000 0.94505 19600 0.98474 1450 0.01011 3350 0.35097 5250 0.66371 7800 0.84797 12200 0.94728 19800 0.98516 1500 0.01285 3400 0.36173 5300 0.66937 7900 0.85219 12400 0.94939 20000 0.98555 1550 0.01605 3450 0.37238 5350 0.67491 8000 0.85625 12600 0.95139 20500 0.98649 1600 0.01972 3500 0.38291 5400 0.68034 8100 0.86018 12800 0.95329 21000 0.98735 1650 0.02388 3550 0.39332 5450 0.68566 8200 0.86397 13000 0.95509 21500 0.98814 1700 0.02854 3600 0.4036 0.69089 8300 0.86763 13200 0.95681 22000 0.98886 1750 0.03369 3650 0.41375 5550 0.696 8400 0.87116 13400 0.95843 22500 0.98952 1800 0.03934 3700 0.42377 5600 0.70102 8500 0.87457 13600 0.95998 23000 0.99014 1850 0.04549 3750 0.43364 5650 0.70594 8600 0.87787 13800 0.96145 23500 0.9907 1900 0.05211 3800 0.44338 5700 0.71077 8700 0.88105 14000 0.96285 24000 0.99123 1950 0.0592 3850 0.45297 5750 0.7155 8800 0.88413 14200 0.96419 24500 0.99172 2000 0.06673 3900 0.46241 5800 0.72013 8900 0.88711 14400 0.96546 25000 0.99217 2050 0.07469 3950 0.47172 5850 0.72468 9000 0.88999 14600 0.96667 26000 0.99297 2100 0.08306 4000 0.48087 5900 0.72914 9100 0.89278 14800 0.96783 27000 0.99368 2150 0.0918 4050 0.48987 5950 0.73351 9200 0.89547 15000 0.96893 28000 0.99429 2200 0.10089 4100 0.49873 6000 0.73779 9300 0.89808 15200 0.96999 29000 0.99482 2250 0.11031 4150 0.50744 6050 0.74199 9400 0.9006 0.971 30000 0.99529 2300 0.12003 4200 0.516 6100 0.74611 9500 0.90305 15600 0.97196 32000 0.99607 2350 0.13002 4250 0.52442 6150 0.75015 9600 0.90541 15800 0.97289 34000 0.99669 2400 0.14026 4300 0.53269 6200 0.75411 9700 0.9077 16000 0.97377 36000 0.99719 2450 0.15071 4350 0.54081 6250 0.758 9800 0.90992 16200 0.97461 38000 0.99759 2500 0.16136 4400 0.54878 6300 0.76181 9900 0.91207 16400 0.97542 40000 0.99792 2550 0.17217 4450 0.55662 6350 0.76554 10000 0.91416 16600 0.9762 0.99851 2600 0.18312 4500 0.56431 6400 0.76921 10100 0.91618 16800 0.97694 50000 0.9989 2650 0.19419 4550 0.57186 6450 0.7728 10200 0.91814 17000 0.97765 55000 0.99917 2700 0.20536 4600 0.57927 6500 0.77632 10300 0.92004 17200 0.97834 60000 0.99935 2750 0.2166 4650 0.58654 6600 0.78317 10400 0.92188 17400 0.97899 2800 0.22789 4700 0.59367 6700 0.78976 10500 0.92367 17600 0.97962 2850 0.23922 4750 0.60067 6800 0.7961 0.9254 0.98023 5500 10600 15400 17800 45000 7 Denklem [A]{X} = [I]{ {X}  [A-]{X} şeklinde de yazılabilir. Buradaki değerine özdeğer, sınırdeğer veya karekteristik değer (İngilizce eigen-value) adı verilir. Açık formda yazarsak a11    a  11  a11   ...  a1n  a12 a 22   a11 ... a2 n bu çözüm setini veren X değerlerine de sınırdeğer vektörü (İngilizce eigen-vector) adı verilir. A matrisinin sınır değerlerini büyüklük sırasına göre sıralayalım |1| > |2| > |3| > |4| …> |n-1| > |n En büyük sınır değere dominant sınır değer de denilir. Eğer bir sınır değer tüm diğer sınır değerlerden büyük ise bu gerçek bir sınırdeğer olmalıdır ve gerçek sayılardan oluşan sınırdeğer vektörü bulunmalıdır. x k k sınır değerine karşı gelen sınır değer vektörü olsun. A xk=k xk , 1 <= k < n. { x1 , x2 , x3 , x4 ,…, xn } n sınır değer vektörü olsun. bu vektörün lineer olarak bağımsız bir set oluşturduğunu varsayalım, bu varsayım A simetrik matrisse ve aynı zamanda n birbirinden bağımsız sınır değeri varsa geçerlidir. denklemi ile ifade edilebilir. denklemi genelleştirirsek n in en büyük sınır değer olduğunu hatırlayalım. Bu durumda denklemi parantezine alırsak i k Bu denklemde i  k  x , i  0     k / 1  1 dir. i  iken k / 1 i  0 . Bundan dolay vektörü bilindiğinde sınır değere rahatlıkla geçebiliriz. Bu durumda yaklaşık olarak  k 0 yazabiliriz ve  sınır değere yaklaşır. nün sınır değerden sapmasının hata fonksiyonu  k sınır değer ve yk sınır değer vektörüne dönüşür. Bu yüzden rk küçülürse iterasyon prosesinde sınır değere ulaşmış oluruz. Program 8.3-1 Kuvvet metodu ile en büyük sınırdeğerin bulunması import java.io. * import javax.swing. yeterince { //multiplys a vector transpose with a vector int n=left.length double tot=0 for(int i=0 i<n i++) { tot+=left[i]*right[i] } return tot } public static double eigen_power(double A[][]) { double eps=1e-15 double err=1 int m=100 int n=A.length double y[]=new double[n] double r[]=new double[n] double xnorm double mu=1.0 for(int i=0 i<n i++) y[i]=1.0 int k=0 double mueski double x[]=new double[n] do{ mueski=mu x=multiply(A,y) xnorm=norminf(x) for(int i=0 i<n i++) {y[i]=x[i]/xnorm } mu=YT_X(y,x)/YT_X(y,y) for(int i=0 i<n i++) {r[i]=mu*y[i]-x[i] } k++ err=Math.abs((mu-mueski)/mu) }while(err>eps) return mu } Çıktı 8.3-1 Kuvvet metodu ile en büyük sınırdeğerin bulunması yk  k  Program 8.4-1 En küçük sınır değer bulunması import java.io. * import javax.swing. * Çıktı 8.4-1 En küçük sınır değer bulunması Simetrik matrisler için matrisin transpozu kendine eşittir. {A}T={A} Simetrik matrislerin bu özelliğini kullanarak benzerlik dönüşümü adı verdiğimiz bir dönüşüm prosesi ile matrisi diagonal form adını verdiğimiz forma dönüştürebiliriz. Bu form yardımı ile de sınır değerlerini hesaplarız. P matrisinin tekil olmayan bir matris olduğunu varsayalım. Benzerlik dönüşümü {B}={P}-1{A}{ P} şeklinde yazılabilir. Benzerlik dönüşümü sonucu sınır değerler değişmez, fakat sınır değer vektörleri değişir. Bu yüzden B matrisinin sınır değerleri A matrisinin sınır değerleri ile aynıdır. Şimdi [y] k vektörünün {B} matrisinin k sınır değerine karşı gelen sınır değer vektörü olduğunu varsayalım. Bu durumda {B}[y]k = k [y]k olur. {B}={P}-1{A}{ P} denkleminin her iki tarafını da { P} ile çarpacak olursak { P} {B}={ P} {P}-1{A}{ P}={A}{ P} olduğunu görürüz. Buradan {A}{ P}[y]k = { P} {B}[y]k=k{ P} [y]k olur. Eğer [y]k {B} matrisinin sınırdeğer vektörü ise, {A} matrisinin sınırdeğer vektörü de [x]k gibi bir değer alacaktır. Bu durumda [y]k ve [x]k arasında [x]k={ P}[y]k bağıntısı bulunmalıdır. Yani {A} matrisinin sınırdeğer vektörleri {B} matrisinin sınır değer vektörlerinin {P} matrisiyle çarpımından elde edilebilir. Ortagonal benzerlik dönüşümü uygulanarak ( {P}-1 ={P}T) A simetrik matrisi diagonal forma dönüştürülebilir. Bu dönüşümü sağlamak için açısal döndürme matrisi R() kullanılabilir. R() matrisi p satırı ve q sütunu hariç birim matrise eşittir. Rpp=Rqq = cos()=c Rpq= - Rqp= - sin()=-s Örneğin n=8 p=3 q=5 için 1 0  0  0 R( )   0  0 0  0 0 1 0 0 0  0   0  0  0  0   0  0 0  0   1 0 0 0 0  0 0  0 0  1 Formunu alır. Burada dönme açısıdır.Dönme matrisi R'nin ilginç özellikleri mevcuttur. Bunlardan birisi de transpose matris ile çarpıldığında birim matrise eşit olmasıdır. {R(}T{R(}=I Aynı zamanda ters matris hesabı çok kolaydır. {R(}-1 ={R(}T bu denklem de {R(}T ={R(- } Eğer benzerlik dönüşümü R matrisi kullanılarak uygulanır ise {B}={R(}T{A}{R(} bu transformda açısını öyle seçebilirizki Bqp=0 olsun. Bqp=(Aqq - App) sin()cos()+Apq [cos2() – sin2()] = 0   2 Apq    olarak bulunur.   App  Aqq   1 2   arctan  Bu açıyı kullanan R matrisini kullanarak benzerlik dönüşümü gerçekleştirilir. Jacobi metodu şu şekilde uygulanır P=I seçilir. Diagonalin üst üçgenin düşen bölgede mutlak değeri en büyük olan Apq elemanı bulunur. P ve q değerleri kullanarak açısı hesaplanır. R matrisi hesaplanır. Sınır değerleri k=Akk alınır, sınır değer vektörü de P=[x1,x2,…,xn] olarak alınır. Jacobi metodunun temel problemi Apq elemanı sıfıra yaklaşıncaya kadar çok fazla iterasyon stepine ihtiyaç duymasıdır. Eğer A matrisini yukarıdaki işleme tabi tutmadan önce bir ön değişimden geçirir isek bu işlem hızlanabilir. Bu hızlanma işlemi için Matris üst Hesenberg matrisi denilen bir forma dönüştürülür.  B11 B12 B  21 B22  0 B32 B 0  0  ... ...  0  0 B13 B23 B33 B43 ... 0 ... ... ... ... ... ... B1,n1 B2,n1 B3,n1 B4,n1 ... Bn ,n1 Şekilden de görüleceği gibi bu formda matrisin üst üçgeni ve diagonalin altındaki satırlar mevcuttur. Bu dönüşüm işlemi Householder dönüşüm işlemi adını alır. Dönüşüm işlemi şu steplerden oluşur 1. Q=I alınır 2.   sign( Ak 1,k ) n A j k 1 2 j ,k buradaki sign( Ak 1,k ), Ak 1,k nin işaretinin 1 ile çarpımıdır. sign(x)= x / |x| 3. P  I  4. 5. 6. B=A üst Hesenberg formuna dönüşmüş olur. Örnek problem olarak Program 8.5-1 Jacobi ve House holder dönüşümü ile simetrik matrislerin gerçek sınır değerlerinin hesaplanması import java.io. * import javax.swing. public static void main(String args[]) throws IOException { //Sınır değer hesapları double c[] c=new double[2] //double a[][]={{12,6,-6},{6,16,2},{-6,2,16}} double a[][]={{4,-2,6,4},{-2,2,-1,3},{6,-1,22,13},{4,3,13,46}} String s= Orijinal matris \n s+=Matrix.toString(a) //c=eigen_jacobi(a) Çıktı 8.5-1 Jacobi ve House holder dönüşümü ile simetrik matrislerin gerçek sınır değerlerinin hesaplanması Bu matrisi Q ortagonal ve L alt matris olmak üzere A=Q L biçiminde yazılabilir. Q ortogonal bir matris olduğundan QT = Q-1 dir. buradan yeni bir B matrisi oluşturulabilir. QL algoritması bir dizi ortogonal dönüşümü esas almaktadır. Burada ilgilendiğimiz A matrisi simetrik olduğundan özdeğerleri gerçek sayılar olacaktır. import java.io. * import javax.swing. absb=Math.abs(b) if (absa > absb) return absa*Math.sqrt(1.0+(absb/absa)*(absb/absa)) else return (absb==0.0 . B yine aynı şekilde tekrar benzerlik transformasyonundan geçirilir, B üst üçgen forma ulaştığı zaman, üst üçgen formdan sınır değerler elde edilebilir. Üst üçgene çevirme prosesi oldukça uzun sürebilir. Bu prosesi kısaltabilmek için matrisi üst hesenberg formuna çevirmek gerekir. Bunun için Householder transferiyle gerçekleştirilebilir. QR algoritmasında matris simetrik olmak zorunda değildir. Elbette simetrik olmayan matrisler için özdeğerlerin kompleks (karmaşık) sayılar çıkacağını göz önünde bulundurmamız gereklidir. Program 8.2-1 QR algoritması import java.io. * import javax.swing. * } Bu programda kullanılan kompleks değişken hesabını yapan complex sınıfı da program 4.4-3 de verilmiştir. Çıktı 8.2-1 QR algoritması Bu polinomun kökleri  bn 1  1  A 0   ...    b0  0  0  matrisinin sınır değerleri ile aynıdır. Bu yüzden n'inci dereceden  ...  0  polinomun köklerini bulmak için refakatçi matrisinin özdeğerlerini hesaplayabiliriz. Program 8.6-1 QR metodu ile refakatçi matris kullanarak ninci dereceden denklemin köklerinin çözülmesi import java.util. * import java.awt. * import javax.swing. * import java.awt.event. * 0.0 absb*Math.sqrt(1.0+(absa/absb)*(absa/absb))) Bu programda kullanılan kompleks değişken hesabını yapan complex sınıfı da program 4.4-3 de verilmiştir. Çıktı 8.6-1 ninci dereceden denklemin köklerini QR metodu sınır değeri ile hesaplayan programın çıktısı Milin üzerine T burkulma torku ve M eğilme momenti uygulanmaktadır. -4.7 4.6 11.8 6.45 11.8 -8.3 olarak verilmiştir. Q noktasındaki asal gerilmeleri hesaplayan bir program yazınız. Not Asal gerilmeler gerilme matrisinin sınır değerleridir. 3  2 0 A  2 1 4 matrisinin sınır değerlerini hesaplayınız. 3 9  5 7 12 7  0  11 8  matrisinin en büyük sınır değerini hesaplayınız  14 1  5 6  2 13   18  5  7 Cevap Not asal gerilmeler verilen gerilme matrisinin sınır değerleridir. 9 Bunun için ilk kullanacağımız ilk dx metod Euler yöntemidir. Bu yöntem y0i+1=yi +f(xi,yi)h olarak yazılabilir. Burada h adım büyüklüğüdür. Çıktılardan da görüldüğü gibi h değeri küçüldükçe çözüm gerçek çözme yaklaşmaktadır. Program 9.1-1 Euler denklemi //====================================================== // Numerical Analysis package in java // example to show differential equation solution // and differentiation (derivative) functions // Dr. Turhan Coban // ===================================================== // Basit diferansiyel denklemler dy/dx=f(x,y) import java.io. } } Çıktı 9.1-1 Euler denklemi h=1 Çıktı 9.1-3 Euler denklemi h=0.5 Çıktı 9.1-4 Euler denklemi h=0.1 y0i+1=yi +f(xi,yi)h y ik11  yi  f ( xi , y ik )  f ( xi 1 , yik1 ) 2 k Burada bulduğumuz y i+1iteratif olarak hesaplanabilecek bir terimdir. İterasyon stepinin uygulanma sayısı değişebilir. Program 9.1-1 Heun denklemi //====================================================== // Numerical Analysis package in java // example to show differential equation solution // and differentiation (derivative) functions // Dr. Turhan Coban // ===================================================== // Basit diferansiyel denklemler dy/dx=f(x,y) import java.io. * abstract class f_xy { //single function single independent variable // example f=x*x abstract double func(double x,double y) } Çıktı 9.1-1 Heun denklemi, step h=1 için Çıktı 9.3-1 Orta nokta ve geliştirilmiş polinom denklemi, h=1 Çıktı 9.3-2 Orta nokta ve geliştirilmiş polinom denklemi, h=0.5 Çıktı 9.3-3 Orta nokta ve geliştirilmiş polinom denklemi, h=0.1   x1 , y1 , h)   ai ki i 1 burada a lar sabit değerler olup k değerleri k1=f(xi,yi) k2=f(xi+p1h,yi+q11k1h) k3=f(xi+p2h,yi+q21k1h+ q22k2h) …. kn=f(xi+pn-1h,yi+qn-1,1k1h+ …+ qn-1,n-1kn-1h ) şeklinde ifade edilebilir. Görüldüğü gibi yöntem çok geneldir ve katsayıların aldığı değerlere göre hassasiyetleri artmaktadır. Örneğin ikinci derece Runge – Kutta (RK2) yi+1 = yi + ( 0.5k1 + 0.5k2 )h k1=f(xi,yi) k2=f(xi+h,yi+k1h) Program 9.4-1 ikinci dereceden Runge-Kutta (Ralston) denklemi //====================================================== // Numerical Analysis package in java // example to show differential equation solution // and differentiation (derivative) functions // Dr. Turhan Coban // ===================================================== // Basit diferansiyel denklemler dy/dx=f(x,y) import java.io. Çıktı 9.4-1 ikinci dereceden Runge-Kutta (Ralston) denklemi, h=1 Program 9.4-2 Üçüncü dereceden Runge-Kutta denklemi //====================================================== // Numerical Analysis package in java // example to show differential equation solution // and differentiation (derivative) functions // Dr. Turhan Coban // ===================================================== // Basit diferansiyel denklemler dy/dx=f(x,y) import java.io. * abstract class f_xy { //single function single independent variable // example f=x*x abstract double func(double x,double y) } class fxy extends f_xy Çıktı 9.4-2 Üçüncü dereceden Runge-Kutta denklemi, h=1 Program 9.4-3 Dördüncü dereceden Runge-Kutta (Ralston) denklemi //====================================================== // Numerical Analysis package in java // example to show differential equation solution // and differentiation (derivative) functions // Dr. Turhan Coban // ===================================================== // Basit diferansiyel denklemler dy/dx=f(x,y) import java.io. Çıktı 9.4-3 Dördüncü dereceden Runge-Kutta (Ralston) denklemi, h=0.5 Program 9.4-4 Altıncı dereceden Runge-Kutta (Ralston) denklemi //====================================================== // Numerical Analysis package in java // example to show differential equation solution // and differentiation (derivative) functions // Dr. Turhan Coban // ===================================================== // Basit diferansiyel denklemler dy/dx=f(x,y) import java.io. Program 9.4-4 Altıncı dereceden Runge-Kutta denklemi, h=0.5 Bu tür metodların cözüm kararlılıklarının daha iyi olduğu yönünde görüşler mevcuttur. İlk olarak Milne formülüne göz atalım Milne 1. adım formülü (ilk tahmin) yip1  yi 3  Milne 2. adım formülü (ilk düzeltme) yi(01)  y jp1   28 yi  yip 29  Milne 3. adım formülü (düzeltme)   3 Bu metodları uygulayabilmek için daha önceden hesaplanmış noktalara ihtiyaç mevcuttur. Daha önceki noktalar tek adımlı metodlarla (örneğin Runge-Kutta metodlarıyla) hesaplanarak başlanabilir. Örnek olarak Bu çözümü kullanarak hata miktarını da inceleyebiliriz. y 1 x2 y'  Program 9.5-1 Milne Tahmin-düzeltme (Predictor-corrector) formülü //====================================================== // Numerical Analysis package in java // example to show differential equation solution // and differentiation (derivative) functions // Dr. Turhan Coban // ===================================================== // Basit diferansiyel denklemler dy/dx=f(x,y) import java.io. Çıktı 9.5-1 Milne Tahmin-düzeltme (Predictor-corrector) formülü grafik çıktı Çıktı 9.5-2 Milne Tahmin-düzeltme (Predictor-corrector) formülü hesaplanan değerler y_çözüm 0 0.062256809 0.123076922 0.181132074 0.235294614 0.284697577 0.328767367 0.367212702 0.399999711 0.427298769 0.449437527 0.466842287 0.479999216 0.489410522 0.495574537 0.498959376 0.499999514 0.499081613 0.496551452 0.492705844 0.487804796 0.482065316 0.475675749 0.468789209 0.461538657 0.454028961 0.446352222 0.438578152 0.430769597 0.422971217 0.415225342 0.40755904 0.400000481 2.8879E-07 9.34563E-07 6.75003E-07 1.2147E-06 7.8413E-07 1.24273E-06 6.83803E-07 1.1231E-06 4.86142E-07 9.56231E-07 2.72191E-07 8.01101E-07 8.16887E-08 6.81141E-07 -7.3537E-08 5.99558E-07 -1.95371E-07 5.51033E-07 -2.9049E-07 5.28107E-07 -3.6604E-07 5.23921E-07 -4.28026E-07 5.33046E-07 -4.8098E-07 İkinci olarak olarak Hamming formülüne bakalım. Bu formül Milne formülüne oldukça yakındır. Bu formülün hata miktarı milne formülüne göre biraz daha düşüktür, ancak kararlılık yönünden biraz daha iyidir. Hamming 1. adım formülü (ilk tahmin) yip1  yi 3  Hamming 2. adım formülü (ilk düzeltme) yi(01)  y jp1   112 yi  yip 121  Hamming 3. adım formülü (düzeltme) yi(k11)    Program 9.5-2 Hamming Tahmin-düzeltme (Predictor-corrector) formülü //====================================================== // Numerical Analysis package in java // example to show differential equation solution // and differentiation (derivative) functions // Dr. Turhan Coban // ===================================================== // Basit diferansiyel denklemler dy/dx=f(x,y) import java.io. k=0,1,…. Çıktı 9.5-2 Hamming Tahmin-düzeltme (Predictor-corrector) formülü hesaplanan değerler y_çözüm 0 0.062256809 0.123076922 0.181132074 0.235295447 0.284699363 0.328768754 0.367213781 0.399999285 0.427297497 0.449434654 0.466838916 0.479994747 0.489406203 0.495569657 0.498955165 0.499995055 0.499078103 0.496547778 0.492703217 0.487801944 0.482063515 0.475673598 0.468788085 0.461537041 0.45402835 0.446350987 0.438577917 0.430768617 0.422971251 0.415224525 0.407559266 0.399999761 -1.32917E-06 -1.85455E-06 -1.63052E-06 -6.6612E-07 7.14995E-07 2.20588E-06 3.5483E-06 4.58534E-06 5.25346E-06 5.56192E-06 5.56428E-06 5.33375E-06 4.94536E-06 4.46539E-06 3.94663E-06 3.42766E-06 2.93423E-06 2.48172E-06 2.07773E-06 1.7244E-06 1.42031E-06 1.16193E-06 9.44654E-07 7.63473E-07 6.13446E-07 4.89946E-07 3.88796E-07 3.06316E-07 2.3933E-07 Çıktılarda Runge_kutta 6 metoduyla hesaplanan ilk değerler koyu olarak verilmiştir. Üçüncü olarak AdamsBashford-Moulton formüllerini inceleyelim. Bu formüller birbirini tamamlıyan bir tahmin formülü (predictor) ve bir düzeltme formülünün (corrector) beraber kullanılmasıyla oluşur. Adams-Bashford-Moulton modelinde ilk tahmin için Adams-Bashford formüllerinden yararlanılır. Bu formül Adams-Bashford 1 adım formülü y i 1 yi  hf ( xi , yi ) Adams-Bashford 2 adım formülü y i 1  yi  h 3 f ( xi , yi )  f ( xi1 , yi1 ) 2 Adams-Bashford 3 adım formülü y i 1  yi  Adams-Bashford 4 adım formülü y i 1  yi  Adams-Bashford 5 adım formülü y i 1  yi  h 1901 f ( xi , yi )  2774 f ( xi1 , yi1 )  2616 f ( xi2 , yi2 )  1274 f ( xi3 , yi3 )  251 f ( xi4 , yi4 ) 720 Şeklindedir. Düzeltme terimi olarak Adams-Moulton formülünü kullanabiliriz. Bu formül değişik polinom kademeleri için Adams-Moulton 0 adım formülü y i 1 yi  hf ( xi 1 , yi 1 ) Adams-Moulton 1 adım formülü y i 1  yi  h  f ( xi1 , yi1 )  f ( xi , yi ) 2 Adams-Moulton 2 adım formülü y i 1  yi  h 5 f ( xi1 , yi . ) ) 12 Adams-Moulton 3 adım formülü y i 1  yi  Adams-Moulton 4 adım formülü y i 1  yi  h 251 f ( xi1 , yi1 )  646 f ( xi , yi )  264 f ( xi1 , yi1 )  106 f ( xi2 , yi2 )  19 f ( xi3 , yi3 ) 720 Program listesi aşağıda verilmiştir. Bu programda Adams Bashford 4 adım formülü ile Adams-Milton 3 adım formülünü kullanan bir metod ve Bashford 5 adım formülü ile Adams-Milton 4 adım formülünü kullanan bir metod verilmiştir. Program 9.5-3 Adams-Bashford-Milton Tahmin-düzeltme (Predictor-corrector) formülü //====================================================== // Numerical Analysis package in java // example to show differential equation solution // and differentiation (derivative) functions // Dr. Turhan Coban // ===================================================== // Basit diferansiyel denklemler dy/dx=f(x,y) import java.io. } Çıktı 9.5-4 Adams-Bashford 4 adım Adams-Milton 3 adım Tahmin-düzeltme (Predictor-corrector) formülü grafik çıktı Hata miktarlarını görebilmek için Adams-Bashford 4 adım ve Adams-Milton3 adım Tahmin-düzeltme yöntemi ile çözdüğümüzde hata miktarları aşağıda verilmiştir. Runge-Kutta 6 adım yöntemi ile hesaplanan başlangıç değerleri koyu olarak işaretlenmiştir. Çıktı 9.5-5 Adams-Bashford 4 adım Adams-Milton 3 adım Tahmin-düzeltme (Predictor-corrector) formülü Hesaplanan değerler X y_hesaplanan y_tam çözüm hata 0 0 0 0 0.0625 0.062256809 0.062256809 1.29392E-10 0.125 0.123076922 0.123076923 6.07481E-10 0.1875 0.181132074 0.181132075 1.36894E-09 0.25 0.235295557 0.235294118 -1.43921E-06 0.3125 0.284699363 0.284697509 -1.8537E-06 0.375 0.328768525 0.328767123 -1.40145E-06 0.4375 0.367213479 0.367213115 -3.64545E-07 0.5 0.399999069 0.4 9.31283E-07 0.5625 0.427297499 0.427299703 2.20423E-06 0.625 0.449434941 0.449438202 3.26136E-06 0.6875 0.466839495 0.466843501 4.0062E-06 0.75 0.479995578 0.48 4.42175E-06