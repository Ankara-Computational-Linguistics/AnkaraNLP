birdosya isimi olup olamdığını kontrol eder. lastModified() Dosyanın en son değiştirildiği tarihi verir length() Dosyanın boyutunu Byte olarak verir. list() Verilen dizinin içindeki dosyaların listesini verir. list(FilenameFiltre) Verilen dizinin içindeki Filtre nesnesindeki tanıma uyan dosyaların listesini verir. mkdir() Yeni bir dizin oluşturur. mkdirs() O anda tanımlı olan dizinin içine bir alt dizin oluşturur. renameTo(File) Dosyanın ismini değiştirir. toString() Dosya ve dizin isimleri topluluğunun String değişkeni eşdeğerini verir. File(dosya) sınfındaki metodlardan da görülebileceği gibi bu sınıf dosyadan okuyup yazma gibi bir işlem yürütmez. File sınıfının temel işlevi girdi çıktı dosyasının adlandırılması ve isimle ilgili fonksiyonlara ulaşılmasıdır. File sınıfının bazı metotlarını ufak bir program içinde kullanalım. FileTestiSW.java programı import java.awt. * import java.io.File import java.util.HashMap import java.awt.event. * import javax.swing. * import javax.swing.filechooser. * import javax.swing.event. * public class FileTestiSW { public static void main(String args[]) { //önce JFileChooser kullanarak dosyayı seç, sonra dosya özelliklerini göster. Mevcut Mevcut değil + \n s+=f.canWrite() . Yazılabilir Yazılamaz + \n s+=f.canRead() . Okunabilir Okunamaz + \n s+=f.isDirectory() . Dizin Dizin degil + \n s+=f.isFile() . Dosya Dosya degil + \n s+=f.isAbsolute() . Her dosya dosya-bitiş işaretiyle sonlanır. Yeni bir dosya açıldığında bu dosyayla ilgili bir nesne oluşturulur. Yeni bir java programı açıldığında üç akış nesnesi otomatik olarak açılır. Bunlar System.in , System.out, System.err nesneleridir. Eğer kendimiz bir girdi veya çıktı akış nesnesi oluşturmak istersek FileInputStream veya FileOutputStream sınıfı bir nesne tanımlıyabiliriz. Akısın içindeki değişkenleri sadece byte olarak okumak yerine direk olarak double veya integer gibi değişkenler türünden okumak istersek DataInputStream ve DataOutputStream sınıflarını kullanabiliriz. Genel olarak FileOutputStream ve DataOutputStream sınıflarını aşağıdaki gibi bir arada kullanabiliriz DataOutputStream ciktiakimi try{ ciktiakimi=new DataOutputStream(new FileOutputStream( isim.dat )) } catch(IOException e) {System.err.println( Dosya acilamadi\n +e.toString()) } Bu deyim bize isim.dat isimli dosyadan bir fileOutputStream aracılığıyla açılan dosyayı DataOutputStream'e çevirip gerçek değişkenler cinsinden akış kanalı açar. DataOutputStream ve FileOutputStream sınıflarının tanımları public class DataOutputStream extends FilterOutputStream implements DataOutput { public DataOutputStream(OutputStram o) protected int written public void flush() public final void size() public synchronized void write(byte[],int baslangıçnoktası,int uzunluk) public synchronized void write(int) public final void writeBoolean(boolean b) public final void writeBytes(String s) public final void writeChar(int) public final void writeChars(String) public final void writeDouble(double) public final void writeFloat(float) public final void writeInt(int) public final void writeLong(long) public final void writeShort(int) public final void writeUTF(String) } FileOutputStream ise dosya sınıfı File ile DataOutputStream sınıfı arasındaki gerekli tanımları sağlar public class FileOutputStream extends OutputStream { public FileOutputStream(File file) throws IOException public FileOutputStream(FileDescriptor fd) throws IOException public FileOutputStream(String s) throws IOException public FileOutputStream(String s, boolean b) throws IOException public void close() throws IOException protected void finalize() throws IOException public void getFD() throws IOException public void write(byte[]) throws IOException public void write(byte[], int, int) throws IOException public void write(int) throws IOException public final FileDescriptor getFD() throws IOException } Kanal açıldıktan sonra DataOutputStream sınıfının metodlarını kullanarak dosyaya yazı yazabiliriz. Yazma metodlarının işlevlerine bir göz atarsak write(byte B[] ) byte tipi boyutludeğişkeni açılmış olan DataOutputStream kanalına yazar. write(byte B[], int baslangıcindeksi, int indeksboyutu) byte tipi boyutludeğişkeni açılmış olan DataOutputStream kanalına yazar. Baslangiç indeksinden baslar ve indeksboyutu uzunluğundaki kısmı yazar. write(int B) int datayı data output stream'e yazar. writeBoolean(boolean B) Boolean değişkeni DataOutputStream'e yazar. writeByte(int) int değişkeni byte olarak DataOutputStream'e yazar. writeBytes(String) String değişkeni byte boyutlu değişken olarak DataOutputStream'e yazar. writeChar(int) int değişkeni char değişken olarak DataOutputStream'e yazar. writeChars(String) String değişkeni Char değişken olarak DataOutputStream'e yazar. writeDouble(double) double değişkeni double değişken olarak DataOutputStream'e yazar. writeFloat(float) float değişkeni float değişken olarak DataOutputStream'e yazar. writeInt(int) float değişkeni float değişken olarak DataOutputStream'e yazar. writeLong(long) long değişkeni long değişken olarak DataOutputStream'e yazar. writeShort(int) int değişkeni short (short integer) değişken olarak DataOutputStream'e yazar. writeUTF(String) String değişkeni unicode UTF-8 formatı karekter boyutu olarak yazar. Bu şekilde yazdığımız bir veri akışın okumak için ise DataInputStream girdiakimi try{ girdiakimi=new DataInputStream(new FileInputStream( isim.dat )) } catch(IOException e) { System.err.println( Dosya acilamadi\n +e.toString()) System.exit(1) } tanımını kulanabiliriz. Buradaki DataInputStream sınıfının tanımı public class DataInputStream extends FilterInputStream implements DataInput { public DataInputStream(InputStream in) public DataInputStream(InputStream in) public final int read(byte b[]) throws IOException public final int read(byte b[], int başlangıçdeğeri, int uzunluk) throws IOException public final void readFully(byte b[]) throws IOException public final void readFully(byte b[],int başlangıçdeğeri, int uzunluk) throws IOException public final int skipBytes(int n) throws IOException public final boolean readBoolean() throws IOException public final byte readByte() throws IOException public final int readUnsignedByte() throws IOException public final short readShort() throws IOException public final int readUnsignedShort() throws IOException public final char readChar() throws IOException public final int readInt() throws IOException public final long readLong() throws IOException public final float readFloat() throws IOException public final double readDouble() throws IOException public final String readLine() throws IOException public final String readUTF() throws IOException public final static String readUTF(DataInput in) throws IOException } şeklindedir. FileInputStream ise public FileInputStream(File file) throws FileNotFoundException { public FileInputStream(FileDescriptor fdObj) public int read() throws IOException public int read(byte b[]) throws IOException public int read(byte b[],int başlangıçnoktası,int uzunluk) throws IOException public long skip(long n) throws IOException public int available() throws IOException public void close() throws IOException public final FileDescriptor getFD() throws IOException protected void finalize() throws IOException } şeklinde tanımlıdır. DataInputStream metdunun alt okuma metodlarına biraz daha detaylı göz atarsak read(byte[]) byte veri akışını direk okur. read(byte[], int başlangıçnoktası, int boyut) byte veri akışını başlangıçnoktası indeksinden boyut uzunluğuna kadar okurdirek okur. readBoolean() boolean değişken (true veya false) okur. readByte() 8-bit byte integer okur readChar() unicode karecter(char) okur readDouble() double okur readFloat() float okur readFully(byte[]) byte boyutlu değişkenini, byte[] boyutlu girdi değişkeninin boyutuna göre okur. readFully(byte[], int, int) readInt() Integer okur readLine() Bir satırı satırbaşı yap komutuna kadar okur. 1.1 ve üzerinde bazı okuma hataları yaptığı görüldüğünden kullanılmaması tavsiye edilir. readLong() Long tamsayı değişkeni okur. readShort() Short tamsayı değişkeni okur readUnsignedByte() 8-bitlik işaretsiz tamsayı değişkeni okur. readUnsignedShort() 16-bitlik işaretsiz tamsayı değişkeni okur. readUTF() Unicode karekteri okur. readUTF(DataInput) Unicode Karakterini (Character) DataInput girdi akışından okur. skipBytes(int n) n byte değeri okumadan atlar. Şimdi bir örnek problem ile bu yazma ve okuma işlemine daha yakından bir göz atalım. * import java.awt. * import java.awt.event. * import javax.swing. c.add(hesapKutusu) enter=new JButton( Gir ) enter.addActionListener(this) c.add(enter) done=new JButton( Cikis ) done.addActionListener(this) c.add(done) setVisible(true) } public void hesapEkle() { int accountNumber=0 Double d if(.hesapIsmiKutusu.getText().equals( )) { try{ accountNumber=Integer.parseInt(hesapIsmiKutusu.getText()) if(accountNumber>0) { cikti.writeInt(accountNumber) cikti.writeUTF(isimKutusu.getText()) cikti.writeUTF(soyIsimKutusu.getText()) d=new Double(hesapKutusu.getText()) cikti.writeDouble(d.doubleValue()) } hesapIsmiKutusu.setText( ) isimKutusu.setText( ) soyIsimKutusu.setText( ) hesapKutusu.setText( ) } catch(NumberFormatException nfe) { System.err.println( Hesap numarasi tamsayi degisken olamalidir ) } catch(IOException io) { System.err.println( Dosyaya yazarken hata olustu\n +io.toString()) System.exit(1) } } } public void actionPerformed(ActionEvent e) { hesapEkle() if(e.getSource()==done) { try{ cikti.close() } catch(IOException io) { System.err.println( Dosya kapatilamadi\n +io.toString()) } System.exit(0) } } public static void main(String[] args) { ardisikDosyaYaratSWF_2000 pencere= new ardisikDosyaYaratSWF_2000() pencere.setSize(300,150) pencere.addWindowListener(new BasicWindowMonitor()) pencere.setVisible(true) } } * import java.awt. * import java.awt.event. * public class ardisikDosyaOku extends Frame implements ActionListener { private TextField accountField,firstNameField,lastNameField,balanceField private Button next,done private DataInputStream input public ardisikDosyaOku() { super( Musteri dosyasini oku ) try{ input=new DataInputStream(new FileInputStream( musteri.dat )) } catch(IOException e) { System.err.println( Dosya acilamadi\n +e.toString()) System.exit(1) } setSize(300,150) setLayout(new GridLayout(5,2)) add(new Label( Hesap Numarasi )) accountField=new TextField() add(accountField) add(new Label( isim )) firstNameField=new TextField(20) add(firstNameField) add(new Label( soyisim )) lastNameField=new TextField(20) add(lastNameField) add(new Label( Hesaptaki para )) balanceField=new TextField(20) add(balanceField) next=new Button( bir sonraki hesap ) next.addActionListener(this) add(next) done=new Button( cikis ) done.addActionListener(this) add(done) setVisible(true) } public void readRecord() { int account String first,last double balance { try{ account=input.readInt() first=input.readUTF() last=input.readUTF() balance=input.readDouble() accountField.setText(String.valueOf(account)) firstNameField.setText(first) lastNameField.setText(last) balanceField.setText(String.valueOf(balance)) } catch(EOFException eof) { closeFile() } catch(IOException io) { System.err.println( Dosyay okurken hata olustu\n +io.toString()) System.exit(1) } } } public void actionPerformed(ActionEvent e) { if(e.getSource()==next) readRecord() else closeFile() } private void closeFile() { try{ input.close() System.exit(0) } catch(IOException e) { System.err.println( Dosya Kapama Hatası oluştu\n +e.toString()) System.exit(1) } } public static void main(String args[]) { new ardisikDosyaOku() } } Şekil 1.83-2 ArdisikDosyaOku.java programı ve sonuclarının Frame çıktısında görülmesi ArdisikDosyaYarat.java programında musteri.txt dosyası try{ cikti=new DataOutputStream(new FileOutputStream( musteri.txt )) } catch(IOException e) { System.err.println( Dosya dogru acilamadi\n +e.toString()) System.exit(1) } gurubunu kullanarak açılmıştır. Bu gurubu File sınıfını da kullanarak File f=new File( musteri.txt ) f=f.getAbsolutePath(f) try{ cikti=new DataOutputStream(new FileOutputStream(f)) } catch(IOException e) { System.err.println( Dosya dogru acilamadi\n +e.toString()) System.exit(1) } şeklinde de yaratabilirdik. İkinci şekilde dosyayı tanımlarken tam dizin ismini de otomatik olarak tanımlamış olurduk. Dosyanın okunması içinse try{ input=new DataInputStream(new FileInputStream( musteri.dat )) } catch(IOException e) { System.err.println( Dosya acilamadi\n +e.toString()) System.exit(1) } gurubunu kullandık. Eğer dosya ismi de değişkende dışarıdan okuduktan sonra ismi File sınıfına yükleyip sonra akış kanalı açabiliriz. Dosya ile işlemler bittikten sonra dosya kapanır. private void closeFile() { try{ input.close() System.exit(0) } catch(IOException e) { System.err.println( Dosya Kapama Hatası oluştu\n +e.toString()) System.exit(1) } } closeFile() metotu dosya akışını kapatmak amacıyla oluşturulmuştur. Bu örnekte kullandığımız, DataOutputStream, FileOutputStream, DataInputStream, FileInputStream girdi çıktı akış kontrolları temel olarak daha önce tanımlarını vermiş olduğumuz OutputStream ve InputStream sınıflarından türetilmiş sınıflardı. Ve temel olarak byte değişken türü üzerinden veri akışını sağlamaktadırlar. Yine yukarıda tanımlanmış olan Reader ve Writer sınıfları ise aynı işlemi char sınıfı veri akışı üzerinden yapmaktadır ve char sınfı direk olarak unicode olarak tanımlandığından herhangibir hataya sebep vermeden daha iyi bir veri akışı sağlar. Bu sınıfın alt sınıfları olarak tanımlanan ve yazma işleminde kullanılan sınıfların kullanılmasına bir göz atalım. Genel olarak Writer sınıfından türetilen ve en çok kullanılan Yazma kanalı PrintWriter, BufferedWriter, FileWriter veya OutputStreamWriter sınıflarının beraber kullanılmasıyla gerçekleştirilebilir. Bu sınıfların birlikte kulanılmalarını şu deyimlerle örnekleyebiliriz dosya a.txt e yazdırmak için PrintWriter cfout=new PrintWriter(new BufferedWriter(new FileWriter( a.txt ))) tanımı kullanılabilir. PrintWriter sınıfının tanımı public class PrintWriter extends Writer { public PrintWriter(OutputStream o) public PrintWriter(OutputStream o, boolean b) public PrintWriter(Writer w) public PrintWriter(Writer w, boolean b) public void flush() public void close() public boolean checkError() protected void setError() public void write(int c) public void write(char buf[]) public void write(String s,int baslamaindeksi,int uzunluk) public void write(String s) public void print(boolean b) public void print(char c) public void print(int i) public void print(long l) public void print(float f) public void print(double d) public void print(Object obj) public void println() public void println(boolean x) public void println(char x) public void println(int x) public void println(long x) public void println(float x) public void println(double x) public void println(char x[]) public void println(Object x) } PrintWriter sınıfının mevcut metotlarının işlevleri şunlardır checkError() Tüm veriyi gönderir ve hata kontrolu yapar. close() veri akış kanalını kapatır. flush() veri akış kanalındaki tüm veriyi gönderir (ve bufferi yeni veri için boşaltır). print (boolean) boolean değişken yazar. print (char) character değişken yazar. print (char[]) boyutlu chracter değişkenleriyazar. print (double) double yazar. print (float) float yazar. print (int) integer yazar. print (long) long yazar. print (Object) object sınıfının tanımladığı çıktıyı (object türüne göre değişebilir) yazar. print(String) String yazar println () satır sonu yapar alt satıra geçer. println (boolean) boolean yazar ve satır sonu yapar alt satıra geçer. println (char) character yazar ve satır sonu yapar alt satıra geçer. println (char[]) boyutlu character değişkenleri yazar ve satır sonu yapar alt satıra geçer. println (double) double yazar ve satır sonu yapar alt satıra geçer. println (float) float yazar ve satır sonu yapar alt satıra geçer. println (int) Print an integer, and then finish the line. println (long) long yazar ve satır sonu yapar alt satıra geçer. println (Object) object sınıfının tanımladığı çıktıyı (object türüne göre değişebilir) yazar ve satır sonu yapar alt satıra geçer. println(String) String yazar ve satır sonu yapar alt satıra geçer. setError() bir hata oluştuğunu gösterir write (char[]) boyutlu character değişkenlerini yazar write (char[], int, int) boyutlu character değişkenlerini birinci integer(tamsayı) boyutundan ikinci integer boyutuna kadar yazar. write (int) tek bir character yazar. write (String) string yazar write(String, int, int) string değişkenini birinci integer(tamsayı) boyutundan ikinci integer boyutuna kadar yazar. BufferedWriter sınıfının tanımı public class BufferedWriter extends Writer { public BufferedWriter(Writer cikti) public BufferedWriter(Writer cikti,int boyut) public void write(int c) throws IOException public void write(char c[],int başlamaindeksi,int uzunluk) throws IOException public void write(String s, int başlamaindeksi,int uzunluk) throws IOException public void newLine() throws IOException public void flush() throws IOException public void close() throws IOException } şeklindedir. Yazma verimini arttırmak için akışa ilave edilmektedir. FileWriter sınıfı ise File sınıfı ile bağlantımızı kuran (dosyayı tanımlayan sınıfımızdır.). Writer sınıfının altında yer alan OutputStreamWriter Sınıfının alt sınıfıdır. tanımı public class FileWriter extends OutputStreamWriter { public FileWriter(String fileName) throws IOException public FileWriter(String fileName,boolean append) throws IOException public FileWriter(File file) throws IOException public FileWriter(FileDescriptor fd) } OutputStreamWriter sınıfının tanımı public class OutputStreamWriter extends Writer { public OutputStreamWriter(OutputStream o,String enc) throws UnsupportedEncodingException public OutputStreamWriter(OutputStream o) public String getEncoding() public void write(int c) throws IOException public void write(char c[],int başlamaindeksi,int uzunluk) throws IOException public void write(String str,int başlamaindeksi,int uzunluk) throws IOException public void flush() throws IOException public void close() throws IOException } Bu sınıfları kullanarak bir yazma kanalı açmak istersek PrintWriter cfout=new PrintWriter(new BufferedWriter(new FileWriter( a.txt ))) cfout.println( hello ) Komutunu kullanabiliriz. Bu komut hello string değişkenini a.txt dosyasına yazdırır. Dosya veya ekrandan okumak için ise paralel olarak BufferedReader, FileReader ve InputStreamReader sınıflarını kullanabiliriz. BufferedReader sınıfının tanımı public class BufferedReader extends Reader { public BufferedReader(Reader giriş,int boyut) public BufferedReader(Reader giriş) public int read(char c[],int off,int len) throws IOException public int read() throws IOException public String readLine() throws IOException public long skip(long n) throws IOException public boolean ready() throws IOException public boolean markSupported() public void mark(int readAheadLimit) throws IOException public void reset() throws IOException public void close() throws IOException } BufferedReader ve FileReader sınıflarını birarada kullanarak bir okuma kanalı açabiliriz. örneğin a.txt dosyasından okumak için BufferedReader cfin=new BufferedReader(new FileReader( a.txt )) deyimini kullanabiliriz. * class YazOku { public static void main (String args[]) throws IOException { String s1= ilk deger String s2= ilk deger String s3= ilk deger PrintWriter cfout=new PrintWriter(new BufferedWriter(new FileWriter( a.txt ))) cfout.println( Merhaba ) cfout.println( isminiz nedir ) cfout.println( sizinle tanistigima memnun oldum ) cfout.close() BufferedReader cfin=new BufferedReader(new FileReader( a.txt )) s1=cfin.readLine() s2=cfin.readLine() s3=cfin.readLine() cfin.close() System.out.println( s1 = +s1) System.out.println( s2 = +s2) System.out.println( s3 = +s3) } } Program çıktısı s1 = Merhaba s2 = isminiz nedir s3 = sizinle tanistigima memnun oldum dosya a.txt Merhaba isminiz nedir sizinle tanistigima memnun oldum Şeklinde olacaktır. Programımız a.txt dosyasını oluşturup, üç string değerini yazdıktan sonra okuma kanalı açarak bu veriyi okudu. Ancak bu araçların kullanımları çok basit olmadığından programlamaya yeni başlayanlar için bir engel teşkil edebilirler. Text sınıfı bu karmaşıklığı arka plandaki sınıfların içine gizlemek amacıyla geliştirilmiştir. Burada Text sınıfını kullanarak girdi çıktı yapılması örnekleriyle verilecektir. Ekrandan tek bir veri okumak için import java.io. * public class SCO12E {public static void main(String[] args) throws IOException {BufferedReader cin=new BufferedReader(new InputStreamReader(System.in)) double number=Text.readDouble(cin) System.out.println(number) }} * public class SCO12D { public static void main(String[] args) throws IOException { double number Text cin=new Text() number=cin.readDouble() System.out.println(number) }} örneklerinde görülen işlemler uygulanabilir. * public class SCO12F {public static void main(String[] args) throws IOException { BufferedReader fin=new BufferedReader(new FileReader( girdi.txt )) double number=Text.readDouble(fin) System.out.println(number) }} * public class SCO12G {public static void main(String[] args) throws IOException { Text cin=new Text( girdi.txt ) double number=cin.readDouble() System.out.println(number) }} Örneklerinde görülen işlemler uygulanabilir. * public class SCO12H {public static void main(String[] args) throws IOException { double number[][]=Text.readDouble( girdi.txt ) }} işlemi kullanılır. * public class SCO12I {public static void main(String[] args) throws IOException { double number[][]=Text.readDouble(3) }} değerler her satır için açılan pencereden veriler arasında bir boşluk bırakarak girilir. Üstte verilen program parçacığında satır sayısı 3 dür, sütun sayısını birinci satıra girilen veri sayısı tayin eder. * public class SCO12J {public static void main(String[] args) throws IOException { double number[][]=Text.readDouble(3,4) }} Üstte verilen program parçacığında satır sayısı 3 dür, sütun sayısı 4 tür. Satıra girilen veri sayısı daha fazla olduğunda ihmal edilir. * import javax.swing. * public class SCO12M {public static void main(String[] args) throws IOException { double A[][]=Text.readDouble_TextArea(3,3) }} şeklindir. Veri ekrana direk olarak girilir. Her satırdan sonra return  tuşuna basmak gerekir. Veriyi girdikten sonra alttaki düğmeye bastığımızda veri A boyutlu değişkenine aktarılır. İstenilen matris boyutunu programın içinde tanımlamak yerine girişte grafik ortamında tanımlama istersek içi boş readDouble_TextArea() metodu kullanırız. Bu metod önce boyut tanımlama penceresi açar. * import javax.swing. * public class SCO12L {public static void main(String[] args) throws IOException,Throwable { double A[][]=Text.readDouble_TextArea() Text.print(A) }} Program çıktısı almak için bir üstteki aynı pencere açılır. * import javax.swing. * public class SCO12N {public static void main(String[] args) throws IOException { double A[][]=Text.readDouble_Table(3,3) Text.print(A) }} tablo formatındadır. Bu pencerede return komutu her seferinde bir alt satıra geçtiğinden veriyi sütunlar halinde girmek daha kolaydır. Veriyi girdikten sonra alttaki düğmeye bastığımızda veri A boyutlu değişkenine aktarılır. * import javax.swing. * public class SCO12O {public static void main(String[] args) throws IOException { double A[][]=Text.readDouble_Table() Text.print(A) }} içi boş readDouble_Table() metodu kullanırız. Bu metod önce boyut tanımlama penceresi açar. Program çıktısı almak için bir üstteki aynı pencere açılır. . * public class SCO12B {public static void main(String[] args) {double A[][]=Text.readDouble( R134a_S_TPln.txt ) Text.print(A) }} şeklinde oluşacaktır. Buradaki başlıkları da kendimiz verebiliriz. * public class SCO12B1 {public static void main(String[] args) {double A[][]=Text.readDouble( R134a_S_TPln.txt ) String baslik[]={ x ekseni , y ekseni } String genelbaslik= R134a_S_TPln.txt verisi Text.print(A,baslik,genelbaslik) }} durumunu alacaktır. Bir üstte dosyadan okuma ve ekrana bastırma iki kademeli işlemini tek kademede de yapabiliriz. * public class SCO12C {public static void main(String[] args) {String baslik[]={ Sıcaklık C , log(Basınç, kPa) } String genelbaslik= R134a_S_TPln.txt verisi Text.print( R134a_S_TPln.txt ,baslik,genelbaslik) }} Son olarak da birden fazla verimiz (matrisimiz) olduğunda bu verilerin hepsini aynı pencerede görmek istediğimizde nasıl yapacağımıza bir göz atalım. Burada Tüm verinin JPanel sınıfı x değişkeninde toplanmasını istiyoruz. Toplanan veri en sonunda Text.print(x,s1) metodu tarafından ekrana aktarılır. Bu metodu kullanmadan önce istediğimiz miktarda veriyi arka arkaya Text.add komutunu kullanarak sıralayabiliriz. Text sınıfında oluşan çıktı pencerelerinden veriyi direk olarak alabiliriz. Bunun için veriyi fare ile seçtikten sonra <Ctrl>C tuşuyla kopyalamak ve bir text dosyası açarak <Ctrl>V tuşuyla yapıştırmak kafidir. Yukarıda bahsi geçen programı kullanabilmek için gerekli sınıflar altta listelenmiştir. * import java.util. * import javax.swing. * import javax.swing.table. * import java.awt. * class Text { BufferedReader in /* --------------------------------------------------Static routines provided are --------------------------------------------------public static void prompt(String s) public static int readInt(BufferedReader in) public static double readDouble(BufferedReader in) public static String readString(BufferedReader in) public static char readChar(BufferedReader in) ---------------------------------------------------Dynamic routines provided are ---------------------------------------------------public void Text() public void Text(String s1) public void Text(File f1) public int readInt() public double readDouble() public String readString() public char readChar() Sample use --------- reading a double-------------BufferedReader cin=new BufferedReader(new InputStreamReader(System.in)) double number number=Text.readDouble(cin) veya double number Text cin=new Text() number=cin.readDouble() ------ reading data from a file datafile.dat -----double number BufferedReader fin=new BufferedReader(new FileReader( datafile.dat )) double number number=Text.readDouble(fin) veya double number Text cin=new Text( dataFile.dat ) number=cin.readDouble() ------ reading double array data from a file datafile.dat -----double a[][]=Text.readDouble( datafile.dat ) ------ reading double array data from screen -----double a[][]=Text.readDouble(3) double a[][]=Text.readDouble(3,4) double a[][]=Text.readDouble_TextArea(3,4) double a[][]=Text.readDouble_TextArea() double a[][]=Text.readDouble_Table(3,4) double a[][]=Text.readDouble_Table() ------ displaying array data from screen -----double a[][]=new double{{1,2,3},{4,5,6},{7,8,9}} String heading={ column 1 , column 2 ,column 3 } Text.print(a) Text.print(a'heading) Text.print( datafile.dat ,heading) Text.print( datafile.dat ) double a[][]=Text.readDouble(3,4) ------ printing data into a file printfile.dat ---doub PrintStream fout=new PrintStream (new FileOutputStream( printfile.dat )) String a= turhan fout.println(a) veya BufferedWriter fout=new BufferedWriter(new FileWriter( datafile.dat )) String a= Turhan ) fout.println(a) ---------------------------------------------------*/ private static StringTokenizer T private static String S public Text() { in=new BufferedReader(new InputStreamReader(System.in)) } public Text(String s1) throws IOException { in=new BufferedReader(new FileReader(s1)) } public static void prompt (String s) { System.out.print(s + ) System.out.flush() } public int readInt() throws IOException {return Text.readInt(in) } public double readDouble() throws IOException {return Text.readDouble(in) } public String readString() throws IOException {return Text.readString(in) } public char readChar() throws IOException {return Text.readChar(in) } public static int readInt (BufferedReader in) throws IOException { if (T==null) refresh(in) while (true) { try { String item = T.nextToken() return Integer.valueOf(item.trim()).intValue() } catch (NoSuchElementException e1) { refresh (in) } catch(NumberFormatException e2) { //System.err.println( Error in number, try again. ) } } } public static char readChar (BufferedReader in) throws IOException { if (T==null) refresh(in) while (true) { try { return T.nextToken().charAt(0) } catch(NoSuchElementException e1) {refresh (in) } } } public static double readDouble(BufferedReader in) throws IOException { if(T==null) refresh(in) while (true) { try { String item = T.nextToken() return Double.valueOf (item.trim()).doubleValue() } catch(NoSuchElementException e1) { refresh (in) } catch(NumberFormatException e2) { //System.err.println( Error in number, try again. ) } } } public static String readString(BufferedReader in) throws IOException { if(T==null) refresh (in) while (true) { try {return T.nextToken() } catch (NoSuchElementException e1) { refresh (in) } } } public static String readStringLine(BufferedReader in) throws IOException { //reads a line of strings from BufferedReader in int ch String r = boolean done = false while (.done) { try { ch = in.read() if(ch < 0 || (char)ch == '\n' || (char)ch == '\0') done = true else r = r + (char) ch } catch(java.io.IOException e) { done = true } } return r.substring(0,(r.length()-1)) } public static String readStringLine(String s) { xi.add(s2) } i=0 while(fin .= null) { i++ String s11=Text.readStringLine(fin) //System.out.println(s11) if(s11== ) break StringTokenizer token1=new StringTokenizer(s11) while(token1.hasMoreTokens()) { String s2=token1.nextToken() xi.add(s2) } } } catch(ArrayIndexOutOfBoundsException e_eof) { } } catch(StringIndexOutOfBoundsException e_eof) { } } catch(EOFException e_eof) {System.out.println( end of file ) } } catch(NumberFormatException e_nfe) {System.out.println( non-number input ) } } catch(IOException e_io) {System.out.println( file name is not existed ) } nn=i //System.out.println( m= +m+ nn= +nn) double aa[][]=new double[nn][m] Enumeration nx=xi.elements() for(i=0 i<nn i++) { for(int j=0 j<m j++) { String s1=(String)nx.nextElement() Double ax=new Double(s1) aa[i][j]=ax.doubleValue() } } return aa } public static double[][] readDoubleT(String filename) {//veriyi ters matris olarak okur(satir ve sutun degisir) double a[][]=readDouble(filename) int n=a.length int m=a[0].length double b[][]=new double[m][n] for(int i=0 i<n i++) { for(int j=0 j<m j++) { b[j][i]=a[i][j] } } return b } public static double[][] readDouble(int n,int m) { String s= line 0 String s1=JOptionPane.showInputDialog(s) StringTokenizer token=new StringTokenizer(s1) double a[][]=new double[n][m] int j=0 for(j=0 j<m j++) {Double ax=new Double(token.nextToken()) a[0][j]=ax.doubleValue() } for(int i=1 i<n i++) { s= line +i s1=JOptionPane.showInputDialog(s) token=new StringTokenizer(s1) j=0 for(j=0 j<m j++) {Double ax=new Double(token.nextToken()) a[i][j]=ax.doubleValue() } } return a } public static double[][] readDouble(int n) { // column number determined by number of data entered in first column String s= line 0 String s1=JOptionPane.showInputDialog(s) StringTokenizer token=new StringTokenizer(s1) int nn=token.countTokens()-1 int m=nn+1 double a[][]=new double[n][m] int j=0 while(token.hasMoreTokens()) { Double ax=new Double(token.nextToken()) a[0][j++]=ax.doubleValue() } for(int i=1 i<n i++) { s= line +i s1=JOptionPane.showInputDialog(s) token=new StringTokenizer(s1) for(j=0 j<m j++) {Double ax=new Double(token.nextToken()) a[i][j]=ax.doubleValue() } } return a } public static double[] readDoubleV() { // column number determined by number of data entered in first column String s= line 0 String s1=JOptionPane.showInputDialog(s) StringTokenizer token=new StringTokenizer(s1) int nn=token.countTokens()-1 int m=nn+1 double a[]=new double[m] int j=0 while(token.hasMoreTokens()) { Double ax=new Double(token.nextToken()) a[j++]=ax.doubleValue() } return a } public static double[] readDoubleV(String s) { // column number determined by number of data entered in first column String s1=JOptionPane.showInputDialog(s) StringTokenizer token=new StringTokenizer(s1) int nn=token.countTokens()-1 int m=nn+1 double a[]=new double[m] int j=0 while(token.hasMoreTokens()) { Double ax=new Double(token.nextToken()) a[j++]=ax.doubleValue() } return a } public static double[][] readDouble_TextArea(int n,int m) { girdi g=new girdi(n,m) double a[][]=g.vericiktisi() return a } public static fa return2Dfunction() {createfunction() fa ff=new fa() return ff } public static fa return2Dfunction(String fonksiyon) {createfunction(fonksiyon) fa ff=new fa() return ff } public static String createfunction() { girdi2 g=new girdi2( fa , ) String s=g.vericiktisi() try{ g.finalize() } catch(Throwable e1) {System.err.println( girdi hatası. ) } return s } public static String createfunction(String function) { functiongenerator g=new functiongenerator( fa ,function) String s=g.createfunction() try{ g.finalize() } catch(Throwable e1) {System.err.println( girdi hatası. ) } return s } public static String create3Dfunction() { girdi3 g=new girdi3( fb , ) String s=g.vericiktisi() try{g.finalize() } catch(Throwable e1) {System.err.println( girdi hatası. ) } return s } public static String create3Dfunction(String fonksiyon) { functiongenerator3D g=new functiongenerator3D(fonksiyon) String s=g.createfunction() try{ g.finalize() } catch(Throwable e1) {System.err.println( girdi hatası. ) } return s } public static double[][] readDouble_TextArea() { String s1=JOptionPane.showInputDialog( n(satır) ve m(sütun) boyutlarını veriniz ) StringTokenizer token=new StringTokenizer(s1) Integer ax=new Integer(token.nextToken()) int n=ax.intValue() ax=new Integer(token.nextToken()) int m=ax.intValue() girdi g=new girdi(n,m) double a[][]=g.vericiktisi() return a } public static double[][] readDouble_Table(int n,int m) { girdi1 g=new girdi1(n,m) double a[][]=g.vericiktisi() return a } public static double[][] readDouble_Table() { String s1=JOptionPane.showInputDialog( n(satır) ve m(sütun) boyutlarını veriniz ) StringTokenizer token=new StringTokenizer(s1) Integer ax=new Integer(token.nextToken()) int n=ax.intValue() ax=new Integer(token.nextToken()) int m=ax.intValue() girdi1 g=new girdi1(n,m) double a[][]=g.vericiktisi() return a } * import java.awt.event. * import javax.swing. * import javax.swing.table. * import javax.swing.event. * import java.io. * import java.util. * class genelModel extends AbstractTableModel implements TableModelListener { Object[][] veri String[] baslik public genelModel(Object[][] verii,String basliki[]) { int n=veri.length int m=veri[0].length veri=new Object[n][m] baslik=new String[m] for(int j=0 j<m j++) {for(int i=0 i<n i++) {veri[i][j]=verii[i][j] } baslik[j]=basliki[j] } addTableModelListener(this) } public genelModel(Object[][] verii) { int n=veri.length int m=veri[0].length veri=new Object[n][m] baslik=new String[m] for(int j=0 j<m j++) {for(int i=0 i<n i++) {veri[i][j]=verii[i][j] } baslik[j]= +j } } public genelModel(int n,int m) { veri=new Object[n][m] baslik=new String[m] /* for(int j=0 j<m j++) {for(int i=0 i<n i++) {veri[i][j]=(Object) } } */ } public genelModel(double[][] verii) { int n=verii.length int m=verii[0].length veri=new Object[n][m] baslik=new String[m] veri=doubletoDouble(verii) for(int j=0 j<m j++) baslik[j]= +j } public genelModel(double[][] verii,String basliki[]) { int n=verii.length int m=verii[0].length int m1=basliki.length veri=new Object[n][m] baslik=new String[m] veri=doubletoDouble(verii) if(m1>=m) { for(int j=0 j<m j++) baslik[j]=basliki[j] } else { for(int j=0 j<m1 j++) baslik[j]=basliki[j] for(int j=m1 j<m j++) baslik[j]= +j } } public genelModel(String filename) { double a[][]=readDouble(filename) int n=a.length int m=a[0].length veri=new Object[n][m] baslik=new String[m] veri=doubletoDouble(a) for(int j=0 j<m j++) baslik[j]= +j } public genelModel(String filename,String basliki[]) { double a[][]=readDouble(filename) int n=a.length int m=a[0].length veri=new Object[n][m] baslik=new String[m] veri=doubletoDouble(a) for(int j=0 j<m j++) baslik[j]=basliki[j] } public static Double[][] doubletoDouble(double xi[][]) { int n=xi.length int m=xi[0].length Double X[][]=new Double[n][m] for(int j=0 j<m j++) {for(int i=0 i<n i++) {X[i][j]=new Double(xi[i][j]) } } return X } public static double[][] readDouble(String filename) { //veriyi oku bu metodun verisayısı sınırı yoktur //istediğimiz uzunluktaki veriyi okuyabilir Vector xi=new Vector() int nn int m=2 int i=0 BufferedReader fin try{ fin=new BufferedReader(new FileReader(filename)) try { try{ try{ String s1=Text.readStringLine(fin) //System.out.println(s1) StringTokenizer token=new StringTokenizer(s1) int n=token.countTokens()-1 m=n+1 //m tokens boyutludeğişken kolon sayısı while(token.hasMoreTokens()) { String s2=token.nextToken() xi.add(s2) } i=0 while(fin .= null) { i++ String s11=Text.readStringLine(fin) //System.out.println(s11) if(s11== ) break StringTokenizer token1=new StringTokenizer(s11) while(token1.hasMoreTokens()) { String s2=token1.nextToken() xi.add(s2) } } } catch(ArrayIndexOutOfBoundsException e_eof) { } } catch(StringIndexOutOfBoundsException e_eof) { } } catch(EOFException e_eof) {System.out.println( end of file ) } } catch(IOException e_io) {System.out.println( file name is not existed ) } nn=i //System.out.println( m= +m+ nn= +nn) double aa[][]=new double[nn][m] Enumeration nx=xi.elements() for(i=0 i<nn i++) { for(int j=0 j<m j++) { String s1=(String)nx.nextElement() Double ax=new Double(s1) aa[i][j]=ax.doubleValue() } } return aa } public int getRowCount() {return veri.length } public int getColumnCount() {return baslik.length } public Object getValueAt(int satir,int sutun) {return veri[satir][sutun] } public String getColumnName(int c) {return baslik[c] } public void setValueAt(Object val, int row, int col) {veri[row][col] = val } public void setValues(String filename) {veri=doubletoDouble(readDouble(filename)) } public void tableChanged(TableModelEvent e) { } public double[][] todouble() { int n=veri.length int m=veri[0].length double x[][]=new double[n][m] for(int j=0 j<m j++) {for(int i=0 i<n i++) {x[i][j]=Double.parseDouble((String)(veri[i][j])) } } return x } public void setValues(double xi[][],String[] basliki) { int n=xi.length int m=xi[0].length Double X[][]=new Double[n][m] for(int j=0 j<m j++) {for(int i=0 i<n i++) {X[i][j]=new Double(xi[i][j]) } baslik[j]=basliki[j] } veri=X } public Object[][] getValues(){return veri } public boolean isCellEditable(int row, int col) {return true } } * import java.awt.event. * import javax.swing. * import javax.swing.table. * import javax.swing.event. * import java.io. * import java.util. * class genelModel extends AbstractTableModel implements TableModelListener { Object[][] veri String[] baslik public genelModel(Object[][] verii,String basliki[]) { int n=veri.length int m=veri[0].length veri=new Object[n][m] baslik=new String[m] for(int j=0 j<m j++) {for(int i=0 i<n i++) {veri[i][j]=verii[i][j] } baslik[j]=basliki[j] } addTableModelListener(this) } public genelModel(Object[][] verii) { int n=veri.length int m=veri[0].length veri=new Object[n][m] baslik=new String[m] for(int j=0 j<m j++) {for(int i=0 i<n i++) {veri[i][j]=verii[i][j] } baslik[j]= +j } } public genelModel(int n,int m) { veri=new Object[n][m] baslik=new String[m] /* for(int j=0 j<m j++) {for(int i=0 i<n i++) {veri[i][j]=(Object) } } */ } public genelModel(double[][] verii) { int n=verii.length int m=verii[0].length veri=new Object[n][m] baslik=new String[m] veri=doubletoDouble(verii) for(int j=0 j<m j++) baslik[j]= +j } public genelModel(double[][] verii,String basliki[]) { int n=verii.length int m=verii[0].length int m1=basliki.length veri=new Object[n][m] baslik=new String[m] veri=doubletoDouble(verii) if(m1>=m) { for(int j=0 j<m j++) baslik[j]=basliki[j] } else { for(int j=0 j<m1 j++) baslik[j]=basliki[j] for(int j=m1 j<m j++) baslik[j]= +j } } public genelModel(String filename) { double a[][]=readDouble(filename) int n=a.length int m=a[0].length veri=new Object[n][m] baslik=new String[m] veri=doubletoDouble(a) for(int j=0 j<m j++) baslik[j]= +j } public genelModel(String filename,String basliki[]) { double a[][]=readDouble(filename) int n=a.length int m=a[0].length veri=new Object[n][m] baslik=new String[m] veri=doubletoDouble(a) for(int j=0 j<m j++) baslik[j]=basliki[j] } public static Double[][] doubletoDouble(double xi[][]) { int n=xi.length int m=xi[0].length Double X[][]=new Double[n][m] for(int j=0 j<m j++) {for(int i=0 i<n i++) {X[i][j]=new Double(xi[i][j]) } } return X } public static double[][] readDouble(String filename) { //veriyi oku bu metodun verisayısı sınırı yoktur //istediğimiz uzunluktaki veriyi okuyabilir Vector xi=new Vector() int nn int m=2 int i=0 BufferedReader fin try{ fin=new BufferedReader(new FileReader(filename)) try { try{ try{ String s1=Text.readStringLine(fin) //System.out.println(s1) StringTokenizer token=new StringTokenizer(s1) int n=token.countTokens()-1 m=n+1 //m tokens boyutludeğişken kolon sayısı while(token.hasMoreTokens()) { String s2=token.nextToken() xi.add(s2) } i=0 while(fin .= null) { i++ String s11=Text.readStringLine(fin) //System.out.println(s11) if(s11== ) break StringTokenizer token1=new StringTokenizer(s11) while(token1.hasMoreTokens()) { String s2=token1.nextToken() xi.add(s2) } } } catch(ArrayIndexOutOfBoundsException e_eof) { } } catch(StringIndexOutOfBoundsException e_eof) { } } catch(EOFException e_eof) {System.out.println( end of file ) } } catch(IOException e_io) {System.out.println( file name is not existed ) } nn=i //System.out.println( m= +m+ nn= +nn) double aa[][]=new double[nn][m] Enumeration nx=xi.elements() for(i=0 i<nn i++) { for(int j=0 j<m j++) { String s1=(String)nx.nextElement() Double ax=new Double(s1) aa[i][j]=ax.doubleValue() } } return aa } public int getRowCount() {return veri.length } public int getColumnCount() {return baslik.length } public Object getValueAt(int satir,int sutun) {return veri[satir][sutun] } public String getColumnName(int c) {return baslik[c] } public void setValueAt(Object val, int row, int col) {veri[row][col] = val } public void setValues(String filename) {veri=doubletoDouble(readDouble(filename)) } public void tableChanged(TableModelEvent e) { } public double[][] todouble() { int n=veri.length int m=veri[0].length double x[][]=new double[n][m] for(int j=0 j<m j++) {for(int i=0 i<n i++) {x[i][j]=Double.parseDouble((String)(veri[i][j])) } } return x } public void setValues(double xi[][],String[] basliki) { int n=xi.length int m=xi[0].length Double X[][]=new Double[n][m] for(int j=0 j<m j++) {for(int i=0 i<n i++) {X[i][j]=new Double(xi[i][j]) } baslik[j]=basliki[j] } veri=X } public Object[][] getValues(){return veri } public boolean isCellEditable(int row, int col) {return true } } * import java.awt.event. * import javax.swing. * import javax.swing.table. * import javax.swing.event. * import java.io. * import java.util. * } } * import java.awt.Window public class BasicWindowMonitor extends WindowAdapter { public void windowClosing(WindowEvent e) { Window w=e.getWindow() w.setVisible(false) w.dispose() System.exit(0) } } Bu işlem İngilizce de sayıya dönüştürme veya sayısallaştırma adı verilen digitizing kavramı ile verilir. Çeşitli proseslerde kullanacağımızdan dolayı bu işlemle ilgili bir örnek programı vermekte yarar görüyoruz. * import java.applet.Applet import java.awt. * import java.awt.event. * import java.util. * import javax.swing. * import javax.swing.table. * import java.awt. * import java.awt.event. * import javax.swing.event. * import java.awt.geom. * import java.util. * public class scanP extends JPanel implements MouseListener,MouseMotionListener,MouseWheelListener { int x1[],y1[] public JLabel jp public double a[][] int n boolean mousemoved Rectangle2D l Ellipse2D l1,l2 Color c Image img public PrintWriter fout String dosya //BufferedWriter fout double xmin,xmax,ymin,ymax int xcmin,xcmax,ycmin,ycmax public scanP(String p1, String idosya,double ixmin,double ixmax,double iymin,double iymax) {super() dosya=idosya try {fout=new PrintWriter(new BufferedWriter(new FileWriter(dosya))) } catch(IOException e1) {System.err.println( girdi hatası. ) xcmin=(int)xmin ycmin=(int)ymin xcmax=(int)xmax ycmax=(int)ymax x1=new int[1000] y1=new int[1000] a=new double[2][1000] n=-2 addMouseListener(this) addMouseMotionListener(this) addMouseWheelListener(this) mousemoved=false } public void setMinMax(double ixmin,double ixmax,double iymin,double iymax) { xmin=ixmin xmax=ixmax ymin=iymin ymax=iymax } public JLabel getLabel() { return jp } public void setDosyaismi(String Di) { dosya=Di try {fout=new PrintWriter(new BufferedWriter(new FileWriter(dosya))) } catch(IOException e1) {System.err.println( girdi hatası. ) Text.print(dosya, digitize çıktı verisi +dosya+ dosyası ) mousemoved=true } } public void mousePressed(MouseEvent e) { if(e.isMetaDown()) {mouseclose() } //sağ tuş basıldığında else if(e.isAltDown()) //orta tuş basıldığında {} else { setCizgi(e.getX(),e.getY()) n++ repaint() } //sol tuş basıldığında } public void mouseReleased(MouseEvent e) {} public void mouseEntered(MouseEvent e) {} public void mouseExited(MouseEvent e) {} //MouseMotionListener (fare hareket dinleyicisi) metotlari public void mouseDragged(MouseEvent e) { } public void mouseMoved(MouseEvent e) { double x1,y1 x1=xmin+(xmax-xmin)/(xcmax-xcmin)*(e.getX()-xcmin) y1=ymin+(ymax-ymin)/(ycmax-ycmin)*(e.getY()-ycmin) jp.setText( x = +x1+ y = +y1) } public void mouseWheelMoved(MouseWheelEvent e) {} } * import java.awt. * import java.awt.event. * import java.io. * import java.awt. * import java.awt.event. * import javax.swing. * import javax.swing.filechooser. Makina Müh.\n s+= =========================================================================================\n s+= Komut yapısı fareye ilk iki basış sırası ile minimum ve maksimum noktayı tanımlar.\n s+= Bu işlemden sonra fare ile (sol düğme) basılan her nokta verilen xmin,xmax,ymin,ymax \n s+= değerlerine göre double değerlere dönüştürülür. Ekranın arka planına istenilen bir resim \n s+= yerleştirilir. Bu resimdeki verilerden yararlanılarak basılan noktaların gerçek değerlere \n s+= dönüştürülmüş eşdeğerleri hesaplanır ve bizim tarafımızdan verilen bir çıktı dosyasına \n s+= kaydedilir. farenin sağ düğmesine basıldığında program durur ve o ana kadar alınan veri dosyaya \n s+= kaydedilir ve ekrana yansıtılır.\n s+= =========================================================================================\n return s } public void actionPerformed(ActionEvent e) { if(e.getSource()==t[0]) { Double V0=new Double(t[0].getText()) public static void main(String s[]) { JFrame f = new digitizerF( digitiser çizim programı ) f.pack() f.setSize(800,1000) f.setVisible(true) } } Ekranda önce minimum ve maksimum noktalarımızı işaretleyerek digitizer programımızı kalibre etmemiz gerekir. Ayrıca maksimum ve minumum noktalarının x ve y koordinat değerleri de programa girilmelidir. Bundan sonra her fareye basışımızda(sol tuş) düzeltilmiş karteziyan koordinat sistemindeki veri alınarak bizim belirttiğimiz dosyaya (dosya belirtmediyseiz a.txt dosyasına) yazılacaktır. Farenin sağ tuşuna basıldığında program duracak ve kaydedilen tüm veriyi (üstte incelediğimiz Text sınıfı üzeriden) ekrana taşıyacaktır. Bu pencereden veriyi kopyeleyebiliriz veya kaydedilen dosya üzerinden herhangi bir program girdisi olarak okuyabiliriz. Bu tür fonksiyonları herhangi bir editöre yazarak ve sonra javac komutuyla derleyerek kullanabiliriz. Örneğin class fa extends f_x { public double func (double x) { double y=Math.cos(x) return y } } Buradaki f_x sınıfı abstract bir sınıftır. abstract class f_x { //single function single independent variable // example f=x*x abstract double func(double x) } Bu yapı bize sayısal yöntemlerimizi abstract sınıf olan f_x cinsinden yazma olasılığını verir. Aynı abstract yapıyı fonksiyonların grafiklerini çizmek için girdi olarak ta kullanılabilir. Eğer daha önce yazılmış programları daha sonra yazılan fonksionlarla kullanmak istersek, bu tür abstract sınıf üzerinden yazılmış fonksiyonları kullanabiliriz. Ancak yeni fonksiyon tanımını yaparken yeni program yazma gereği olması gerçek zamanda proğramı çalıştırırken yeni fonksiyon girdisi oluşturmamızı engelleyen bir yapıdır. Yeni bir fonsiyon oluştuğunda javac komutuyla derlenerek class dosyasının oluşturulması gerekir. Bu sorunun program içinde çözülmesi javax.tools.JavaCompiler ve javax.tools.ToolProvider sınıflarını kullanara çözülebilir. Bu iki sınıfı kullanarak programımızın içinde oluşan bir kodu derleyebiliriz. Bunun için String isim= fa.java JavaCompiler javac = ToolProvider.getSystemJavaCompiler() int rc = javac.run(null, null, null,isim) komutlarını programımızın içinde kullanmamız yeterlidir. Bu komut fa.java dosyasını derleyecektir. fa.java dosyasını program içinde oluşturarak derleyebiliriz. * import javax.swing. * import javax.tools. * import java.util. * import java.lang.Math. Burada oluşturduğumuz program kodunu dosyaya yazdıktan sonra JavaCompiler kulanarak derledi. Bu durumda yeni oluşan fonksiyon kodu direk olarak çalıştırılabilir. * import java.awt.event. * import javax.swing. * import javax.swing.table. * import javax.swing.event. * import java.io. * import java.util. * } } } } * import javax.swing. * import javax.tools. * import java.util. * import java.lang.Integer import java.awt. * import java.awt.event. * import java.awt.font. * import java.awt.geom. * import java.awt.image. * import javax.swing. * import java.util.Locale import java.text. * import java.util. * import javax.swing.table. * import static java.lang.Math. * class ce1 { String s public ce1() {girdi2 g=new girdi2( fa , ) s=g.vericiktisi() try{ g.finalize() } catch(Throwable e1) {System.err.println( girdi hatası. ) } } public ce1(String function) { functiongenerator g=new functiongenerator( fa ,function) s=g.createfunction() try{ g.finalize() } catch(Throwable e1) {System.err.println( girdi hatası. ) } } public static void main(String arg[]) { //String s1=JOptionPane.showInputDialog( Fonksiyonu giriniz ) ce1 x0=new ce1() double a[]=Text.readDoubleV( Fonksiyonun minimum ve maksimum değerlerini giriniz xmin xmax ) ce3 x1=new ce3(a[0],a[1],100,x0.s) //ce8 x2=new ce8(a[0],a[1],x0.s) } } * import javax.swing. * import javax.tools. * import java.util. * import java.lang.Integer import java.awt. * import java.awt.event. * import java.awt.font. * import java.awt.geom. * import java.awt.image. * import javax.swing. * import java.util.Locale import java.text. * import java.util. * import javax.swing.table. * class ce3 extends JApplet { public ce3(double x1,double x2,int n,String s) {Plot pp=new Plot(new fa(),x1,x2,n) pp.setPlabel( f(x)= +s) pp.plot() } public ce3(double x1,double x2,int n) {Plot pp=new Plot(new fa(),x1,x2,n) pp.plot() } public ce3(double x1,double x2) {Plot pp=new Plot(new fa(),x1,x2,50) pp.plot() } } ce2 sınıfı çalıştırıldığında pencerelerinden fonksiyon ve grafik sınır şartlarını girdikten sonra 2 boyutlu grafik çıktısını elde edebiliriz. Görüldüğü gibi burada fonksiyon girdisi oluşturabildik. Burada program içinde program yazmanın bir örneği verilmiş oldu. Bu örneği genelleştirerek her türlü programlama işlemlerimiz için kullanabiliriz. İkinci bir örnek olarak 3boyutlu bir fonksiyon oluşturan functiongnerator3 sınıfını verelim import java.io. * import javax.swing. * import javax.tools. * import java.util. * class functiongenerator3D extends Thread { String fonksiyon String dosyaismi public functiongenerator3D(String dosyaismi,String fonksiyon) { this.fonksiyon=fonksiyon this.dosyaismi=dosyaismi } public functiongenerator3D(String fonksiyon) {this.fonksiyon=fonksiyon dosyaismi= fb } public functiongenerator3D() {fonksiyon= x[0]*x[0]+x[1]*x[1]-4.0 dosyaismi= fb } public void addfunction(String fonksiyon) {this.fonksiyon=fonksiyon } public String toString() {return fonksiyon } public String createfunction() {String isim=dosyaismi+ .java String s= try {PrintWriter fout=new PrintWriter(new BufferedWriter(new FileWriter(isim))) s+= class +dosyaismi+ extends f_xj\n s+= {\n s+= public double func(double w[])\n s+= {//çözümü istenen fonksiyon\n s+= double x=w[0] \n s+= double y=w[1] \n s+= double ff \n s+= ff= +fonksiyon+ \n s+= return ff \n s+= }\n s+= }\n fout.println(s) //System.out.println(s) fout.close() } catch(IOException e1) {System.err.println( girdi hatası. ) } catch(NumberFormatException e2){} JavaCompiler javac = ToolProvider.getSystemJavaCompiler() int rc = javac.run(null, null, null,isim) return s } protected void finalize() throws Throwable {super.finalize() } } Ardışık dosyalar Teyp kaydı şeklinde birbiri ardı sıra gelen bilgilerden oluşur. Rastlantısal Ulaşım sisteminde ise CD gibi herhangi bir kayıta kayıt numarası kullanılarak doğrudan ulaşmak mümkündür. Rastlantısal Ulaşım dosyası işlemleri RandomAccessFile sınıfı üzerinden yapılır. Bu sınıfın tanımı public class RandomAccessFile extends Object implements DataOutput, DataInput { public RandomAccessFile(String name,String mode) throws IOException public RandomAccessFile(File file,String mode) throws IOException public final FileDescriptor getFD() throws IOException public int read() throws IOException public int read(byte b[],int off,int len) throws IOException public int read(byte b[]) throws IOException public final void readFully(byte b[]) throws IOException public final void readFully(byte b[],int off,int len) throws IOException public int skipBytes(int n) throws IOException public void write(int b) throws IOException public void write(byte b[]) throws IOException public void write(byte b[],int off,int len) throws IOException public long getFilePointer() throws IOException public void seek(long pos) throws IOException public void seek(long pos) throws IOException public long length() throws IOException public void close() throws IOException public final byte readByte() throws IOException public final int readUnsignedByte() throws IOException public final short readShort() throws IOException public final int readUnsignedShort() throws IOException public final char readChar() throws IOException public final int readInt() throws IOException public final long readLong() throws IOException public final float readFloat() throws IOException public final double readDouble() throws IOException public final String readLine() throws IOException public final String readUTF() throws IOException public final void writeBoolean(boolean v) throws IOException public final void writeByte(int v) throws IOException public final void writeShort(int v) throws IOException public final void writeChar(int v) throws IOException public final void writeInt(int v) throws IOException public final void writeLong(long v) throws IOException public final void writeFloat(float v) throws IOException public final void writeDouble(double v) throws IOException public final void writeBytes(String s) throws IOException public final void writeChars(String s) throws IOException public final void writeUTF(String str) throws IOException } Burada tanımlanan metodların görevlerine kısaca bir bakacak olursak getFD() dosya (File) tanımını verir getFilePointer() Dosyanın (File) o anda hangi dosya referansını gösterdiğini belirtir. length() Dosyadaki toplam referans sayısını verir. read() Byte (char değişkeni karşılığı) olarak dosyadan bilgiyi okur (bir byte). read(byte[]) Byte (char değişkeni karşılığı) olarak dosyadan bilgiyi okur (byte[] değişkeninin boyu kadar) ve byte degişkenine aktarır. read(byte[], int baslangıç_indisi, int indis_boyutu) Byte (char değişkeni karşılığı) olarak dosyadan bilgiyi okur (byte[] değişkeninin boyu kadar, başlangıç indisinden başlayarak, indis_boyutu uzunluğunda) ve byte degişkenine aktarır. readBoolean() boolean değişken okur readByte() dosyadan integer tipi byte değişken (işaretli 8-bit ) okur. readChar() Dosyadan Unicode karekter (character) okur. readDouble() Dosyadan double değişkeni okur. readFloat() Dosyadan float değişkeni okur. readFully(byte[] b) dosyadan byte olarak okur readFully(byte[] b, int baslangıç_indisi, int toplam_boy) dosyadan bte olarak sadece byte boyutlu değişkeninin başlangıc_indisi'nden başlamak üzere taplam_boy kadar kısmını okur. readInt() Dosyadan int değişkeni okur. readLine() Dosyadan \n = yeni satır işaretini veya \r satırbaşı işaretini veya herikisini birden arka arkaya görene kadar yazılan her şeyi bütün bir satır olarak okur. readLong() Dosyadan Long (Long integer) değişkeni okur. readShort() Dosyadan Short (Short integer) değişkeni okur. readUnsignedByte() İşaretsiz Byte değeri okur. readUnsignedShort() İşaretsiz 16 bitlik Short integer değeri okur. skipBytes(int n) n bit input değerini okumadan atlar Aşağıdaki tanımlar read tanımlarına parelel olan write terimleridir. write(byte[]) byte boyutlu değişkenini yazar. write(byte[],int baslangıç_indisi, int toplam_boy) dosyaya byte olarak sadece byte boyutlu değişkeninin başlangıc_indisi'nden başlamak üzere taplam_boy kadar kısmını yazar. write(int) dosyaya byte boyutlu değişkenini yazar writeBoolean(boolean) dosyaya boolean boyutlu değişkenini yazar writeByte(int) dosyaya int girdisini byte olarak yazar writeBytes(String) dosyaya String girdisini byte boyutlu değişkeni olarak yazar writeChar(int) dosyaya int girdisini Char olarak yazar writeChars(String) dosyaya string girdisini char boyutlu değişkeni olarak yazar writeDouble(double) dosyaya double girdisini double olarak yazar. writeFloat(float) dosyaya float girdisini float olarak yazar writeInt(int) dosyaya int girdisini int olarak yazar. writeLong(long) dosyaya long(integer) girdisini long(integer) olarak yazar writeShort(int) dosyaya integer gidisini short(integer) olarak yazar. RandomAccessFile sınıfının tanımından da görüldüğü gibi b sınıf DataOutput ve DataInput sınıflarını implement eder. DataOutput ve DataInput sınıflarınını tanımı public interface DataOutput { public abstract void write(int b) throws IOException public abstract void write(byte b[]) throws IOException public abstract void write(byte b[],int off,int len) throws IOException public abstract void writeBoolean(boolean v) throws IOException public abstract void writeByte(int v) throws IOException public abstract void writeShort(int v) throws IOException public abstract void writeChar(int v) throws IOException public abstract void writeInt(int v) throws IOException public abstract void writeLong(long v) throws IOException public abstract void writeFloat(float v) throws IOException public abstract void writeDouble(double v) throws IOException public abstract void writeBytes(String s) throws IOException public abstract void writeChars(String s) throws IOException public abstract void writeUTF(String str) throws IOException } public interface DataInput { public abstract void readFully(byte b[]) throws IOException public abstract void readFully(byte b[],int off,int len) throws IOException public abstract int skipBytes(int n) throws IOException public abstract boolean readBoolean() throws IOException public abstract byte readByte() throws IOException public abstract int readUnsignedByte() throws IOException public abstract short readShort() throws IOException public abstract int readUnsignedShort() throws IOException public abstract int readInt() throws IOException public abstract long readLong() throws IOException public abstract float readFloat() throws IOException public abstract double readDouble() throws IOException public abstract String readLine() throws IOException public abstract String readUTF() throws IOException } RandomAccessFile Çok daha çabuk ulaşım olanakları yaratır. Raslantısal Ulaşım dosyası örneği olarak aşağıdaki paketi veriyoruz. Kayit sınıfı tek bir kayıtın yazılıp okunabilmesi için gerekli olan bilgileri içeriyor. Kayıtların hesap numarası, isim, soyisim ve hesaptaki paradan oluştuğunu kabul ediyoruz. Bütün bu kayıtları bir arada yapmak için oku ve yaz metotları bu sınıfın içindr tanımlanmıştır. Raslantısal ulaşım kanalının dosyaya açılması için try{ girdi=new RandomAccessFile( musteri1.dat , rw ) } catch(IOException e) { System.err.println( Dosya acma hatasi\n +e.toString()) System.exit(1) } yapısı kullanbilir. Buradaki rw yapısı dosyaya hem yazı yazılıp hem okunabileceğini belirtir. r sadece okumak için w sadece yazmak için kullanılır. RandomAccessFile içinde yer alan close() metodu RandomAccessFile (Raslantısal Ulaşım Dosyası) kanalını ve ilgili tüm sınıfları kapatır. örnek olarak private void closeFile() { try{ girdi.close() System.exit(0) } catch(IOException e) { System.err.println( Error closing filr\n +e.toString()) System.exit(1) } } metotu verilebilir. * public class Kayit { private int hesap private String soyIsim private String Isim private double hesaptakiPara public void oku(RandomAccessFile dosya) throws IOException { //RandomAccessFile = Raslantisal Ulasim dosyasi hesap=dosya.readInt() char first[]=new char[15] for(int i=0 i<first.length i++) { first[i]=dosya.readChar() } Isim=new String(first) char last[]=new char[15] for(int i=0 i<first.length i++) { last[i]=dosya.readChar() } soyIsim=new String(last) hesaptakiPara=dosya.readDouble() } public void yaz(RandomAccessFile dosya) throws IOException { StringBuffer buf dosya.writeInt(hesap) if(Isim.=null) buf=new StringBuffer(Isim) else buf=new StringBuffer(15) buf.setLength(15) dosya.writeChars(buf.toString()) if(soyIsim.=null) buf=new StringBuffer(soyIsim) else buf=new StringBuffer(15) buf.setLength(15) dosya.writeChars(buf.toString()) dosya.writeDouble(hesaptakiPara) } public void yazhesap(int a) {hesap = a } public int okuhesap() {return hesap } public void yazIsim(String f){Isim=f } public String okuIsim() {return Isim } public void yazsoyIsim(String f){soyIsim=f } public String okusoyIsim() {return soyIsim } public void yazhesaptakiPara(double b) {hesaptakiPara=b } public double okuhesaptakiPara() {return hesaptakiPara } public static int boyut() {return 72 } } * import java.awt. * import java.awt.event. * import Kayit public class RaslantisalUlasimDosyasiYarat { private Kayit hesapDosyasi private RandomAccessFile girdi public RaslantisalUlasimDosyasiYarat() { hesapDosyasi = new Kayit() try{ girdi = new RandomAccessFile( musteri1.dat , rw ) for(int i=0 i<100 i++) { hesapDosyasi.yaz(girdi) } } catch(IOException e) { System.err.println( Dosya acma hatasi\n +e.toString()) System.exit(1) } } public static void main(String args[]) { RaslantisalUlasimDosyasiYarat H= new RaslantisalUlasimDosyasiYarat() } } * import java.awt. * import java.awt.event. * import Kayit public class RaslantisalUlasimDosyasiYaz extends Frame implements ActionListener { private TextField hesapAlani,isimAlani,soyisimAlani,hesaptakiParaAlani private Button birsonraki,kapat private RandomAccessFile girdi private Kayit hesapDosyasi public RaslantisalUlasimDosyasiYaz() { super( Tesadufi ulasim dosyasina yaz ) hesapDosyasi=new Kayit() try{ girdi=new RandomAccessFile( musteri1.dat , rw ) } catch(IOException e) { System.err.println( Dosya acma hatasi\n +e.toString()) System.exit(1) } setSize(300,150) setLayout(new GridLayout(5,2)) add(new Label( Hesap numarasi )) hesapAlani=new TextField() add(hesapAlani) add(new Label( isim )) isimAlani=new TextField(20) add(isimAlani) add(new Label( Soyisim )) soyisimAlani=new TextField(20) add(soyisimAlani) add(new Label( Hesaptaki para )) hesaptakiParaAlani=new TextField(20) add(hesaptakiParaAlani) birsonraki=new Button( Gir ) birsonraki.addActionListener(this) add(birsonraki) kapat=new Button( cikis ) kapat.addActionListener(this) add(kapat) setVisible(true) } public void addKayit() { int accountNumber=0 Double d if(.hesapAlani.getText().equals( )) { try{ accountNumber=Integer.parseInt(hesapAlani.getText()) if(accountNumber0 && accountNumber <=100) { hesapDosyasi.yazhesap(accountNumber) hesapDosyasi.yazIsim(isimAlani.getText()) hesapDosyasi.yazsoyIsim(soyisimAlani.getText()) d=new Double(hesaptakiParaAlani.getText()) hesapDosyasi.yazhesaptakiPara(d.doubleValue()) girdi.seek((long)(accountNumber-1)*Kayit.boyut()) hesapDosyasi.yaz(girdi) } hesapAlani.setText( ) isimAlani.setText( ) soyisimAlani.setText( ) hesaptakiParaAlani.setText( ) } catch(NumberFormatException nfe) { System.err.println( Hesap numarasi tamsayi degisken olamalidir ) } catch(IOException io) { System.err.println( Dosyaya yazarken hata olustu\n +io.toString()) System.exit(1) } } } public void actionPerformed(ActionEvent e) { addKayit() if(e.getSource()==kapat) { try{ girdi.close() } catch(IOException io) { System.err.println( Dosya kapatilamadi\n +io.toString()) } System.exit(0) } } public static void main(String args[]) { new RaslantisalUlasimDosyasiYaz() } } * import java.awt. * import java.awt.event. * import Kayit public class RaslantisalUlasimDosyasiOku extends Frame implements ActionListener { private TextField hesapAlani,isimAlani,soyisimAlani,hesaptakiParaAlani private Button birsonraki,kapat private RandomAccessFile girdi private Kayit hesapDosyasi public RaslantisalUlasimDosyasiOku() { super( Musteri dosyasini oku ) try{ girdi=new RandomAccessFile( musteri1.dat , r ) } catch(IOException e) { System.err.println( Dosya acilamadi\n +e.toString()) System.exit(1) } hesapDosyasi=new Kayit() setSize(300,150) setLayout(new GridLayout(5,2)) add(new Label( Hesap numarasi )) hesapAlani=new TextField() add(hesapAlani) add(new Label( isim )) isimAlani=new TextField(20) add(isimAlani) add(new Label( soyisim )) soyisimAlani=new TextField(20) add(soyisimAlani) add(new Label( Hesaptaki para )) hesaptakiParaAlani=new TextField(20) add(hesaptakiParaAlani) birsonraki=new Button( bir sonraki hesap ) birsonraki.addActionListener(this) add(birsonraki) kapat=new Button( cikis ) kapat.addActionListener(this) add(kapat) setVisible(true) } public void okuKayit() { int hesap String ilk,son double balance { try{ do{ hesapDosyasi.oku(girdi) } while(hesapDosyasi.okuhesap()==0) hesapAlani.setText(String.valueOf(hesapDosyasi.okuhesap())) isimAlani.setText(String.valueOf(hesapDosyasi.okuIsim())) soyisimAlani.setText(String.valueOf(hesapDosyasi.okusoyIsim())) hesaptakiParaAlani.setText(String.valueOf(hesapDosyasi.okuhesaptakiPara())) } catch(EOFException eof) { closeFile() } catch(IOException io) { System.err.println( Dosyayı okurken hata olustu\n +io.toString()) System.exit(1) } } } public void actionPerformed(ActionEvent e) { if(e.getSource()==birsonraki) okuKayit() else closeFile() } private void closeFile() { try{ girdi.close() System.exit(0) } catch(IOException e) { System.err.println( Error closing filr\n +e.toString()) System.exit(1) } } public static void main(String args[]) { new RaslantisalUlasimDosyasiOku() } } Frame ve swing eşiti JFrame konsol ortamında kullanılabilen grafik ortamı programlamasıdır. Temel olarak applet yapılarında kullanılan her yerde Frame de kullanılabilir. Frame main programdan başlatılır. Html dosyasından başlatılmaz. Bu dokümanlara http //www.faqs.org/rfcs adresinden ulaşılabilir. Kullanma açısından bu dokümanlara ihtiyacınız yoktur. Gerekli programlar java zip paketinde bulunmaktadır. return } deyimi dosyanın gzip olarak yazılması için gerekli kanalı oluşturur. * import java.util.zip. JOptionPane.showInputDialog(null, Dosya oluşturma hatası + zipname + . ) } try { zipout.close( ) } catch (IOException e) {} } } return } yapısı kullanılır. Programların çalışması için java isim deyiminden sonra dostya ismini vermek kafidir. C \co\java\prog>java Gzip a.dat veya C \co\java\prog >java Gunzip a.dat.gz gibi. * import java.util.zip. return } } try { zipin.close( ) } catch (IOException e) {} } } Çünki bu proseste direktory içindeki dosyaların açılma işlemi söz konusudur. * import java.util. * import java.util.zip. java zip zipdosyası dosya(veyadirectory)ismi1 dosya(veyadirectory)ismi1...\n + zip dosyası yarat ve dosya(veya directorylerdeki dosyaları) sıkıştır + alt direktoryler atlanmaktadır tekrar tanımla // anahtarı kontrol et if(args.length<1 ) { String s1= zipdosyası isim.zip tanımlanmadı lütfen argümanları giriniz\n +s JOptionPane.showMessageDialog(null,s1) System.exit(0) return } // girdi dosyasını incele else if(args.length<2) { String s1= sıkıştırılacak dosya(veya direktory) isimleri tanımlanmadı\n + lütfen argümanları giriniz\n +s JOptionPane.showMessageDialog(null,s1) System.exit(0) return } if (args[0].endsWith( .zip )) { zipname = args[0] source = args[0].substring(0, args[0].length( ) - 3) } else { zipname = args[0] + .zip source = args[0] } //zip kanalını tanımla try { out = new FileOutputStream(zipname) zout=new ZipOutputStream(out) } catch (IOException e) { JOptionPane.showMessageDialog(null, Dosya oluşturma hatası + zipname + . ) * import java.util.zip. System.exit(0) } s+= +z.getName()+ \n }while(z.=null) } catch(NullPointerException npe) { s+= dosyaları açıldı JOptionPane.showMessageDialog(null,s) System.exit(0) } try { zin.close() } catch (IOException e) {} } catch(IOException e) { JOptionPane.showMessageDialog(null, Dosya açılma hatası + zipname) System.exit(0) } } } programı java unzip zip1.zip komutu kullanarak çalıştırırsak Burada zip dosyasına ulaşmak için FileInputStream in = new FileInputStream(zipname) ZipInputStream zin=new ZipInputStream(in) Deyimini kullandık. Burada temel olarak iki yeni sınıf kullanıldı. Bunlardan birincisi ZipInputStream, diğeri ise ZipEntry sınıfları idi. Ayrıca zip dosyasının içindeki elemanlar ZipEntry sınıfında tanımlanmaktadır. ZipEntry sınıfı public class ZipEntry implements ZipConstants, Cloneable { String name long time long crc long size Burada şu ana kadar verdiğimiz sınıf tanımları ile ilgili şunu söyliyelim. Tanımlamalar sadece sınıf ve değişken adlarını vermektedir, gerçek programı açtığınızda göreceğiniz koda benzemezler sadece metod isimlerini taşırlar. Java Dilinde bu görevi StringTokenizer sınıfı yerine getirir. StringTokenizer sınıfının yapısı Public class StringTokenizer implements Enumeration { private int currentPosition private int maxPosition private String str private String delimiters private boolean retTokens public StringTokenizer(String str, String delim, boolean returnTokens) public StringTokenizer(String str, String delim) public StringTokenizer(String str) * import java.util. * public class StringTokenizerTest { public static void main(String arg[]) { String s= Ali veli 49 elli System.out.println( cumle +s) StringTokenizer t=new StringTokenizer(s) System.out.println( kelime sayisi +t.countTokens()) int i=0 while(t.hasMoreTokens()) { System.out.println( kelime indeksi +(i++)+ kelime +t.nextToken()) } } } Programdan da görüleceği gibi StringTokenizer sınıfı StringTokenizer t=new StringTokenizer(s) deyimiyle tanımlanmıştır. Ayrıca string'in içindeki cümle sayısı t.countTokens() metoduyla çağırılmış, t.hasMoreTokens() sınıfı ise daha fazla kelime kalıp kalmadığının boolean kontrolü metodu olarak çağırılmıştır. t.nextToken() metodu o andaki kelimeyi dışarıya (String cinsinden) aktarırken indeksi de (currentPosition) bir sonraki kelimeye kaydırır. Program çıktısı cümle Ali veli 49 elli kelime sayısı 4 kelime indeksi 0 kelime Ali kelime indeksi 1 kelime veli kelime indeksi 2 kelime 49 kelime indeksi 3 kelime elli olacaktır. StringTokenizer sınıfının alt değişkenleri nval eğer seçilmiş olan token bir sayı ise nval bu sayının değerini içerir. nextToken metotu çağrıldıkrtan sonra bu değişken en son okunan token (kelimenin) türünü bildiri StringTokenizer sınıfının metotları kurucu metot StreamTokenizer(Reader) eolIsSignificant(boolean) satır sonu kumutunun yeni kelime tanımlayıp tanımlamadığını belirler. lineno() satır sayısını verir. lowerCaseMode(boolean) kelimelerin otomatik olarak küçük harfe çevrilip çevrilmeyeceğini tanımlar nextToken() giriş Stringinin içindeki bir sonraki kelimeyi bulur. ordinaryChar(int) Tokanizer'in normalde kontrol için kullandığı coşluk,satır sonu gibi özel kontrol karakterlerinin normal karakter olarak okunmasını sağlar parseNumbers() Direk olarak bir sayı dizininin geldiğini haber verir pushBack() bir sonraki nextToken çağırılmasında kelimenin şu andaki kelime olarak kalmasını sağlar. quoteChar(int) eğer karecteri varsa bunun içindeki karakterleri bir String değişkeni olarak algılar. slashSlashComments(boolean) Tokenizer'in C++-tipi (//.....)comment deyimlerini comment olarak tanıyım tanımıyacağını belirler. slashStarComments(boolean) Tokenizer'in C-tipi comment (/*...*/) deyimlerini comment olarak tanıyıp tanımıyacağını belirler. toString() o anda seçilmiş olan klimeyi (token) gönderir. StringBuffer genel olarak String sınıfının aynıdır, fakat genellikle dinamik olarak program içinde değeri sıkça değişen String'ler için kullanılır. String ise genellikle statik olarak verilen String değişkenleri içindir. StringBuffer sınıfına Append metoduyla dinamik olarak ilave yapabiliriz. StringBuffer sınıfının metot yapısı şöyledir package java.lang public final class StringBuffer implements java.io.Serializable { private int count private boolean shared static final long serialVersionUID = 3388685877147921107L public StringBuffer public StringBuffer(int length) public StringBuffer(String str) public int length() public int capacity() private final void copy() public synchronized void ensureCapacity(int minimumCapacity) private void expandCapacity(int minimumCapacity) public synchronized void setLength(int newLength) public synchronized char charAt(int index) public synchronized void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin) public synchronized void setCharAt(int index, char ch) public synchronized StringBuffer append(Object obj) public synchronized StringBuffer append(String str) class TersString { public static String reverseIt(String source) { int i, len = source.length() StringBuffer dest = new StringBuffer(len) for (i = (len - 1) i = 0 i--) { dest.append(source.charAt(i)) } return dest.toString() } } diğer bir StringBuffer metotu insert metotudur. Bu metot i inci elementten sonra verilen yeni parçayı ilave edecektir. * class javaKahvesi { public static void main (String args[]) { StringBuffer sb = new StringBuffer( Java kahvesi ic. ) sb.insert(12, ni sicak ) System.out.println(sb.toString()) } } bu programı çalıştırdığımızda Java kahvesini sicak iç. mesajını verecektir. Boyutlu değişkenlerin boyutları bilgisayar belleğinde oluşturulurken birbiri ardına sırayla oluşturulur. Buradaki sorun eğer bilgisayar belleğindeki toplam yer değiştirilmek istenirse bunun zor olmasıdır. Aynı zamanda bilgisayar boyutlu değişkenin adreslerini bilgisayar hafızasında bir referans tablosu olarak tuttuğundan boyut değiştirme bilgisayar hafızasını da zorlayan bir işlemdir. Pratik olarak yapılan uygulama yeni bir boyutlu değişken oluşturup adresleri değiştirmektir. double c[]=new double[5] for(int i=0,i<b.length i++) { c[i]=b[i] } b=c Daha gelişmiş bir bilgi yapısı olarak Vector sınıfını kullanabiliriz. Vector sınıfı java.util kütüphanesinde tanımlanmıştır. Vector sınıfında her bilgi elemanı aynı zamanda bir sonraki bilgi elemanının adresini taşır. Boylece istenildiğinde dizinin son elemanına yeni bir adres ilave edilerek kolayca yeni elemanlar ilave edilebilir. Dizinin arasından herhangibir elemanı da kalaylıkla sadece referans adresini değiştirerek silebiliriz. Vector sınıfının tanımı public class Vector extends AbstractList implements List, Cloneable, java.io.Serializable { protected int elementCount protected int capacityIncrement private static final long serialVersionUID = -2767605614048989439L public Vector(int initialCapacity, int capacityIncrement) public Vector(int initialCapacity) public Vector() public Vector(Collection c) public synchronized void copyInto(Object anArray[]) public synchronized void trimToSize() public synchronized void ensureCapacity(int minCapacity) private void ensureCapacityHelper(int minCapacity) public synchronized void setSize(int newSize) public int capacity() public boolean isEmpty() public Enumeration elements() public boolean hasMoreElements() public Object nextElement() public boolean contains(Object elem) public int indexOf(Object elem) public synchronized int indexOf(Object elem, int index) public int lastIndexOf(Object elem) public synchronized int lastIndexOf(Object elem, int index) public synchronized Object elementAt(int index) public synchronized Object firstElement() public synchronized Object lastElement() public synchronized void setElementAt(Object obj, int index) public synchronized void removeElementAt(int index) public synchronized void insertElementAt(Object obj, int index) public synchronized void addElement(Object obj) public synchronized boolean removeElement(Object obj) public synchronized void removeAllElements() public synchronized Object clone() public synchronized Object[] toArray() public synchronized Object[] toArray(Object a[]) public boolean remove(Object o) public void add(int index, Object element) public synchronized Object remove(int index) public void clear() public synchronized boolean containsAll(Collection c) public synchronized boolean addAll(Collection c) public synchronized boolean removeAll(Collection c) public synchronized boolean retainAll(Collection c) public synchronized boolean addAll(int index, Collection c) public synchronized boolean equals(Object o) public synchronized int hashCode() public synchronized String toString() public List subList(int fromIndex, int toIndex) protected void removeRange(int fromIndex, int toIndex) } Vector sınıfında tanımlanan metotların bazılarının anlamları şunlardır addElement(Object) Vektöre object türü (herhangi bir sınıf olabilir, vectörün hepsi bu sınfta tanımlanmış olmalıdır.) bir eleman ekler. capacity() vektörün toplam kapasitesini verir. clone() vectorun bir kopye vectörünü verir. contains(Object) Vectörün içinde sorgulanan elemanın olup olmadığını kontrol eder. copyInto(Object[]) vectorü boyutlu değişkene aktarır. elementAt(int indeks) Verilen indeksteki elemanı verir.. elements() Tüm vektörü enumeration sınıfına aktarır. ensureCapacity(int yeni_kapasite) eğer yeni_kapasite vector kapasitesinin üstündeyse vector yeni_kapasite'ye aktarılır. firstElement() Vectörün ilk elemanını verir. indexOf(Object) Object'in indeks değerini verir indexOf(Object, int indeks) Object'in indeks değerini verir, arama indeks değişkeninden başlayarak yapılır. insertElementAt(Object, int indeks) Vectörün ideks noktasına Object ilave edilir. isEmpty() Vectörün boş olup olmadığı kontrol edilir. lastElement() vectörün son elemanının indeksini verir. lastIndexOf(Object) Object'in vectördeki son tekrarının indeksini verir. lastIndexOf(Object, int indeks) indeks ten başlayarak geriye doğru Objectin ilk tekrarlandığı yeri bulur. removeAllElements() Vectördeki bütün elemanları siler. removeElement(Object) Vectördeki Object elemanını siler. removeElementAt(int indeks) indeksle verilen elemanı siler. setElementAt(Object, int indeks) Objectin ideksini indeks olarak belirler. setSize(int) Sets the size of this vector. size() Vectördeki toplam eleman sayısını verir. toString() Vectörün String eşitini verir. trimToSize() Vectörün boyutunu dolu olan elemanlarının boyutuna kısaltır. Aşağıda bu metotların önemlilerinden bazılarını kullanan bir örnek program verilmiştir. * import java.awt. * import java.applet.Applet import java.awt.event. containsBtn = new Button( Listede varmi. ) locationBtn = new Button( Adresi ) trimBtn = new Button( Kes ) statsBtn = new Button( Istatistikler ) displayBtn = new Button( Listeyi Goster ) add(prompt) add(input) addBtn.addActionListener(this) YaziPaneli.add(addBtn) removeBtn.addActionListener(this) YaziPaneli.add(removeBtn) firstBtn.addActionListener(this) YaziPaneli.add(firstBtn) lastBtn.addActionListener(this) YaziPaneli.add(lastBtn) emptyBtn.addActionListener(this) YaziPaneli.add(emptyBtn) containsBtn.addActionListener(this) YaziPaneli.add(containsBtn) locationBtn.addActionListener(this) YaziPaneli.add(locationBtn) trimBtn.addActionListener(this) YaziPaneli.add(trimBtn) statsBtn.addActionListener(this) YaziPaneli.add(statsBtn) displayBtn.addActionListener(this) YaziPaneli.add(displayBtn) add(YaziPaneli) } public void actionPerformed(ActionEvent e) { if(e.getSource()==addBtn) { v.addElement(input.getText()) showStatus( Listenin sonuna eklendi +input.getText()) } else if(e.getSource()==removeBtn) { if(v.removeElement(input.getText())) showStatus( Silindi +input.getText()) else showStatus(input.getText()+ not in vector ) } else if(e.getSource() == firstBtn) { try{ showStatus( Ilk eleman +v.firstElement()) } catch(NoSuchElementException exception) { showStatus(exception.toString() ) } } else if(e.getSource()==lastBtn) { try{ showStatus( Son eleman +v.lastElement()) } catch(NoSuchElementException exception) { showStatus(exception.toString() ) } } else if(e.getSource() == emptyBtn) { showStatus(v.isEmpty(). Vector bos vector dolu ) } else if(e.getSource()==containsBtn) { String searchKey = input.getText() if(v.contains(searchKey) ) showStatus( Vektor elemanlar +searchKey) else showStatus( Aranan eleman Vektorde bulunamadi +searchKey) } else if(e.getSource()==locationBtn) { showStatus( Eleman +v.indexOf(input.getText() )+ pozisyonunda bulundu ) } else if(e.getSource()==trimBtn) { v.trimToSize() showStatus( Vector boyu eleman boyuna ksaltld ) } else if(e.getSource()== statsBtn) { showStatus( Boyut = +v.size()+ Toplam kapasite = +v.capacity()) } else if(e.getSource()== displayBtn) { Enumeration enum=v.elements() StringBuffer buf = new StringBuffer() while(enum.hasMoreElements()) { buf.append(enum.nextElement() ) buf.append( ) } showStatus(buf.toString() ) } input.setText( ) } } Bundan sonraki program iki kümenin bileşim ve kesişim kümelerini hesaplamaktadır. Kümelerin kaç elemandan oluştuğu tanımlanmamıştır. İşlemler vector sınıfını kullanarak yapılmaktadır. Ayrıca bu yapıda vector sınıfını bir döngü içinde kullanmak için vector sınıfı Enumeration sınıfına yüklenmektedir. Enumeration sınıfının görevi, StringTokenizer sınıfının görevini andırır. Vector yapısının içinden her vector elemanını ayrı ayrı çağırma ve indeksleme görevi görür. Enumeration interface'inin tanımı public interface Enumeration { boolean hasMoreElements() Object nextElement() } şeklindedir. Enumeration n1=list1.elements() Enumeration n2=list2.elements() while(n1.hasMoreElements()) { s1=(String)n1.nextElement() bilesimVectoru.addElement(s1) } kod parçacığında vector sınıfının elements metotu,Enumeration sınıfı ve Enumeration sınıfının hasMoreElements ve nextElement metotları kullanılarak nasıl döngü oluşturulduğu görülmektedir. Aşağıdaki örnekte setA sınıfı verilmiştir. Bu örnekte bir kümelerin bileşim ve kesişim kümelerinin vector metodunu kullanarak nasıl oluşturulabileceği gösterilmektedir. // Bu program vector ve Enumeration siniflarını // Kullanmaktadır. Bilesim, kesisim kümelerini hesaplar // Ayni zamanda StringTokaniser sinifini kullanir. import java.util. * import java.awt. * import java.applet.Applet import java.awt.event. * class SetA { public Vector bilesim(Vector list1, Vector list2) { Vector bilesimVectoru = new Vector() String s1,s2 Enumeration n1=list1.elements() Enumeration n2=list2.elements() while(n1.hasMoreElements()) { s1=(String)n1.nextElement() bilesimVectoru.addElement(s1) } while(n2.hasMoreElements()) { s2=(String)n2.nextElement() if(.bilesimVectoru.contains(s2)) bilesimVectoru.addElement(s2) } return bilesimVectoru } public Vector kesisim(Vector list1,Vector list2) { Vector kesisimVectoru = new Vector() String s Enumeration n = list1.elements() while(n.hasMoreElements()) { s=(String)n.nextElement() if(list2.contains(s)) kesisimVectoru.addElement(s) } return kesisimVectoru } ansUn = set.bilesim(list1,list2) ansInt = set.kesisim(list1,list2) // sonuclari cikti alanina gonder cikti.append( \nIki listenin bilesim kumesi \n ) ciktiA(ansUn) cikti.append( \nIki listenin kesisim kumesi \n ) ciktiA(ansInt) } } //actionPerformed metotunun sonu } Bu programda aynı zamanda StringTokaniser sınıfı kullanılmıştır. StringTokaniser String değişkenini bosluk kullanarak alt değişkenlere ayırmaya yarayan Enumeration türü bir sınıftır. Aynı programın Swing versiyonuSetTestSWF_2000.java aşağıda verilmiştir // Bu program vector ve Enumeration siniflarını // Kullanmaktadır. Bileşim ve kesişim kümelerini hesaplar // Aynı zamanda StringTokeniser sınıfını kullanır. import java.util. * import java.awt. * import javax.swing. * import java.awt.event. list.addElement(test) } } public void ciktiA(Vector v) { Enumeration enum = v.elements() while(enum.hasMoreElements()) { String ans = (String)enum.nextElement() cikti.append(ans + ) } cikti.append( \n ) } public void actionPerformed(ActionEvent e) { if(e.getSource()==T1) { String stringToTokenize = T1.getText() girdiA(stringToTokenize,list1) } else if(e.getSource()==T2) { String stringToTokenize = T2.getText() girdiA(stringToTokenize,list2) // Iki listenin bilesim ve kesisim kümelerini hesapla. ansUn = set.bilesim(list1,list2) ansInt = set.kesisim(list1,list2) // sonuclari cikti alanina gonder cikti.setText( ) cikti.append( İki listenin bileşim kümesi \n ) ciktiA(ansUn) cikti.append( İki listenin kesişim kümesi \n ) ciktiA(ansInt) } } //actionPerformed metodunun sonu public static void main(String[] args) { SetTestSWF_2000 pencere = new SetTestSWF_2000() pencere.addWindowListener(new BasicWindowMonitor()) pencere.setSize(400,350) pencere.setVisible(true) } } Eğer vektor boyutları program çalışırken azalıyor veya çoğalıyorsa, boyutlu değişkenler yerine dinamik hafıza kullanımı toplam bilgisayar hafızası kullanımı açısında çok daha verimlidir. Dinamik data yapıları sadece vektorden ibaret değildir. List(liste), Stack(dizin) ve Queue (sıra) ve Tree(agaç) yapıları da oldukça sık kullanılar dinamik yapıları teşkil eder. Bunlardan List yapısının özellikleri şunlardır  Listenin ilk elemanından önce veya son elemanından sonra listeye dinamik eleman ilavesi yapılabilir.  Listenin herhangibir ara noktasına yeni eleman ilave edilemez.   Listenin ilk elemanı veya son elemanı listeden çekilebilir. Listenin herhangi bir ara noktasından eleman çekilemez. Burada List kavramının daha iyi anlaşılabilmesi için önce kendi List sınıfımız oluşturulmuş ve bir örnek problemde kullanlmıştır. Bu program örneklerine bir göz atalım. Bu program List yapısını tanımlayan ListNode ve List sınıflarını içerir. class ListNode { Object data ListNode next ListNode(Object o) {this(o,null) } ListNode(Object o,ListNode nextNode) { data=o next=nextNode } Object getObject() {return data } ListNode getnext() {return next } } public class List { //Liste private ListNode firstNode private ListNode lastNode private String name public List(String s) { name=s firstNode=lastNode=null } public List(){this( Liste ) } public synchronized void insertAtFront(Object insertItem) { if( isEmpty() ) firstNode = lastNode = new ListNode(insertItem) else firstNode = new ListNode(insertItem,firstNode) } public synchronized void insertAtBack(Object insertItem) { if(isEmpty()) firstNode=lastNode=new ListNode(insertItem) else lastNode=lastNode.next=new ListNode(insertItem) } public synchronized Object removeFromFront() throws EmptyListException { Object removeItem=null if(isEmpty()) throw new EmptyListException(name) removeItem=firstNode.data if(firstNode.equals(lastNode)) firstNode=lastNode=null else firstNode=firstNode.next return removeItem } public synchronized Object removeFromBack() throws EmptyListException { Object removeItem=null if(isEmpty()) throw new EmptyListException(name) removeItem=lastNode.data if(firstNode.equals(lastNode)) firstNode=lastNode=null else { ListNode current=firstNode while(current.next .= lastNode) current=current.next lastNode=current current.next=null } return removeItem