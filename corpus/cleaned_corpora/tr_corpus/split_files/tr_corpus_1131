Temel yapı switch - case yapısı switch( degişken ismi) { case değişkenin alacağı deger bu değer oluştuğunda yapılacak işlemler break // bu deyim döngünün bitmesini sağlar. case değişkenin alacağı başka bir değer bu değer oluştuğunda yapılacak işlemler break // bu deyim döngünün bitmesini sağlar. ................ default eğer yukarıdaki case kutularından hiçbirine girilemediyse yapılacak işlemler break } şeklindedir. Switch yapısından sonra değişken ismi gelir. Her case deyiminden sonra ise değişkenin alacağı yeni bir değer alternatifi verilir. Eğer switch yapısında verilen alternatif hiçbir case bloğunda tanımlanmamışsa default bloğuna gider ve buradaki işlemler gerçekleştirilir. Case ve default blokları break deyimi ile sona erer. break deyimi herhangi bir döngü yapısından döngü bitmeden çıkma amacıyla da kullanılabilir. break yapısıyla döngünün dışına çıkma amacıyla diğer döngü yapılarında da kullanılabilir(if, for while gibi), fakat bu tür break kullanılarak döngü dışına çıkılması yapısal programlama teknikleri tarafından tavsiye edilmez. Bilgisayar listelerini yapısallıktan uzaklaştırıp, spagetti programlama dediğimiz karmakarışık programlamaya yol açabilir. Döngü yapılarından standart kontrolları yoluyla çıkılması tavsiye edilir. Programcılara göre kullanılma sıklığı değişebildiği varsayılsa bile, switch yapısı şu ana kadar bahsedilen yapılar içinde en az kulanılanıdır. Bu program öğrenci notlarını appletden girer ve her nottan kaç tane girildiğini listeler. import javax.swing. * // java swing JApplet sinifini cagir import java.awt. * // java pencere awt sinifini cagir import java.awt.event. örneğin char a='x' int b=a işlemi c++ da geçerli bir işlemdir. Javada ise bu işlem hata verir. fakat aynı islem char a='x' int b=(int)a şeklinde gerçekleştirilebilir (int) deyimi orijinal olarak char olarak tanımlanan a değişkeninin değerini int türüne dönüştürmüş sonra da in türünden b değişkenine yüklemiştir. Bu dönüşüm işlemlerini tüm değişken türleri için kullanabiliriz, yalnız burada programcının çok dikkatli olması ve değişken türlerini, ve sınırlarını iyi tanıması gerekmektedir. Değişken türlerini değiştirirken bazı bilgiler kaybolacağı gibi hiç istemediğimiz bir sonuca ulaşma olasılığımız da mevcuttur. sayı değil (NaN) sonucu sıfır bölü sıfır, sıfır çarpı sonsuz gibi işlemlerden çıkar. sonsuz işlemi ise sayi bölü sıfır gibi işlemlerden çıkar. Bu işlemler sadece float ve double değişkenleri için tanımlıdır. Tamsayı değişkenler sıfıra bölünemezler. Bu yüzden genelde programlar küçük parçalara bölünerek daha kolaylıkla anlaşılır şekle getirilmeye çalışılır. Buna böl parçala ve yönet tekniği de diyebiliriz. Bu küçük parçalara javada metot adi verilir. Java programları yeni metotları içeren java sınıflarıyla(class) java sınıf kütüphanelerinde yer alan metotların birleşmesinden oluşur. Java kütüphanesinde matematik işlemlerinden grafik, ses, giriş çıkış işlemleri, yanlış kontrolu gibi birçok konularda yazılmış metotlar mevcuttur. Java sınıf kütüphanesi adi da verilir. Şüphesiz bunun dışında java metodlar kolleksiyonlarının olduğu çeşitli diğer kütüphaneler de mevcutur. java.awt (java window araçları paketi) Bu sınıf grafik arayüzleri tanımlamaya yara. java.awt.color renk tanımlar java.awt.datatransfer bilgisayarın geçic hafızasıyla java programı arasında bilgi akışını sağlar. java.awt.dnd ekle ve çalıştır türü programlar arasında geçiş yapabilen paketlerden oluşur. java.awt.event grafik programlama ortamıyla kullanıcı arasındakiilişkiyi sağlar. Örneğin grafik penceresinde return tuşuna basıldığında veya farenin düğmesine basıldığında ne yapılması gerektiğini belirler. Java.awt ve javax.swing sınıflarının ikisiyle de kullanılır. java.awt.font yazı fontları ve bu fontların değiştirilmesiyle ilgili programalrı içerir. java.awt.geom iki boyutlu geometrik şekilleri tanımlar. java.awt.im java programlarına çince, japonca ve kore dilinde girdi girebilmek için tanımlanmış bir arabirimdir. java.awt.image java görüntü işleme paketi java.awt.image.renderable bir program içindeki resimleri depolama ve değiştirme için gerekli olan programları içerir. java.awt.print java programlarından yazıcılara yazım için bilgi aktaran paketleri içerir. java.beans java fasulyeleri paketi, bu paketin detayları için ilgili bölümü inceleyiniz. java.beans.beancontext tekrar kullanılabilen ve otomatik olarak birleştirilebilen program parçacıkları tanımlar. java.io dosya ve ekrandan girdi ve çıktı yapmak için gerekli program paketleri tanımlanır. java.lang bu paket birçok temel program içerir Bunlardan biri olan Math paketi aşağıda açıklanacaktır. Lang paketi java programlarınca otomatik olarak kullanılır. İmport deyimiyle iave edilmesi gerekmez. java.lang.ref bu paket java programıyla garbage collector (çöp toplayıcısı) denilen otomatik kullanılmayan hafıza temizleme programıyla ilişkiyi sağlar. java.lang.reflect bu paketteki programlar java programının çağrıldığında içinde bulunan değişken ve metotları dinamik olarak tespit etmesinive kullanma izni almasını sağlar. java.math bu sınıf değişebilir hassasiyette arimetik işlemler yapmak için gereken tanımları ve sınıfları içerir. java.net ağ işlemlerinde kullanılan çeşitli paketleri tanımlar java.rmi , java.rmi.activation, java.rmi.dgc, java.rmi.registry, java.rmi.server programların ve metodların uzaktan çalışabilmeleri için gerekli tanımlamaları içerir. java.security, java.security.acl, java.security.cert, java.security.interfaces, java.security.spec güvenlikle ilgili programlar demetini içerir. java.sql database programıyla java programlarını bağlantısını sağlar. java.text sayı karekter ve string tarih gibi işlemlerle ilgili programlar demeti içerir. Örneğin çok dilli programlar yazmayı sağlayan internalisation paketi bu paket içinde yer alır. java.util bu sınıf tarih ve zamanla ilgili fonksiyonlar, tesadüfi sayı üreticileri, StringTokenizer gibi programları barındırır. java.util.jar bu paket java programlarını paketlemeye yarıyan jar yapılarını tanımlamada gerekli olan programları tanımlar. java.util.zip bu paket programları sıkıştırmaya yarayan programları tanımlar. Java.accessibility bu paket özürlülerin kullanabileceği ara üniteler tanımlar. Ekran okuyucular ve ekran büyüteçleri gibi. javax.swing grafik kullanıcı arabirimi tanımlar. Bu sınıftakitanımlar aracılığıyla ekrandan grafik ortamında veri transferi kolaylıkla yapılabilir. javax.swing.borders grafik arabirimi sınır yaratımında çeşitli sınır şekilleri yaratmakta kullanılır. Javax.swing.colorchooser renk seçimi için tanımlanmış grafik kullanıcı arabirimini tanımlar. Java.applet paketi appletleri oluşturma, appletlere giriş çıkısları ve dosyaları applet içerisinde çalıştırmayı sağlar. java.awt pencere(window) ortamındaki tüm programlama sınıflarını ve metotlarını içerir. Java swing (javax.swing) paketi yine aynı tür pencere(window) ortamında programlama için gerekli girdi çıktı grafik ortamlarını içerir. awt grafik ortamına göre daha zengin ve gelişmiş bir kolleksiyondur. Bu metotları ilerideki bölümlerde daha detaylı inceleyeceğiz. java.io paketi javaya dışarıdan(dosya,ekran v.b) bilgi giriş çıkışını ayarlar. Java metodlarının tamamının listesini (İngilizce olarak) Java doküman kütüphanesindeki api alt gurubunda bulabilirsiniz. Java döküman kütühanesi http //java.sun.com adresinden çekilebilir. Bu sınıf(class) java.lang paketinde yer alır. Java.lang paketi java programı açılırken otomatik olarak çağırılır. Bütün diğer paketler import deyimi kullanılarak programa ilave edilirler. Tablodaki x veya y değişkenleri double değişken türündendir. Math sınıfında(class) iki tane de sabit tanımlanmıştır. (türkçesi taban) cos(x) x in trigonometrik cosünisü (x radyan cinsinden tanımlanmıştır.) sin(x) x in trigonometrik sinüsü (x radyan cinsinden tanımlanmıştır.) tan(x) x in trigonometrik tanjantı (x radyan cinsinden tanımlanmıştır.) acos(x) x in trigonometrik cosünisünün tersi (sonuç radyan cinsindendir) asin(x) x in trigonometrik sinüsü (x radyan cinsinden tanımlanmıştır.) atan(x) x in trigonometrik tanjantı (x radyan cinsinden atan2(x,y) tanımlanmıştır.) x,y noktanın x,ykoordinatlarıdır exp(x) e(2.7182818284590452354) nin x inci kuvveti log(x) e tabanına göre logaritma pow(x,y) x in y inci kuvveti max(x,y) x ve y nin büyük olanı min(x,y) x ve y nin küçük olanı random() Raslantısal sayı (0 ile 1 arasinda) Math.sin(1.0)=0.8414709840709 Math.tan(1.0)=1.557040724655 Math.acos(0.54030230568)=1.0 Math.asin(0.8414709840709)=1.0 Metotlar sınıfların(class) içinde yer alan küçük program parçacıklarıdır. Metotların çoğunda değişken parametreler metotlar ve sınıflar arasında iletişimi sağlarlar. Ayrıca her metotun kendine özgü değişkenleri de vardır. Metot yapısının ana sebebi programları modüler hale getirmektir. Aynı zamanda aynı program parçacığının tekrarlanmasını önlemeyi de sağlar. Her metot çağrıldığı proğram parçacığına belli bir değişkeni aktarabilir. Metotların tanımlarında aktardıkları değişken türü tanımlanır. Eğer metot hiçbir değişken aktarmıyorsa void sözcüğüyle tanımlanır. Metotların genel tanımı aşağıdaki gibidir. Parantez içindeki terimler kullanılmıyabilir. z ve f değişkenleri metotun yerel değişkenleridir ve bu metot dışında tanımları yoktur. Metot f değişkeninin değerini çıktı olarak metotun dışina aktarmaktadır. Şimdi aynı metotun statik metot olarak bir appletin içinde kullanılmasını görelim. * public class metod2 { // sayinin karesi metodu // bu metodda static kelimesi kullanilmiyor public double kare(double x) Bilgisayar kare(sayi) ifadesini gördüğünde metotun içine gider, orada tanımlanan tüm işlemleri yaptıktan sonra return kelimesinin karşısındaki işlemleri çağırıldığı yere geri iletir. Metot1 java programında çağırılan kare(sayi) metotunda sadece sayının kendisiyle çarpımı return kelimesinin karşısına yazıldığından, kare(sayı) ifadesi sayı*sayı ifadesiyle eşdeğerdir. Burada kare metotundandaki değişken adının sayı değil x olarak verildiğini de burada not edelim. Sayı değişkeni metotun girişinde x degişkenine yüklenir. Gerekli işlemler metotda yapıldıktan sonra sadece metotun sonuçları return deyimiyle metodun değişken türü olarak (bu metod için double ) geri döner. nasıl tanımladığımızı görmüştük. Nesne tipi programlamanın en önemli özelliği kendi değişken türlerimizi yaratabilmemizdir. İlerideki bölümlerde kendi değişken türlerimizi sınıf (class) yapısını kullanarak nasıl yaratacağımızı daha detaylı olarak inceleyeceğiz. Bu bölümde nesnelerin program içindeki tanımlanmasına göz atalım. Daha önce tanımladığımız bazı applet programlarında nesne tanımları zaten geçmişti. Örneğin daha önceki programlarımızda bilgi okutmak için kullandığımız Text cin=new Text() Terimi Text sınıfından(class) cin nesnesini tanımlar. Nesne(object) tanımı yaparken aynı metotlarda olduğu gibi değişken veya nesneleri girdi olarak tanımlamamız mümkündür. Diğer bir örnek olarak yine daha önceki örnek problemlerde kullandığımız Label sınıfından(class) kutubasligi nesnesinin tanımını ve TextField sınıfından(class) kutugirdisi nesnesini gösterebiliriz. İlk sınıf metot3a da kare metotu tanımlanmıştır. İkinci sınıf(class) metot3 de ise metot3a sınıfı b nesnesi tanımlanmış, ve kare metotu b nesnesi üzerinden b.kare(sayi) olarak çağırılmıştır. Bu metot b nesnesi için bilgisayar belleğinde bir yer ayırır. Kare metotunu çağırırken bu yerin adresini kullanır. metot3.java programında kare metotu ayrı bir sınıf(class) ta tanımlandığından yerinin tanımlanması gerekir. Metotlar statik olarak da tanımlanabilirler. Statik olarak tanımlanan metotlar nesne kullanılmadan direk olarak sınıf(class) adları kullanılarak çağırılabilirler. * public class metod4 { public static void main(String[] args) throws IOException { double sayi BufferedReader cin=new BufferedReader(new InputStreamReader(System.in)) System.out.println( Bir gerçek sayı giriniz ) sayi=Text.readDouble(cin) System.out.println( girilen sayının karesi +metod4a.kare(sayi)) }} Program girdi ve çıktısı Bir gerçek sayı giriniz 2.25 girilen sayının karesi 6.25 Görüldüğü gibi metoti4 sınıfında(class) kare metotu metoti4a.kare(sayi) olarak tanımlanmış ve ek bir nesne adresi kullanılmamıştır. static olarak tanımlanan metotların kendi kendine yeterli metotlar olması gerekir. Yani içinde bulunduğu sınıfla veya baska sınıflarla direk olarak veri alışverişi olamaz. Girdileri sadece girdi parantezleri () arasinda verilen değişkenlerdir.dinamik metotlar ise kendi sınıfları ve diğer sınıflarla değişik yollardan bilgi ve değişken aktarımı yapabilirler Java bir metotun kendi kendini çağırmasına izin verir. Burada dikkatli olunması gereken nokta bu kendi kendine çağırılma döngüsünün sonsuza kadar sürmesinin bir kontrol yapısı kullanılarak engellenmesidir. Kendi kendini çağıran programlarda mutlaka bir döngü çıkış şartı tanımlanmalıdır. Şimdi aynı programın faktoriyel metodu ayrı yazılmış fakat yine for döngüsü kullanan şekline göz atalım. 1 = (2*1. (=1)) = 2 = (3 * 2. (=2)) = 6= (4*3. (=6))=24= (5*4. (24))=120= 5. (=120) sonuç 120 olarak ana programa gönderilecektir. Kendi kendini çağıran metodlar mutlak bir gereksinim olmadıkça tercih edilmez. Bu tür programlamada hem sonsuz döngülerin görülmesi daha güç olabilir, hemde for, while gibi döngüler kullanılarak programlamaya göre programlar daha yavaş çalışır. Aynı sınıfta(class) kullanılan metotların girdi değişkenlerinin değişken türlerinin veya değişken sayılarının farklı olması gerekir. Java aynı isimli ve ayni degişken türlü iki metotu birbirinden ayıramaz. Örneğin public double Bmetodu(double Adeğişkeni) Ve public double Bmetodu(double Bdeğişkeni) Veya public int Bmetodu(double Cdeğişkeni) Java tarafindan ayırt edilemez , Fakat public double Cmetodu(double Adeğişkeni) Ve public double Cmetotu(int Bdeğişkeni) veya public double Cmetotu(double Adeğişkeni, double Bdeğişkeni) Java tarafından ayırt edilir ve birlikte aynı sınıfın (class) içinde yer alabilir. Eğer birbirinin tam olarak eşiti metotlar değişik sınıflarda yer alıyorsa bunun herhangi bir sakıncası yoktur. Program 2.11'de ayniisimliikimetot.java programı görülmektedir. Bu programda daha önceki programlarda da kullandığımız kare metotunu int ve double girdi değişkenleriyle iki kere aynı sınıfın içerisinde tanımlayacağız. Benzer bir örneği swing applet olarak verelim * public class H3AL9_2000 extends JApplet { JTextArea ciktiAlani public void init() { ciktiAlani=new JTextArea() Container c=getContentPane() c.add(ciktiAlani) int x1=7 double x2=7.0 ciktiAlani.setText( exp ( +x1+ ) ciktiAlani.append( exp ( +x2+ ) x1=5 x2=5.0 ciktiAlani.append( exp ( +x1+ ) ciktiAlani.append( exp ( +x2+ ) } (int metod girdisi ) = +exp(x1)+ \n ) (double metod girdisi) = +exp(x2)+ \n ) (int metod girdisi ) = +exp(x1)+ \n ) (double metod girdisi) = +exp(x2)+ \n ) // double girisli exp metodu public double exp(double x) { double faktoriyel=1 double us=1 double exponent=1 for(double i=1 i<=300 i++) { faktoriyel*=i us*=x exponent+=us/faktoriyel } return exponent } // int girişli exp metodu public double exp(int x) { double exponent=1.0 for(int i=1 i<=x i++) { exponent*=Math.E } return exponent } } * public class metodexpornegi { public static void main(String arg[]) { int x1=7 O metotun dışında tanımları yoktur. Eğer değişkenler metotların dışında sınıf(class) değişkenleri olarak tanımlanırsa metota da aynen aktarılırlar. Bu yüzden paint metotundaki drawString metotu tekrar çağırıldığında x ve y nin değerlerinin değiştiğini görürüz. Bu yüzden metot1 in içindeki x ve y değişkenlerinin değişmesi paint metotundaki drawString metotu tekrar çağırıldığında x ve y nin değerlerinin değişmediği görülür. Nesne tanımı yapıldığında Bilgisayar bu nesne için bir adres yaratır. Yeni adres yarat komutu new komutudur. // java kutuphanelerinde tanimli bir sinifin cagirilip // nesne olarak tanimlanmasi ve adres paylasimi import java.io. nokta1=new Point(100,100) nokta2=nokta1 // nokta1 ve nokta2 bilgisayarda ayni // adres kutusunu paylasiyor System.out.println( nokta1 ve nokta2 ayni degerleri tasiyor ) System.out.println( ve aynı bilgisayar adresini paylasiyor ) System.out.println( nokta 1 +nokta1.x+ , +nokta1.y) System.out.println( nokta 2 +nokta2.x+ , +nokta2.y) nokta1.x=200 nokta1.y=200 System.out.println( nokta1 in degeri degistirildi ) System.out.println( nokta 1 +nokta1.x+ , +nokta1.y) System.out.println( nokta 2 +nokta2.x+ , +nokta2.y) // nokta1 ve nokta2 nin degerleri ayni fakat bilgisayarda // degisik adreslerde tanimlanmis nokta1=new Point(100,100) nokta2=new Point(100,100) System.out.println( nokta1 ve nokta2 ayni degerleri tasiyor ) System.out.println( fakat ayni bilgisayar adresini paylasmiyor ) System.out.println( nokta 1 +nokta1.x+ , +nokta1.y) System.out.println( nokta 2 +nokta2.x+ , +nokta2.y) nokta1.x=200 nokta1.y=200 System.out.println( nokta1 in degeri degistirildi ) System.out.println( nokta 1 +nokta1.x+ , +nokta1.y) System.out.println( nokta 2 +nokta2.x+ , +nokta2.y) }} Point1.java da verilen Point nokta1,nokta2 nokta1=new Point(100,100) nokta2=nokta1 tanımında Point sınıfından(class) nokta1 ve nokta2 değişkenleri tanımlanmış, nokta1 değişkeni için yeni(new) adres tanımlanmış, nokta2 değişkenine de aynı adresi (nokta1'in adresini) kullanması soylenmiştir. Bu yüzden programda nokta1 e yeni deger verildiğinde nokta2 nin değeri de aynı değeri alır. daha sonra kullanılan nokta1=new Point(100,100) nokta2=new Point(100,100) deyimi ile ise nokta1 ve nokta2 için iki ayrı adres yaratılmıştır. Bu yüzden nokta1 değiştiğinde nokta2 eski değerinde kalır. Aynı adresin iki değişken tarafından kullanılması ancak gerektiği zaman ve çok dikkat sarfederek yapılmalıdır. Gereksiz yere kullanılmasından kesin olarak kaçınılmalıdır. Program güvenlik ve kontrol problemleri yaratabildiği gibi, istemediğimiz değişken değerlerinin silinmesi sonucunu da verebilir. 1.3 . object nesne sınıf (Class) yapıları bilgisayar belleğinde bir işlem için kullanıldığında aldıkları (özel) isim. Fakat tam olarak sınıfların ne olduğunu ve neler yapabileceklerini anlatmadık. Sınıf yapısının en onemli ozelliği yeni bir değişken türü tanımlıyor olmasıdır. Şu ana kadar programlarımızı tanımlamak amacıyla çeşitli sınıflar tanımladık. Bu bölümde sınıfların değişken türü olarak tanımlamasını ve kullanmasını göreceğiz. Sınıf (Class) deyince herhangi bir nesnenin genel tanımlanmasını anlıyoruz. Bu sınıflardan değişkenler tanımlandıklarında nesneleri oluştururlar. Örneğin kalem dediğimizde genel bir sınıfı anlatıyoruz. Alinin cebindeki kırmızı kalem ise belirli bir nesnedir. Sınıfın genel tanımı şu şekilde yapılabilir class sınıfın_ismi { //sınıfa ait değişken listesi değişken_türü değişken_ismi değişken_türü değişken_ismi ......... //sınıfa ait metot listesi degişken türü metotadı(metot girdi değişken listesi) { //metotun içindeki hesaplanan işlemler return çıktı_değişkeni } .............. } Sınıf (class) tanımında metotların (veya değişkenlerin) bulunması şart değildir. Bulundukları takdirde bunlar o sınıfa ait veya sinifin üyesi metotlar olarak düşünülür. İlk sınıf örneği olarak içinde hiçbir metotun yer almadığı bir kutu sınıfı tanımlıyalım. Bir kutuyu üç geometrik boyutu (eni,boyu,yüksekliği) cinsinden tanımlayabiliriz. class Kutu { double en double boy double yukseklik } Üstte bahsettiğimiz gibi sınıf yeni bir değişken türü yaratır. Yukardaki sınıfın yarattığı değişken türünün adı Kutu'dur. Kutu değişkenini başka bir proğramda tanımlarken budeğişken türünden bir nesne yaratılır. Örneğin Kutu kutu1= new Kutu() kutu1, kutu türünde tanılanmış bir nesnedir. Bu nesnenin kendisinin de en boy ve yükseklik olmak üzere üç alt değişkeni mevcuttur. Eğer bir programda kutu1 değişkeni tanımlanmışsa, bu değişkenin alt degişkenlerine şu şekilde ulaşılabilir kutu1.en=1.0 Şimdi Kutu sınıfından nesneyi kullanacak ufak bir kututestı sınıfı oluşturalım ve Kutu sınıfını bu sınıfta kullanalım. Bu programın adının kututesti.java olması zorunludur. Çünki ana metot(main) kututesti sınıfında tanımlanmıştır. Fakat programı javac terimiyle bilgisayar diline çevirdiğimizde iki tane sınıf(class) dosyasının oluştuğunu görürüz. Birisi Kutu.class diğeride kututesti.class. Ana program kututesti olduğu için bu programın işletimi java kututesti deyimini kullanarak yapılır. Program işletildiğinde kutu1 nesnesi yaratıldığında bilgisayar belleğinde kutu1 için bir adres tanımlanır. New Kutu() deyimi verildiğinde ise bilgisayrın belleginde en,boy ve yükseklik değişkenleri için yer ayrılır ve bu yerlerin adresleriyle kutu1 nesnesinin adresi arasında bağlantı sağlanır. Kutu1 kutu1 adresi (örneğin 23436A3F) en Boy Yükseklik Not null terimi bilgisayar beleğinin boş olduğunu gösterir. Yukardaki grafikte ilk olarak Kutu kutu1 tanımı yapıldığında bilgisayar belleğinde 1 byte boyutunda bir yer tanımlar. Ve bu yere boş anlamına gelen null degerini yükler. İkinci durumda ise (kutu1=new Kutu() tanımında) kutu1 nesne adresindeki kutuda en,boy,yükseklik değişkenlerinin adresleri kaydedilmiştir. Bu adres aracılığıyla en boy ve yükseklik değişkenlerine benimkutum degişkeni üzerinden ulaşılabilir. Diğer deyimle en,boy,yükseklik kutu1 nesnesinin alt değişkenleridir. Bu programın çıktısı Bu basit programda bile en,boy ve yükseklik değikenlerini iki defa çağırmak program listesinin uzamasına sebep olmuştur. Gerçek uygulamalarda ise çok daha yüksek sayıda değişken içeren sınıflar oluşturulabilir ve bu sınıflarda oluşturulan toplam nesne sayısı da çok fazla olabilir. Bu yüzden nesneyi ilk tanımlarken aynı zamanda değişkenlerinin değerlerini de tanımlayabilirsek, çok daha okunaklı ve kısa bir bilgisayar listesiyle aynı işi yapabiliriz. Bu iş için kurucu (constructor) adı verilen metotlar kullanılır. Kurucu metotları diğer metotlardan biraz farklıdır. Once metot önüne metot değişken türü gelmez ve metot dışına hiçbir değişken göndermezler. İsimleri de herzaman sınıf(class) ismiyle aynı olur. Bu program bir öncekinin aynı sonucu verir. Fakat burada bir önceki programda yapılan Kutu kutu1=new Kutu() Tanımı yerini Kutu kutu1=new Kutu(10.0,20.0,30.0) Tanımına bırakmış ve kututesti2 sınıfı yazılırken en ,boy yükseklik değişkenlerinin yeniden tanımlanması ihtiyacını ortadan kaldırmıştır. Hacim bir kutunun özellikleri arasında yer alır, ve her zaman kutunun hacminin hesaplanması gerekebilir. Bu yüzden hacim işlemini Kutu sınıfının içinde tanımlamak daha ideal olacaktır. } Program çıktısı yine aynı olacaktır. Nesne daha tanımlanmadığindan direk olarak nesne ismini kullanamayız. Bunun yerina java this deyimini kullanır. This deyimi bilhassa sınıfa ait değişken isimlerinin aynısı metotda kullanılmışsa da işe yarar. Bu durumda tüm sınıfa ait değişkenler this.değişken_ismi komutuyla çağırılabilir. geçen bölümde sınıf ve metota ait değişkenleri izlerken metotvesinifdeg.java ve metotvesinifdeg1.java isimlerinde iki örnek problemi incelemiştik. Şimdi de aynıgruptan metotvesınıfdeg3.java programını inceleyelim. Sınıfa ait her değişkeni başına this. getirerek kullanabiliriz. Fakat this kullanımı mutlaka gerekli değilse kullanılmaması tavsiye edilir. Örneğin yukarıdaki kurucu metot kutu //kurucu metot kutu kutu(double en,double boy,double yukseklik) { this.en=en this.boy=boy this.yukseklik=yukseklik } şeklinde this değişkenini kullanarak da yazılabilirdi. Burada girdi değişkeni ile sınıf değişkeninin adı aynı verilmiştir. This sol taraftaki değişkenin sınıf değişkeni olduğunu bilgisayara bildirmektedir. Burada en boy ve yükseklik değişkenleri private olarak tanımlanmıştır. Bu değişkenlere ulaşım (değerlerini değiştirme veya çağırma) ancak ulaşım metodları adını verdiğimiz metodlar aracılığıyla yapılabilir. import javax.swing.JOptionPane // giriş çıkış class Kutu { private double en private double boy private double yukseklik //kurucu metod kutu Kutu(double e,double b,double y) { en=e boy=b yukseklik=y } //sınıf değişkenlerini değiştirme set metodu public void setKutu(double e,double b,double y) { en=e boy=b yukseklik=y } //sınıf değişkenlerine ulaşma (get) metotları public double getEn() {return en } public double getBoy() {return boy } public double getTukseklik() {return yukseklik } //bu metot kutunun hacmini hesaplar (işlem- hesap) metodu public double hacim() { return en*boy*yukseklik } //string çıktı metodu public String toString() { return( en = +en+ boy = +boy+ yükseklik = +yukseklik+ \n + Hacim = +hacim()+ \n ) } } class kututesti4 { public static void main(String args[]) { Bu programın çıktısı Burada da sınıf değişkenleri protected olarak tanımlanmıştır. Aşağıda dort işlem (toplama cıkarma carpma bolme yapan dortislemhesapmakinasi sınıfını görüyorsunuz. sonuc=x } public double oku() { return sonuc } public void C() { sonuc=0 } public void M(double x) { //hafızaya al hafiza=x } public double MR() { //hafızayı çagır return hafiza } public void MTopla(double x) { hafiza+=x } public void Mcikar(double x) { hafiza-=x } public double isaretdegistir() { sonuc=-sonuc return sonuc } public String toString() { return +sonuc } public String MtoString() { return +hafiza } } Bu sınıfta (class) sınıf değişkeni sonuc değerlerinin değiştirilmesi için gir metotu yazılmıştır. Bunun sebebi programlarda sınıfa ait değişkenlere dışarıdan direk ulaşımın önlenmesini sağlamaktır. İyi programlama şartlarından birisi sınıfın değişkenlerine sadece o sınıfın metotları üzerinden ulaşmaktır. Herkese serbest ulaşım verilmez. Hatta bunu saglamak için değişkenlerin başına sadece bu sınıfa aittir dışarıdan kullanılamaz anlamındaki private sözcügü getirilebilir. private sözcüğü yerine ancak dışarda bu sınıftan yaratılana yeni sınıflar (akraba sınıflar) kullanabilir, yabancı sınıflar kullanamaz anlamındaki protected sözcüğü de sık olarak kullanılır. Protected sözcügü aynı directorydeki diğer dosyaları da (public) gibi kabula eder, fakat başka direktorylerdeki dosyalar için private olarak davranır. Aynı işlemi yapmak için aşağıdaki üç yoldan birini kullanabiliriz. Hafiza değişkeninin değerinin değiştirilmesi için ise h.M(3.0) metotu çağırılır. Sınıf değişkenlerinin dış dünyadan gizlenmesi niçin gereklidir. Bunun en önemli sebebi program güvenliğinin sağlanmasıdır. Değişkenlere dışarıdan direk müdahale edilebilirse, değerleri de değiştirilebilir. Örneğin değişkeni bir banka hesabı veya şirketin özel hesabı olarak düşünebiliriz. Dış dünyadan gizlenmemiş bir değişkenin değeri değiştirilebilir. Private veya protected değişkenler ise ancak metotlar üzerinden değiştirilebilir, burada yeterli güvenlik önlemlerini almak mümkündür. Kalıtım için sınıf(class) tanımında extends kelimesi kullanılır. Eğer bir sınıftan daha alt sınıflara kalıtım yoluyla aktarma yapılacaksa private değişken türü yerini protected değişken türüne bırakır. Protected private deyiminin aynıdır. Fakat kalıtımla değişkenlerin aktarıldığı alt sınıflara değişkenleri görme izni verir. Private terimi ise kalıtımla aktarılan alt sınıflardan bile o değişkenleri saklar. Programda da görüleceği gibi daire sınıfının tanımı public class daire extends nokta terimiyle yapılmıştır. Ayrıca daire sınıfının kurucusu yazılırken nokta sınıfının kurucusu direk olarak super(a,b) terimiyle çağırılmıştır. Burada önemli bir noktayı hatırlatalım Java dilindeki bir sınıf sadece bir tane başka sınıfın metot ve değişkenlerini kalıtım yoluyla aktarabilir. Daire sınıfı nokta sınıfından Kalıtım (inheritance) yoluyla türetilmiştir. import nokta public class daire extends nokta { protected double yaricap public daire() { //daire kalıtım yaptigi nokta sınıfının kurucu metotunu // super deyimi ile cagirabilir. super(0,0) yaricapgir(0) } public daire(double r, double a, double b) { super(a,b) yaricapgir(r) } public void yaricapgir(double r) { if(r = 0.0) yaricap=r else yaricap=0.0 } public double yaricapoku() { return yaricap } public double alan() { return 3.14159*yaricap*yaricap } public String toString() { return Merkez = + [ +x+ , +y+ ] + Yaricap= +yaricap } } Kalıtım yoluyla aktarılan metotlar ve değişkenler yeni programda o programın içinde yazılmış gibi aynen kullanılabilir. Buna nesne yoluyla aktarım (ingilizce composition) diyoruz. Nokta sınıfı daire1 sınıfında merkez adlı nesne olarak tanımlanmıstır. import nokta public class daire1 { protected double yaricap protected nokta merkez public daire1() { merkez=new nokta(0,0) yaricapgir(0) } public daire1(double r, double a, double b) { merkez=new nokta(a,b) yaricapgir(r) } public void yaricapgir(double r) { if(r = 0.0) yaricap=r else yaricap=0.0 } public double yaricapoku() { return yaricap } public double alan() { return 3.14159*yaricap*yaricap } public String toString() { return Merkez = + [ +merkez.x+ , +merkez.y+ ] + Yaricap= +yaricap } } Baska bir sınıftan kalıtım yoluyla türeyen sınıfın(dairenin noktadan kalıtım yoluyla türemesi gibi), üst sınıfın adresi(tanımı) üzerinden programın içinde aktarımı mümkündür. İnit metotunda p ve c nesnelerinin adresleri kurucu metotu new deyimiyle taşıyarak tanımlanmiştir. Dahasonra noktaref=d deyimiyle aslında daire sınıfından olan d nesnesi nokta sınıfından tanımlanan noktaref nesnesinin adresine yüklenmiştir. Programda da görüldüğü gibi noktaref üzerinden daireyi kullanmak mümkündür çünkü nokta dairenin kalıtım yoluyla üst sınıfıdır. Aynı zamanda cast işlemcisi (daire) terimini kullanarak noktaref'i daireref'e aktarmak da mümkün olmuştur. Bu aktarma nokta dairenin super sınıfı olmasa başarılamazdı. Bazen sadece bu süper sınıf aktarımını saglamak amacıyla sınıf hiyerarşisinin en tepesine aslında belli bir görevi olmayan abstract sınıflar yerleştirilir. Bu sınıfın alt sınıfları olarak tanımlanan tüm sınıflar bu sınıf adresinden yararlanılarak aktarılabilir. Abstract sınıfların tanımında abstract sözcüğü kullanılır. Abstract tür metotların içinde metotların sadece başlıkları verilip tanımları yapılmıyabilir. (metotun ana gövdesi tanımlanmıyabilir). Abstract super sınıfının kullanılmasına şöyle bir örnek verebiliriz sekil isimli bir abstract sınıfın alt sınıfları olarak daire,üçgen,dikdörtgen ve kare sınıflarını oluşturduğumuzu ve bu sınıfların herbirinin kendi şeklini çizecek ciz metotunu içerdiğini düşünelim. Programı yazarken abstract sınıf sekilde de alan metotu tanımı yaparız. Ve sekil sınıfından bir nesne tanımlarız. Program çalışırken sekil üzerinden istediğimiz alt şeklin çizimi dinamik olarak her biri için ayrı bir adres tanımlamadan mümkün olur. Aynı şekilde bir nümerik analiz programı yazarken, örneğin her değişik fonksiyon için ayrı ayrı integral metotu yazma yerine abstract tür bir fonksiyon için integral programını yazar ve gerçek foksiyonumuzu tanımladığımız sınıfı bu abstract sınıfın alt sınıfı olarak tanımlarız. Bu kavramı daha sonraki bölümlerimizde daha geniş örneklerle açıklamaya çalışacağız. Bu yüzden C++ gibi dillerde dinamik nesne tanımlarında mutlaka yer alması gereken nesneyi silme metotları javada o kadar gerekli değildir. Fakat eğer kendiniz metlaka bir nesneyi acil olarak silmek isteseniz finalize() isimli bir metotu sınıfınızda tanımlayıp kullanabilirsiniz. Örnek olarak aşağıdaki metotu verebiliriz. protected void finalize() throws Throwable { super.finalize() } Boyutlu değişkenlere referans indeks numarası kullanılarak ulaşılır. Genel olarak bir boyutlu değişkenler Değişken_türü değişken_ismi[] veya Değişken_türü[] değişken_ismi Şeklinde tanımlanır. Birinci tanımın kullanılması daha yaygındır. İki tanım arasında bilgisayar açısından bir fark mevcut değildir. Bir örnek verecek olursak int ayın_gunleri[] veya int[] ayın_gunleri Bu tanımlar her ne kadar haftanın_gunleri nin boyutlu bir değişken olduğunu belirtiyorsa da kesin boyutunu bildirmemektedir. Boyutlu değişkenin tam boyutunu tanımlamak ve bilgisayar hafızasındaki yerini tam olarak saptamak için Değişken_ismi=new Değişken_türü[değişken_boyutu] Terimi kullanılır. Bunu bir önceki örneğe uygularsak Ayın_gunleri=new int[12] Boyutlu değişkeni bir kere tanımladıktan sonra onun içindeki her alt değere indeksi üzerinden ulaşmak mümkündür. Örnegin ayın_gunleri[0] = 31 ayın_gunleri[1] = 28 gibi. . İndeks değişkeni herzaman sıfırdan başlar. Küçük bir örnek sınıfta bu kavramı daha açık olarak vermeye çalışalım. * class boyut { public static void main(String args[] ) { int ayin_gunleri[] ayin_gunleri=new int[12] ayin_gunleri[0]=31 ayin_gunleri[1]=28 ayin_gunleri[2]=31 ayin_gunleri[3]=30 ayin_gunleri[4]=31 ayin_gunleri[5]=30 ayin_gunleri[6]=31 ayin_gunleri[7]=31 ayin_gunleri[8]=30 ayin_gunleri[9]=31 ayin_gunleri[10]=30 ayin_gunleri[11]=31 System.out.println( Nisan ayi +ayin_gunleri[3]+ gun ceker ) } } * class boyut1 { public static void main(String args[] ) { int ayin_gunleri[]={31,28,31,30,31,30,31,31,30,31,30,31} System.out.println( Nisan ayi +ayin_gunleri[3]+ gun ceker ) } } Boyutlu değişkenin toplam boyutuna da sayı.length değişkeniyle ulaşıyoruz. Daha önceki birçokprogramlama dilinde bu mümkün değildir ve boyutlu değişkenin boyutunun bildirilmesi gerekir. } Şimdi de bir applet örneğinde tek boyutlu değişkenleri kullanalım. Daha önce zarApplet.java programını incelemiştik. Şimdi bu programa her bir zar yüzeyinin atılış frekanslarını ekleyelim. Toplam altı yüz olduğundan birden altıya kadar her sayının kaç kere geldiğini saydırmamız gerekir. Bunun için bir boyutlu zarfrekansi değişkenini tanımlayacağız. * import java.awt. * import java.applet.Applet import java.awt.event. * public class zarfrekansiSWF extends JFrame implements ActionListener { int toplamzaratisi=0 int toplam=0 JTextField ilkzar,ikincizar JButton salla //zar atma düğmesi JTextArea cikti int zar1,zar2 int zarfrekansi[] public static int zar() { return 1+(int)(Math.random()*6) } public zarfrekansiSWF() { //programi baslat super( Zar frekansı swing JFrame ) zarfrekansi=new int[6] Container c=getContentPane() c.setLayout(new FlowLayout()) ilkzar=new JTextField(10) // JTextfield sinifi ilkzar nesnesini yarat c.add(ilkzar) // ilk zar nesnesini pencereye ekle ikincizar=new JTextField(10) // Textfield sinifi ikincizar nesnesini yarat c.add(ikincizar) // ikinci zar nesnesini pencereye ekle salla=new JButton( Zari salla ve at ) c.add(salla) salla.addActionListener(this) cikti=new JTextArea() cikti.setBackground(c.getBackground()) c.add(cikti) } public void actionPerformed(ActionEvent e) { String s= zar1=zar() zar2=zar() ilkzar.setText(Integer.toString(zar1)) ikincizar.setText(Integer.toString(zar2)) toplam+=(zar1+zar2) toplamzaratisi++ // not boyutlu degisken indeksi 0 dan basliyor. zarfrekansi[zar1-1]++ zarfrekansi[zar2-1]++ s+= toplam = +toplam+ Atilan zar sayisi = +toplamzaratisi+ \n for(int i=0 i<6 i++) { s+=zarfrekansi[i]+ kere +(i+1)+ atildi \n } cikti.setText(s) repaint() } //===================================================== public static void main(String[] args) { zarfrekansiSWF pencere= new zarfrekansiSWF() pencere.addWindowListener(new BasicWindowMonitor()) pencere.setSize(450,200) pencere.setVisible(true) } } Normal boyut tanımı yapıldıktan sonra, boyuttaki her nesne teker teker tanımlanır. İki boyutlu değişkenler en fazla tablo veya matris gibi satır ve sütun olmak üzere iki boyutta gösterilmesi gereken büyüklükleri oluşturmak için kullanılır.Java iki boyutlu değişkenleri direk olarak açamaz. Tek boyutlu değişkenlerin yine tek boyutlu degişkenini açar. Sonuç olarak iki boyut sağlanmış olur. Örnek verecek olursak int b[][]=new int[3][4]. Genel olarak ilk parantes satır sayısı, ikinci parantez sütun sayısı olarak kabul edilir. Buna göre b değişkenini şöyle düşünebiliriz b[0][0] B[1][0] B[2][0] b[0][1] b[1][1] b[2][1] b[0][2] b[1][2] b[2][2] b[0][3] b[1][3] b[2][3] Iki boyutlu değişken de bir boyutlu değişkenlerde olduğu gibi degerleri direk olarak yüklüyebiliriz, ve yükleme sırasında boyutları da tayin edebiliriz. Örneğin int b[][] = {{1,2},{3,4}} Terimi bize aşağıdaki tabloyu tanımlar 1 3 2 4 b[0][0] b[1][0] b[0][1] b[1][1] Boyutlu değişkenlere ulaşım. for döngülerinin en çok kullanıldığı yerlerden biridir. Satırların boyutuna a.length, sütunların boyutuna ise a[satır].length terimiyle ulaştık. Bu tanım bize toplam satır ve sütun boyutunu direk tanımlar, ve kullanımda yeterince esneklik sağlar. Örneğin eğer int sıcaklık[] = new int[24] deyimiyle tanımlanan sicaklık sicakligidegistir(sıcaklik) terimiyle sicakligidegistir metotuna aktarılabilir. Metot tanımlanırken, sıcaklığın boyutlu değişken olduğu tanımlanmalıdır double void sicakligideğiştir(int sicaklik[]) { .......................... } gibi. Metotların çıktı değişkenleri de çok boyutlu olarak tanımlanabilir ve kullanılabilir. Örneğin public static double[][] inversematris(double[][] a) gibi. Ancak indirek yollarla boyutun değiştirilmesi mümkündür. Bu yol önce yeni boyutta bir boyutlu değişken tanımlamak, sonra boyutlu değişkenin içerisindeki değerleri bu yeni değişkene aktarmak ve sonra orijinal boyutlu değişkenin adresini yeni oluşturulan boyutlu değişken adresiyle değiştirmek şeklinde yapılır. Daha detaylı bir örnekle boyut değiştirmeyi inceleyelim. Program1. 4.5-1 boyutlu değiştirme örnegi doubleBoyut.java public class doubleBoyut { //sınıf değişkenleri public double a[] public int length public doubleBoyut(double x[] ) { length=x.length a=new double[length] for(int i=0 i<length i++) a[i]=x[i] } public doubleBoyut(int n) { a=new double[n] length=a.length } public void boyutEkle(int n) { if(n>0) { int z=a.length+n double[] b=new double[z] for(int i=0 i<a.length i++) {b[i]=a[i] } a=b length=a.length } } public void boyutEkle() { boyutEkle(1) } public void boyutAzalt(int n) { int z=a.length-n if(z>1) { double[] b=new double[a.length-n] for(int i=0 i<z i++) b[i]=a[i] a=b } else { double[] b=new double[1] b[0]=a[0] a=b } length=a.length } public void boyutAzalt() { boyutAzalt(1) } public double getValue(int i) { return a[i] } public double[] getValue() { return a } public void setValue(double x,int i) { a[i]=x } public void setValue(double[] x ) { length=x.length a=new double[length] for(int i=0 i<length i++) { a[i]=x[i] } } public String toString(int i) { return String.valueOf(a[i]) } public String toString() { String s= for(int i=0 i<length i++) { s+=a[i]+ } s+= \n return s } } DoubleBoyut sınıfında boyutu değiştirilebilen değişken (nesne) tanımladık. }} Program çıktısı Sınıfları kalıtım yoluyla birbirinden türetirken eğer ortak özellikli sınıflar yaratıyorsak, bütün bu sınıf gurubunun en tepesine abstract bir sınıf koyabiliriz. Abstract sınıf diğer sınıfların kullanılmasında extends yoluyla tepe sınıflık etmek ve bütün alt sınıflara ortak bir adres çıkış noktası sağlamak dışında bir görevi yoktur. Diğer bir deyimle bu sınıflar hiçbir zaman doğrudan kullanılmazlar. Ancak alt sınıflarından birini referans olarak göstermek ve onlara dolaylı yoldan ulaşmak amacıyla kullanılırlar. Kavramı daha iyi verebilmek için bir örnek problem oluşturalım. Daha önce sınıf kavramını açıklarken kullandığımız nokta,daire sınıflarını hatırlıyacaksınız. Şimdi bu sınıfların üzerine sekil isimli bir abstract sınıf ekleyerek tekrar oluşturalım. public String isim() {return nokta } } super(0,0) yaricapgir(0) } public daireX(double r, double a, double b) { super(a,b) yaricapgir(r) } public void yaricapgir(double r) { if(r >= 0.0) yaricap=r else yaricap=0.0 } public double yaricapoku() { return yaricap } public double alan() { return Math.PI*yaricap*yaricap } public String toString() { return Merkez = + [ +x+ , +y+ ] + Yaricap= +yaricap } public String isim() {return daire } } public String toString() {return super.toString()+ yukseklik= +yukseklik } public String isim(){return silindir } } Diğer bir deyimle nokta daire ve silindirin adresleri sekil sınıfı nesneye aktarılmış ve bu nesne üzerinden üç sınıfta indirek olarak kullanılmıştır. Bu indirek kullanımın bize temel faydası, Programımıza yeni sınıflar eklediğimizde daha kolay ve az program değiştirerek uyumu sağlayabilme yeteneğidir. Orneğin yukarıdaki program sınıfları gurubuna koni eklemek istersek bütün yapacağımız koni sınıfını tanımladıktan sonra, sekil nesnesi a nın boyutunu bir arttırarak aynı hesaplamaya koniyide ilave etmekten ibaret olacaktır. Bu tür uygulamalar bilgisayar kodunun değişim gereksinimini minimuma indirgediğinden nesne kokenli bilgisayar programcılığının onemli uygulamalarından biridir. Ve eğer başka bir sınıf halihazırda o sınıfa kalıtım yoluyla bağlanmışsa, bizim yeni bir sınıfı üst sınıf olarak kullanma olasılığımız yok olmuş demektir. Fakat bazı uygulamalar için bu gerekebilir.Bu zaman interface kullanırız. Interface de abstract sınıf gibi kendi içinde bir işlem yapmaz. Sadece öbür sınıfların bağlanmasını teşkil eden bir adres noktası olarak iş görür. İnterface'i bir başka sınıfa bağlamak gerektiğinde extends yerine implements sözcüğü kullanılır. Abstract sınıflar kendi başına bir bütün teşkil edebilmelerine rağmen interface'in sadece kendi başına bir anlamı yoktur. Interface sınıfında yer alan tüm metod ve değişkenlerin alt sınıflarda tanımlanması gerekir. Örnek olarak bir önceki problemi interface ile tanımlıyalım. Görüldüğü gibi burada nokta sınıfının bir öncekinden farkı implements kelimesinin kullanılmış olaması ve bos alan ve hacim metotlarının bu dosyada yazılmasının gerekmesinden ibarettir. Interface programla yapılan ve alt sınıflarda bu metodların (veya değişkenlerin) tanımlanacağına dair yapılan bir kontrattır.DaireY ve silindirY sınıflarında bir fark mevcut degildir. İki seklin işlemsel sonuçları arasında da bir fark mevcut değildir. Yukardaki örneğe parelel olarak burada da daireY,SilindirY tanımlarını yapalım ve interfaceTesti_2000.java programında test edelim. Program 15.2-3 interface sekilY'den implements kelimesiyle türeyen noktaY sınıfından extends yoluyla türeyen daireY sınıfı(daireY.java dosyasında yer alıyor) public class daireY extends noktaY { protected double yaricap public daireY() {//daire kalıtım yaptığı nokta sınıfının kurucu metodunu // super deyimi ile cagirabilir. super(0,0) yaricapgir(0) } public daireY(double r, double a, double b) { super(a,b) yaricapgir(r) } public void yaricapgir(double r) { if(r >= 0.0) yaricap=r else yaricap=0.0 } public double yaricapoku() { return yaricap } public double alan() { return Math.PI*yaricap*yaricap } public String toString() { return Merkez = + [ +x+ , +y+ ] + Yaricap= +yaricap } public String isim() {return daire } } Ve grafik (Graphics) sinifinina ait drawString metotunu kullanarak applete yazı yazdırmıştık. Şimdi bu sınıfın diğer özelliklerini ve metotlarını öğreneceğiz. Graphics sınıfı java.lang.Object sınıfının altında yer alır. Bu gurupta aynı zamanda grafik çiziminin çeşitli fazlarında kullanılan java.awt.Color, java.awt Font, java.awt.FontMetrics, java.awt, java.awt.Graphics, java.awt.Polygon yer alır. Daha detaylı grafik çizme işlemleri tanımlayabilen java.awt. Graphics2D paketi java.awt.Graphics paketinden türetilmiştir. Ayrıca java.awt.BasicStroke, java.awt.GradientPaint, java.awt.TexturePaint gibi temel grafik alt programları da java.lang.Object altında tanımlanmıştır. Temel şekilleri çizdirmeye yarayan java.awt.geom.GeneralPath, java.awt.geom.Line2D, java.awt.geom.RectangularShape de java.lang.Object altında tanımlanır. java.awt.geom.Arc2D, . java.awt.geom.Ellipse2D, . java.awt.geom.Rectangle2D, . java.awt.geom.RoundRectangle2D gibi çizim paketleri de java.awt.geom.RectangularShape paketinin alt paketleri olarak tanımlanmıştır. Graphics sınıfı, yazı yazma, çizgi çizme, dikdörtgen, oval çizme gibi bir dizi metotu barındırır. Bunun dışında awt kütüphanesinin önemli bir sınıfı da Color sınıfıdır. Color sınıfı rekleri tanımlar ve değişik renklerin kullanımına imkan verir. Font sınıfı grafikte kullanılan yazıların fontlarının (yazı tipinin ve boyutunun) belirlenmesi amacıyla kullanılır. FontMetrics sınıfı fontların boyutlarının belirlenmesiyle ilgili metotları içerir. Polygon sınıfı polygon çizimiyle ilgili metotları barındırır. Bu metodların bir kısmını burada göreceğiz. Temel olarak Graphics ve Graphics2D sınıflarını grafik çiziminde kullanacağız, Bu işlemi yaparken de diğer tüm yardımcı grafik sınıflarından yararlanacağız. Graphics2D sınıfı daha yeni olarak tanımlanmış ve Graphics sınıfından türetilmiş bir sınıftır. Fakat çok daha komleks grafik çizim kapasitelerini barındırır. Java appletlerinde çizim yaparken ilk hatırlamamız gereken nokta, koordinat merkezinin ekranın sol üst köşesi olduğudur. X ekseni sola doğru, Y ekseni aşağıya doğru gider. Bütün bilgisayar diileri ve ekranı grafik programlamalarında standartdır. Grafik sınıfı java.lang.Object sınıfının alt sınıflarındandır. Grafik çizme amacıyla genellikle Graphics sınıfından bir nesne paint veya paintComponent metotunun içinde çağırılır. Paint metotunun tanımı şöyledir public void paint (Graphics g) Bu tanım Applet, Japplet,JFrame extend etmiş programlardan çağırılabilir. Paint metodu tüm bu üç sınıfın türetildiği Component sınıfında tanımlanmıştır. javax.swing sınıfı altında tanımlanan JComponent sınıfında ise paintComponent metodu tanımlanmıştır. JComponentin alt metodu JPanel bu metodu kullanır. Tanımı paint metoduna benzer public void paintComponent (Graphics g) paint veya paintComponent metodları Applet, Japplet, Frame, JFrame, Panel, JPanel sınıfları tarafından direk olarak program açıldığında çağırılır. Kullanıcı tarafından çağırılmaz. Tekrar kullanıcı tarafından çağırılması gerektiğinde ise repaint metotu kullanılır ve repaint metotu üzerinden indirek olarak paint metotu çağırılır. Bu metodun tanımı public void repaint () şeklindedir. İkinci ilginç metod update metodudur. Bu metod public void update (Graphics g) şeklinde tanımlanmıştır. Update metodu çağırıldığında Graphics metodu sistem tarafından otomatik olarak gönderilir. Graphics2D sınıfı Graphics sınıfının bir alt sınıfı olarak tanımlanmıştır. Bu sınıf Graphicss sınıfına göre çok daha kompleks çizimler yapabilen metodlara sahiptir. Burada graphics ve Graphics2D de yer alan bazı sınıf ve çizim tekniklerini yakından inceleyeceğiz. public abstract void drawString( String stringYazı, int x,int y) public void drawChars( char charYazı[], int baslangıçindeksi,int yazılacakharfsayısı, int x,int y) public void drawBytes( byte byteYazı[], int başlangıçindeksi,int yazılacakharfsayısı, int x,int y) drawString metotu bir string değişkenini verilen x ve y koordinatlarından başlayarak çizer. DrawChars bir boyutlu Char tipi değişken dizisini başlangiçindeksi indeksinden baslayarak yazılacakharfsayısı kadar kısmını x ve y koordinatlarından başlıyarak çizer. DrawByte metotu da drawChars metotu gibidir tek değişikliği Byte türü boyutlu değişken kullanmasıdır. * import java.awt.event. * import java.awt.geom. * import javax.swing. * public class ciz2DSWF_2000 extends JFrame { final static Color bg = Color.white final static Color fg = Color.black final static Color red = Color.red final static Color white = Color.white private String s = Bunu drawString Metoduyla yazdır private char c[]={'k','a','r','e','k','t','e','r','l','e','r'} public ciz2DSWF_2000() { //Initialize drawing colors super( String character çizimi ) setBackground(bg) setForeground(fg) } public void paint(Graphics g) { Graphics2D g2 = (Graphics2D)g Burada hemen belirtelimki swing sınıflarını kullanırken Graphics2D sınıfları kullanmak zorunda değiliz, ama burada genel olarak swing ve Graphics2D kullanımlarını birlikte sunacağız. Bu programın çıktısı da bir önceki programın çıktısında olduğu gibidir Bu üç renk monitorde 0-255 arası değerler alabilir. Üç rengin karışımı toplam 256*256*256 renk tanımlar. Color sınıfı kurucu metotları şu şekilden tanımlanır. public Color( int kirmizi,int yesil,int mavi) //her renk 0-255 arası public Color(float kirmizi,float yeşil,float mavi) //her renk 0.0-1.0 arası Color sınıfında ayrıca renk degerlerini okuyabildiğimiz public int getRed() // Kırmızı tonunu oku public int getGreen()//Yesil tonunu oku public int getBlue()//Mavi tonunu oku public abstract Color getColor() //rengi oku metotları ve rengi değiştirebildiğimiz public abstract Color setColor(Color c) metotu mevcuttur. Renk portakal Pembe camgöbeği Mor RGB değeri 255,200,0 255,175,175 0,255,255 255,0,255 public final static Color yellow public final static Color black public final static Color white public final static Color gray public final static Color lightGray public final static Color darkGray public final static Color red public final static Color green public final static Color blue Sarı Siyah Beyaz Gri Açık gri Koyu Gri kırmızı Yeşil mavi Color sınıfının daha iyi anlaşılabilmesi amacıyla Color sınıfının bir alt sınıfı olan renk sınıfını tanımladık. * import java.awt. * import java.applet.Applet public class renk extends Color { public final static renk kirmizi=new renk(255,0,0) public final static renk mavi=new renk(0,0,255) public final static renk siyah=new renk(0,0,0) public final static renk camgobegi=new renk(0,255,255) public final static renk koyugri=new renk(64,64,64) public final static renk gri=new renk(128,138,128) public final static renk yesil=new renk(0,255,0) public final static renk acikgri=new renk(192,192,192) public final static renk mor=new renk(255,0,255) public final static renk portakal=new renk(255,200,0) public final static renk pembe=new renk(255,175,175) public final static renk beyaz=new renk(255,255,255) public final static renk sari=new renk(255,255,0) public final static renk acikmavi=new renk(150,206,237) public final static renk lacivert=new renk(0,0,128) //burada kendi yeni renginizi tanımlayabilirsiniz. public renk(float kirmizi,float yesil, float mavi) {super(kirmizi,yesil,mavi) } public renk(double kirmizi,double yesil, double mavi) {super((float)kirmizi,(float)yesil,(float)mavi) } public renk(int kirmizi,int yesil, int mavi) {super(kirmizi,yesil,mavi) } public renk(int RGB) {super(RGB) } public renk(renk r) {super(r.getKirmizi(),r.getYesil(),r.getMavi()) } public int getKirmizi() {return getRed() } public int getYesil() {return getGreen() } public int getMavi() {return getBlue() } public int getKYM() {return getRGB() } public Color toColor() {return (Color)this } public static renk toRenk(Color r) {return (renk)r } public String toString() {return renk[ kirmizi +getKirmizi()+ mavi +getMavi()+ yesil +getYesil()+ ] } //metodlar bu metodlar direk olarak extends sözcüğüyle (bir üst sınıfta) tanımlanmıştır //static int HSBtoRGB(float hue,float saturation,float brightness) //getRed(),getGreen(),getBlue(),getRGB() } Renk sınıfını bir çok yerde Color sınıfı yerine kullanabiliriz. Kullanamadığımız durumlarda cast işlemcisi (Color) kullanılabilir. Arka plan rengi ise public void setBackground(Color c) Metotunu kullanarak maviye dönüştürülmüştür. Aynı programın JApplet eşidi olan, aynı zamanda java komutuyla kendi çerçevesini de oluşturabilen bir eşdeğerini verelim. Renk2D sınıfında Graphics2D sınıfı kullanılmaktadır. Grafik kalitesini karşılaştırabilirsiniz. * import java.awt.event. * import java.awt.geom. * import javax.swing. * public class Renk2D extends JApplet { private int kirmizi,yesil,mavi public void init() { kirmizi=100 yesil=255 mavi=125 setBackground(new Color(0,0,255)) setForeground(new Color(kirmizi,yesil,mavi)) } Renk2D sınıfının çıktısı Bu programı kullanarak renk grafik kutusunun rengini değiştirebildiğimiz renkSeciciSWF swing JFrame programı aşağıda verilmiştir. * // java swing sinifini cagir import java.awt. * // java pencere kullanma sinifini cagir import java.awt.event. * // java pencereyi dinleme sinifini cagir import BasicWindowMonitor public class renkSeciciSWF_2000 extends JFrame implements ActionListener { // Renk secme ornegi JButton renkdegistir Color r=Color.lightGray Container c // pencereyi baslatma metodu public renkSeciciSWF_2000() { super( JColorChoser ) c=getContentPane() c.setLayout(new FlowLayout()) renkdegistir=new JButton( renk değiştirmek için düğmeye basınız ) renkdegistir.addActionListener(this) c.add(renkdegistir) } // girdi alanindaki olan olaylari dinleme metodu public void actionPerformed(ActionEvent e) { r=JColorChooser.showDialog(this, Renk seçiniz ,r) if(r==null) r=renk.acikgri c.setBackground(r) repaint() } //===================================================== public static void main(String[] args) { renkSeciciSWF_2000 pencere= new renkSeciciSWF_2000() pencere.addWindowListener(new BasicWindowMonitor()) pencere.setSize(350,200) pencere.setVisible(true) } } Bu programın içerisinde çağırılan r=JColorChooser.showDialog(this, Renk seçiniz ,r) metodu java kütüphanesinde yer almaktadır. ShowDialog metodu bize Color sınıfındaki renk değişkenini aktarmakta ve c.setBackground(r) komutuylada arka plan renklerini değiştirmektedir. * import java.awt.event. * import java.awt.geom. * import javax.swing. * public class stil2D extends JApplet { public void init() { setBackground(Color.white) setForeground(Color.black) } public void paint(Graphics g) { Graphics2D g2 = (Graphics2D) g String stilListesi[] stilListesi=getToolkit().getFontList() int y=15 for(int i=0 i<stilListesi.length i++) { g2.drawString(stilListesi[i],15,y) y+=15 } } public static void main(String s[]) { JFrame f = new JFrame( stil2D ) f.addWindowListener(new WindowAdapter() { public void windowClosing(WindowEvent e) {System.exit(0) } }) JApplet applet = new stil2D() f.getContentPane().add( Center , applet) applet.init() f.pack() f.setSize(new Dimension(550,300)) f.show() } } Public Font( String s, int yazı_sitili, int harf_boyutu) Bir appletin yazı sitili Graphics sınıfındaki setFont metotuyla değiştirilebilir. * import java.awt.event. * import java.awt.geom. * import javax.swing. * public class RenkFont2D extends JApplet { private int kirmizi,yesil,mavi public void init() { kirmizi=100 yesil=255 mavi=125 setBackground(new Color(0,0,255)) setForeground(new Color(kirmizi,yesil,mavi)) } Bu metot Graphics sınıfında tanımlanmıştır. Kurucu metotu Public abstract void drawLine( int x1, // ilk noktanın x koordinatı int y1, //ilk noktanın y koordinatı int x2, // ikinci noktanın x koordinatı int y2) //ikinci noktanın y koordinatı Graphics2D sınıfında ise çizgi çiziminde java.awt.geom kütüphanesinde tanımlanan Line2D sınıfı, Graphics2D sınıfındaki draw metoduyla birlikte kullanılır. * import java.applet.Applet import java.awt. * import java.awt.event. * import java.awt.geom. * import javax.swing. * import renk public class cizgiSWF_2000 extends JFrame { final static Color bg = Color.white final static Color fg = Color.black final static Color red = Color.red final static Color white = Color.white public cizgiSWF_2000() { //Initialize drawing colors super( çizgi çizimi ) setBackground(bg) setForeground(fg) g2.setPaint(Color.black) Grafik çizim rengini siyah olarak tanımlar. Burada bizim için yeni bir kavram olan noktalı çizgi çizmenin detaylarına biraz göz atalım. Noktalıçizgi oluşturmak için temel olarak setStroke metodunu kullanıyoruz. Bu metodun içinde Basic Stroke metodu bir nesne yaratıyoruz. BasicStroke türü nesne çizgi kalınlığı, çizgi bağlama sitili,çizgi ucu bitiş sitili ve çizgi-boşluk bilgisi içerir. Çizgi kalınlığı çizgi istikametine dik olarak ölçülür. Çizgi kalınlığı 1f (buradaki f sayının float temel değişken türü olduğunu belitir) 0.35277 milimetreye eşittir. Yalnız transformasyon kullanıldığında bu değişebilir. Transformasyonlara biraz sonra değineceğiz. Çizgi bağlama sitili iki çizginin birbirine bağlandığı noktadaki şeklini belirler. BasicStroke sınıfında 3 bağlanma sitili mevcuttur. Bunlar Çizgi ucu bitiş sitilleri boş çizgi ucunun şeklini belirtir. Yine temel olarak 3 BasicStroke çizgi ucu bitiş sitili mevcuttur. Çizgi boşluk bilgisi birbirini takip eden şeffaf ve görünür çizgi parçacıkları ve bunların boylarını tanımlar. Bir ara boşluk değişkeni ve çizgi boşluk çizgi boşluk olmak üzere bir seriden oluşur. cizgiSWF_2000.java programında çeşitli stoke tiplerini deneyebilirsiniz. Bu metot Graphics sınıfında tanımlanmıştır. Bu metotların tanımı Public abstract void drawRect( int x1, // üst tepe noktanın x koordinatı int y1, // üst tepe noktanın y koordinatı int en, // dikdörgenin genişliği int yukseklik) // dikdörtgenin yüksekliği Bu metota ilave olarak dikdörtgenin içini verilen renkte boyayan Public abstract void fillRect( int x1, // üst tepe noktanın x koordinatı int y1, // üst tepe noktanın y koordinatı int en, // dikdörgenin genişliği int yukseklik) // dikdörtgenin yüksekliği ve dikdörtgeni arkaplan renginde boyayan (silen) Public abstract void clearRect( int x1, // üst tepe noktanın x koordinatı int y1, // üst tepe noktanın y koordinatı int en, // dikdörgenin genişliği int yukseklik) // dikdörtgenin yüksekliği metotları mevcuttur. * public class dikdortgenCiz extends Applet { public void paint(Graphics g) { g.setColor(new Color(255,0,0)) g.drawRect(10,10,100,50) g.fillRect(129,10,100,50) } } Dikdörtgenin içini maviye boyamak için g2.setPaint(Color.blue) Rectangle2D dikdortgen2=new Rectangle2D.Double(50,50,100,40) g2.fill(dikdortgen2) kullanılabilir. Graphics2D de tek renk yerine değişen bir renk profiliyle boyamak da mümkündür. Örneğin final static Color beyaz=Color.white final static Color siyah=Color.black GradientPaint kirmizidanbeyaza=new GradientPaint(250,50,kirmizi,350,90,beyaz) g2.setPaint(kirmizidanbeyaza) Rectangle2D dikdortgen4=new Rectangle2D.Double(250,50,100,40) g2.fill(dikdortgen4) kodu dikdörtgeni kırmızıdan beyaza dönüşen bir spekturumla boyar. * import java.awt.event. * import java.awt.geom. * import javax.swing. * public class dikdortgenSWF_2000 extends JFrame { final static Color kirmizi=Color.red final static Color beyaz=Color.white final static Color siyah=Color.black public dikdortgenSWF_2000() { super( Dikdörtgen çizimi ) setBackground(Color.lightGray) çeşitli dikdörtgen çizimlerinin dikdortgenSWF_2000 JFrame çıktısında görünümü Graphics sınıfında Köşeleri yuvarlatılmış dikdörtgen çizmek içinse drawRoundRect metotu kullanılır Public abstract void drawRoundRect( int x1, // üst tepe noktanın x koordinatı int y1, // üst tepe noktanın y koordinatı int en, // dikdörgenin genişliği int yukseklik, // dikdörtgenin yüksekliği int koseeni, // yuvarlak kosenin eni int koseyuksekligi )// yuvarlak kosenin yuksekligi Bu metota ilave olarak dikdörtgenin içini verilen renkte boyayan Public abstract void fillRoundRect( int x1, // üst tepe noktanın x koordinatı int y1, // üst tepe noktanın y koordinatı int en, // dikdörgenin genişliği int yukseklik, // dikdörtgenin yüksekliği int koseeni, // yuvarlak kosenin eni int koseyuksekligi )// yuvarlak kosenin yuksekligi metotu da paralel olarak tanımlanmıştır. Yine bir örnek problemde bu tanımı kullanacak olursak Rakamsal örnek verirsek g2.setPaint(Color.blue) RoundRectangle2D dikdortgen2=new RoundRectangle2D.Double(50,50,100,40,15,15) g2.draw(dikdortgen2) kullanılabilir. Dikdörtgenin içini boyamak içinse g2.setPaint(Color.blue) RoundRectangle2D dikdortgen2=new RoundRectangle2D.Double(50,50,100,40,15,15) g2.fill(dikdortgen2) kodu kullanılabilir. Elbette bir önceki örnekte olduğu gibi spektrumlu boyama da mümkündür. * import java.awt.event. * import java.awt.geom. * import javax.swing. Bu metotların tanımları şu şekilde verilmiştir. Bu değişimler döndürme, köşedençekip uzatma gibi değişik işlemler olabilir. Bu değiştirme prosesini önce bir örnekle gösterelim, sonrada izah etmeye çalışalım. * import java.awt.event. * import java.awt.geom. * import javax.swing. * AffineTransform at2= AffineTransform.getShearInstance(xÇekişi,yÇekişi) Şekli x ekseninde xÇelişi kadar, y ekseninde yÇekişi kadar uzatır (orijinal şekilden elastik ve üst köşesi tutturulmuş şekilde) AffineTransform at1= AffineTransform.getScaleInstance(xBoyutFaktörü,yBoyutFaktörü) Şeklin boyutunu xBoyutFaktörü,yBoyutFaktörü faktörleriyle çarparak büyütür. AffineTransform at3= AffineTransform.getTranslateInstance(xTaşımaFaktörü,yTaşımaFaktörü) Şekli yerinden hareket ettirir. Orijinal transforma geri dönmek için g2.setTransform(new AffineTransform()) metodu çağırılabilir. * public class daireCiz extends Applet { public void paint(Graphics g) { g.setColor(new Color(0,0,255)) g.drawOval(10,10,50,50) g.fillOval(70,10,50,50) } } İçini boyamak için ise g2.fill(elips1) metodunu kullanırız. Yine örneğimizde kullanacak olursak * import java.awt.event. * import java.awt.geom. * import javax.swing. public static void main(String[] args) { elipsSWF_2000 pencere= new elipsSWF_2000() pencere.addWindowListener(new BasicWindowMonitor()) pencere.setSize(400,300) pencere.setVisible(true) } } çeşitli oval (elips) çizimlerinin elipsSWF_2000JFrame çıktısında görünümü * import java.awt.geom. * import java.awt.image. Şimdi de Graphics2D metoduyla arc çizdirmeye bakalım arc yukarda da bahsettiğimiz gibi tamamlanmamış bir elipstir. * import java.awt.event. * import java.awt.geom. * import javax.swing. * public class arcSWF_2000 extends JFrame { final static Color kirmizi=Color.red final static Color beyaz=Color.white final static Color siyah=Color.black public arcSWF_2000() { Metotların tanımı public abstract void drawPolygon( int x[], // x koordinat vektörü int y[], // y koordinatı vektörü int nokta sayısı) // nokta sayısı public abstract void drawPolyline( int x[], // x koordinat vektörü int y[], // y koordinatı vektörü int nokta sayısı) // nokta sayısı public abstract void drawPolygon( Polygon p) //Graphics sınıfı metotu public Polygon() //Polygon sınıfı public Polygon( int x[], // x koordinat vektörü int y[], // y koordinatı vektörü int nokta sayısı) // nokta sayısı Metot tanımlarından da görüldüğü gibi polygon int türü vektörle çizilebileceği gibi bu vektörü içinde barındıran Polygon sınıfı bir nesne kullanılarak ta çizilebilir. * import java.awt.event. * import java.awt.geom. * import javax.swing. * public class polygonSWF extends JFrame { g2.fill(yildiz) ile içi boyanmıştır. Programda setPAint kullanarak tesadüfi renkler seçilmiş ve yıldız çizimi doldurulmuştur. Programda kullanılan GeneralPath yildiz=new GeneralPath() Terimine özellikle dikkatinizi çekmek isteriz. Bu terim GeneralPath nesnesi yıldızı tanımlar. * import java.awt.event. * import java.awt.geom. * import javax.swing. Bu komut çizgileri daha düzgün hale getirir, fakat belli bir hesap ve hafıza kapasitesi harcar. Programı bu komutu çıkararak da çalıştırınız ve aradaki farkları inceleyiniz. Daha sonra bu şekiller g2.draw(sekil) komutuyla çizdirilmiştir. g2.fill(sekil) komutu burada kullanılmamakla birlikte, geçerli bir komuttur. Programda deneyiniz. Bu programda çizdirilen ikinci dereceden (quadratik eğriler) quadTo ve curveTo metodları kullanılarak oluşturulmuştur. * import java.awt.event. * import java.awt.geom. * import javax.swing. g2.draw3DRect(0,0,dx-3,dy-3,true) g2.draw3DRect(3,3,dx-7,dy-7,false) g2.setPaint(siyah) QuadCurve2D qc2=new QuadCurve2D.Double(0,125,140,225,225,150) g2.draw(qc2) QuadCurve2D qc2_1=new QuadCurve2D.Double(0,200,155,225,225,170) g2.setPaint(Color.blue) g2.fill(qc2_1) } //===================================================== public static void main(String[] args) { curve2SWF_2000 pencere= new curve2SWF_2000() pencere.addWindowListener(new BasicWindowMonitor()) pencere.setSize(400,300) pencere.setVisible(true) } } * import java.awt.event. * import java.awt.geom. * import javax.swing. //===================================================== public static void main(String[] args) { curve3SWF_2000 pencere= new curve3SWF_2000() pencere.addWindowListener(new BasicWindowMonitor()) pencere.setSize(400,300) pencere.setVisible(true) } } Resim önce getImage metotuyla bir Image sınıfı nesneye yuklenir, sonra drawImage metotuyla gösterilir. Burada ikinci ve üçüncü noktalar başlangıç x ve y koordinatlarıdır.Son olarak this resmin çizileceği appletiniçinde bulunulan sınıfın appleti olduğunu belirtmektedir. }} Bu bölümde veremediğimiz bir çok detayı javanın parasız olarak çekebileceğiniz döküman kütüphanesinde bulabilirsiniz. Profesyonel bilimsel bilgisayar ortamlarına ulaşmak için genelde belli bir ücret karşılığında aldığımız profesyonel programları kullanabiliriz. Örneğin Matlab oldukça güzel bir grafik ortamı sunmaktadır, ancak bu tür paketler programlama ortamını kendi dilleriyle sınırlandırmaktadır. Burada Java ortamında program yazan arkadaşlarımızın oldukça basit bir şekilde programlarına aktarabilecekleri genel maksatlı 2 boyutlu bir bilimsel grafik ortamı programı olan Plot sınıfının (ve ona bağlı çalışan sınıflar gurubu) java ortamında kullanımı tanımlanacaktır. Plot sınıfı tek bir dosya, bir dosya gurubu, java çok boyutlu değişkenleri, ve java fonksiyonlarından girdi alabilen, normal veya logaritmik ortamda çıktı verebilen, kübik şerit aradeğer, en küçük kareler ve ortogonal polinom en küçük kareler, Lagrange interpolasyonu gibi yöntemlerle yeterli olmayan verilerde ara değer hesaplayarak veriye eğri uydurabilen bir sistemdir. Burada Program kodlamasına girmeden programın kullanılması ile ilgili bilgi vermeye çalışacağız. * class PlotT1 { public static void main(String args[]) throws IOException {Plot pp=new Plot( in.txt ) pp.plot() }} Programda gördüğümüz ilk satır olan kurucu metod Plot pp=new Plot( in.txt ) veriyi aktardı ve pp.plot() deyimi de grafik penceresini oluşturdu.Bu ikinci deyim hemen her zaman pencereyi açma komutu olarak kalacaktır. Pencereyi kapama komutu verilmemiştir. Elle kapatılacaktır. Grafik ortamının ikinci sayfasına baktığımızda değiştirilebilecek çeşitli parametreler görüyoruz. Bunlar eğride kullanılan çizgi çeşitleri, renk parametresi, grid, plot başlıkları, ek başlıklar, logaritmik skala gibi özelliklerdir. Bu özellikler değiştirilerek grafik daha küçük bir alt bölgede incelenebilir. Sayfa istenilen ölçeklerde karelere ayrılabilir. Listeden seçilen çeşitli grafik seçenekleri kullanılabilir. * class plotT1 { public static void main(String args[]) throws IOException {Plot.file( in.txt ) } } Çıktı aynı olacaktır. Burada statik tanımlamaları genelde tek bir adımda grafik çizdirmek için kullandığımızı, birden fazla adım olduğunda dinamik tanımlamaları tercih etmemizin daha iyi olacağını belirtelim. Bu çıktıda ara değerleri daha iyi görmek istersek programdan ara değer hesabı yapmasını istiyebiliriz. Çıktı yine üstte tanımlandığı gibidir. aradeğer hesabı yapmak için sadece pp.addSpline(xx,yy,10) deyimini eklememiz kafi geldi. Buradaki her nokta arasını 10 eşit parçaya bölerek ara değerleri kübik şerit interpolasyonuyla hesaplamamız anlamına gelmektedir. Eğer verinin kaç numaralı eğri olarak Plot programına girdiğini bilirsek, veriyi Plot sınıfının okuduğu veriden alarak da aynı aradeğer oluşumunu yapabiliriz. Plot eğri setleri numaraları ekleme sıramıza göre 0 dan başlayarak artarak gider. Kübik şerit interpolasyonunun detaylarını öğrenmek istersek eğri uydurma bölümümüzü inceleyebilirsiniz. Birden fazla grafik komutunu bir arada kullanmak isterseniz statik metodlara başvuramazsınız, örneğin yukardaki programda hem veriyi hemde verinin interpolasyon değerlerini çizdirdiğimizden statik kullanıma uygun değildir. Ancak kendi statik metodumuzda bu tür kompleks kullanımları birleştirerek kullanabiliriz. Aynı aradeğer hesaplarını pp.addB_Spline(xx,yy,10) deyimini ekleyerek B şerit interpolasyonu kullanarak da yapabiliriz. * class PlotT2D veya Lagrange aradeğer hesabıyla da ulaşabiliriz. Tüm interpolasyon hesap detaylarını kitabımızın 6. bölümünde inceleyebilirsiniz. Plot Programındaki kurucu metodumuz tamamen boş olabilir. * class PlotT01 {public static void main (String args[]) throws IOException {Plot pp=new Plot() pp.plot() }} verisi olduğunu varsayalım. Bunun anlamı Plot başlığı x ekseni ve y ekseni grafik başlıklarını kullanarak in.txt ve out.txt dosyalarındaki verilerin çizilmesidir. Verilerin yanındaki ilk rakam grafik çizim türünü ondan sonraki 3 rakam da renk kodunu (kırmızı yeşil ve mavi olarak) ifade eder. Programın grafik çizim kodları 1 __ __ __ __ , 2 . _ . _ . _ , 3 . _ _ . . _ _ . , 4 - - - - - - - - , 5 ______ , 6 __ __ __ __ , 7 . _ . _ . _ , 8 . _ _ . . _ _ . , 9 - - - - - , 10 * , 11 # , 12 $ , 13 % , 14 & , 15 , 16 ~ , 17 + , 18 x , 19 = , 20 kare , 21 dolu kare , 22 daire , 23 dolu daire , 24 üçken , 25 eşkenar dörtgen , 26 beşken , 27 altıgen , 28 dolu üçgen , 28 dolu eşkenar dörtken , 30 dolu beşgen , 31 dolu altıgen , 32 üç köşe yıldız , 33 dört köşe yıldız , 34 beş köşe yıldız , 35 altı köşe yıldız , 36 dolu üç köşe yıldız , 37 dolu dört köşe yıldız , 38 dolu beş köşe yıldız , 39 dolu altı köşe yıldız , 40 çubuk grafik , 41 dolu çubuk grafik } şeklindedir. Grafik türü ve renk kodları burada bahsettiğimiz tüm metodlar için de mevcuttur. Örneğin Bir fonksiyonun grafiğinin çizilmesi için en basit yol fonksiyonu abstract sınıf f_x ten türeterek yapılır. bu programın grafik çıktısı şeklinde olacaktır. Bu fonksiyon matematik olarak ifade edilirse f(x)=x3+3.6x2-36.4 şeklindedir. 0 ile 7 arasında 400 nokta oluşturarak fonksiyonunun çizilmesi istenmiştir. Birden fazla fonksiyonun grafiğini tek bir sınıfta tanımlıyabiliriz. veya ayrı ayrı birden fazla sınıfta tanımlayarak da çizebiliriz. Fonksiyonlar ayrı ayrı çağrıldığında değişik sınır değerleri de tanımlayabiliriz. addFunction metoduna benzer olarak addData metodu mevcuttur, java boyutlu değişken verilerinin eklenmesinde kullanılır. Bu program 2 fonksiyonu f3 sınıfından almakta, 2 set veriyi fi string'i aracılığıyla in.txt ve out.txt dosyalarından okumaktadır. 3. veri seti(2 no'lu veri) bar grafik (grafik tipi 41) olarak seçilmiştir. Bu paketleri kullanarak çok daha karmaşık grafik bileşenleri oluşturulabilir. Örneğin nemli havanın termodinamik özellikleri programında fare ile aktif veri girişi (Fareye basıldığında x ve y koordinatlarını alarak bu değerler için hesap yapma) gibi ek özellikler katılabilir. Bu özellikler burada verdiğimiz paketin içerisinde kullanıma hazır olarak mevcutsa da verdiğimiz şekliyle kullanılamaz. Grafik Paketi Temel Bileşenleri Grafik Paketinin temel bileşenleri Plot.java kurucu metotlar ve girdi çıktı metotlarını içerir PlotW.java çizimi gerçekleştiren ana metodudur. Grafik sayfalarını ve bu sayfaların kontrollerini içerir. PlotShapesSW çeşitli Plot alt elemanlarının çizim tekniklerini içerir, çizgi, üçgen,bar grafik gibi Plot2D PlotShapes alt elemanlarını grafik çizimi haline getirir, sırasıyla alt elemanları çağırır. Şimdi bu paketlerin listelerini verelim. Bu tür program kodları programlamaya yeni başlayan arkadaşlarımız için kompleks olabilir, bu durumda sadece kullanımla yetinebilirler, ancak dileyen kodları alarak daha da geliştirebilir, Bu tür geliştirmelerde tek dileğim geliştirmelerden beni de haberdar etmeniz, eğer yeni kodlar uygunsa orijinal kodları değiştirebiliriz. public void addEKK(int linenumber,int npolinom,int aradegersayisi,int iplottype,int ir,int ig,int ib) public void addLagrange(double xi[],double yi[],int aradegersayisi) public void addLagrange(double xi[],double yi[],int aradegersayisi,int iplottype) public void addLagrange(double xi[],double yi[],int aradegersayisi,int iplottype,int ir,int ig,int ib) public void addLagrange(int linenumber,int aradegersayisi,int iplottype) public void addLagrange(int linenumber,int aradegersayisi,int iplottype,int ir,int ig,int ib) public void addB_Spline(double xi[],double yi[],int nSpline) public void addB_Spline(double ai[][],int nSpline) public void addB_Spline(double xi[],double yi[],int nSpline,int iplottype) public void addB_Spline(double xi[],double yi[],int aradegersayisi,int iplottype,int ir,int ig,int ib) public void addB_Spline(int linenumber,int nSpline) public void addB_Spline(int linenumber,int nSpline,int iplottype) public void addB_Spline(int linenumber,int aradegersayisi,int iplottype,int ir,int ig,int ib) public void addSpline(double xi[],double yi[],int nSpline) public void addSpline(double ai[][],int nSpline) public void addSpline(double xi[],double yi[],int nSpline,int iplottype) public void addSpline(double xi[],double yi[],int aradegersayisi,int iplottype,int ir,int ig,int ib) public void addSpline(int linenumber,int nSpline) public void addSpline(int linenumber,int nSpline,int iplottype) public void addSpline(int linenumber,int aradegersayisi,int iplottype,int ir,int ig,int ib) grafik özelliklerini değiştirmek ===========Grafik türü ===================== public void setPlotType(int plot_type[]) public void setPlotType(int dataset,int plot_no) public void setPlotType(int dataset,char plot_char) ===========x ve y grid =========================== public void setXgrid(int igx) public void setYgrid(int igy) public void setGrid(int igx,int igy) public void setXtic(int ixt) public void setYtic(int iyt) public void setXYtic(int ixt,int iyt) ==========logaritmik grafik skalası açma ve kapama ========== public void setXlogScaleOn() public void setYlogScaleOn() public void setXlogScaleOff() public void setYlogScaleOff() ==========renk seti========== public void setColor(int dataset,int ired,int igreen,int iblue) public void setColor(int dataset,Color c) public void setColor(int ired[],int igreen[],int iblue[]) public void setColor(Color c[]) ================ fonksiyon minimum ve maksimum değerleri =================== public void setMinMax() public void setMinMax(double xi[][],double yi[][]) public void setMinMax(double iminx,double imaxx,double iminy,double imaxy) =============== grafik penceresi formatlanması ================================== public void set_plotwindow(int width,int height,double xip,double yip,double dxp,double dyp) public void setabsMaxMin(int ixmin,int iymin,int idx,int idy) oluşan verinin dinamik ortamda çizilmesi public void plot() Div. // turhan.coban@ege.edu.tr // ===================================================== import java.io. * import java.awt.Color //This class organises data and reqired plot classes for actual plot //===== classes used by this class======= // PlotShapesSW // define shapes to draw in plot windows in real coordinate system // Plot2D // Plot and coordinates data // PLotW // defines actual graphic screens and pages //===== Example classes // PlotT0,PlotT01,PlotT02,PlotT03,PlotT1,PlotT2,PlotT3,PlotT4 abstract class f_x { //single function single independent variable // example f=x*x abstract double func(double x) } abstract class fi_x { // multifunction single independent variable // vector of dependent variables are returned // example f[0]=x+sin(x) // f[1]=x*x-x // func(x) returns the value of f[0] and f[1] // as a two dimensional vector abstract double[] func(double x) } public class Plot { // This class reads plot input variables // and sets relations between absolute scale and relative scale plot windows public Color bg=Color.blue public String label= y=f(x) // Plot Label public String xlabel= x // X axis Label public String ylabel= y // Y axis Label public String filename // file name public double xmin,ymin,xmax,ymax // real max,min scale public int xabsmin,yabsmin,abswidth,absheight // absolute max,min scale in Pixel dimension public int nmax // max number of data points public int ni // data set number with nmax data public int nline // max number of data sets public double x[][] // x data public double y[][] // y=f(x) data public int n[] // n number of data in each line public int red[],green[],blue[] // color code 0-255 public int xgridon=0 // x axis grid line on public int ygridon=0 // y axis grid line on public int xlog=0 // x axis logaritmic scale public int ylog=0 // y axis logaritmic scale public int plottype[] public String plotst[]={ 0 _____________ , 1 __ __ __ __ , 2 . _ . _ . _ , 3 . _ _ . . _ _ . , 4 - - - - - , 5 kalın _____________ , 6 kalın __ __ __ __ , 7 kalın . _ . _ . _ , 8 kalın . _ _ . . _ _ . , 9 kalın - - - - - , 10 * , 11 # , 12 $ , 13 % , 14 & , 15 , 16 ~ , 17 + , 18 x , 19 = , 20 kare , 21 dolu kare , 22 daire , 23 dolu daire , 24 üçken , 25 eşkenar dörtgen , 26 beşken , 27 altıgen , 28 dolu üçgen , 28 dolu eşkenar dörtken , 30 dolu beşgen , 31 dolu altıgen , 32 üç köşe yıldız , 33 dört köşe yıldız , 34 beş köşe yıldız , 35 altı köşe yıldız , 36 dolu üç köşe yıldız , 37 dolu dört köşe yıldız , 38 dolu beş köşe yıldız , 39 dolu altı köşe yıldız , 40 çubuk grafik , 41 dolu çubuk grafik } double xminmaxlog,yminmaxlog // plottype = 0 continuous line // plottype = 1 dashed line // plottype = 2 // plottype = 3 // plottype = 10 variable character plot type // plottype = 20 rectangle // plottype = 21 filled rectangle // plottype = 22 circle // plottype = 23 filled circle // plottype = 24 triangle // plottype = 25 diamond // plottype = 26 pentagon // plottype = 27 hexagon // plottype = 28 filled triangle // plottype = 29 filled diamond // plottype = 30 filled pentagon // plottype = 31 filled hexagon // plottype = 32 tri sided star // plottype = 33 four sided star // plottype = 34 five sided star // plottype = 35 six sided star // plottype = 36 filled tri sided star // plottype = 37 filled four sided star // plottype = 38 filled five sided star // plottype = 39 filled six sided star // plottype = 40 bar plot // plottype = 41 filled bar plot public char ch[] // plot character (used with plottype 10) public int xntic=10 // number of tics in x axis public int yntic=10 // number of tics in y axis BufferedReader fini BufferedReader ffile File plotFile File lineDataFile String fn[] /* ========== constructors ======================= public Plot() throws IOException Read actual data from file Plot.txt and plot filenames listed in this file public Plot(String pl,String xl,String yl,int xnt,int ynt ,int xgo,int ygo,String fn[],int ipt[],int ir[],int ig[] ,int ib[]) throws IOException Read file names from String fn[] and plot them public Plot(String fn[],int ipt[],int ir[],int ig[],int ib[]) throws IOException public Plot(String fn[]) throws IOException Read file names from String fn[] and plot them public Plot(double xi[][],double yi[][],int ipt[],int ir[],int ig[],int ib[]) read plot data from xi[][] and yi[][] public Plot(double xiyi[][]) read plot data xi[] and yi[] from xiyi[][] string public Plot(double xi[][],double yi[][]) read plot data from xi[][] and yi[][] public Plot(double xi[],double yi[]) read plot data from xi[] and yi[] public Plot(f_x f,double xm,double xma,int N,int ipt,int ir,int ig,int ib) create plot data from a simple function f_x f public Plot(f_x f,double xm,double xma,int N) create plot data from a simple function f_x f public Plot(fi_x f,double xm,double xma,int Number_of_Data,int Number_of_Function) create plot data from an array of simple functions fi_x f ======== Label settings ======================== public void setPlabel(String ip) {label=ip } public void setXlabel(String ix) {xlabel=ix } public void setYlabel(String iy) {ylabel=iy } public void setXYlabel(String ix,String iy) {xlabel=ix ylabel=iy } ======== Setting additional data after initial construction ========= This groups's functions are similar to constructor classes public void addData(double xi[],double yi[]) public void addData(double xi[],double yi[],int iplottype) public void addData(double xi[],double yi[],int iplottype,int ir,int ig,int ib) public void addData(double xi[][],double yi[][]) public void addData(double xi[][],double yi[][],int ip[]) public void addData(double xi[][],double yi[][],int ip[],int ir[],int ig[],int ib[]) public void addFunction(f_x f,double xmi,double xma,int N,int ipt) public void addFunction(f_x f,double xmi,double xma,int N) public void addFunction(f_x f,double xmi,double xma,int N,int ipt,int ir,int ig,int ib) public void addFunction(fi_x f,double xmin,double xmax,int Number_of_Data,int Number_of_Function) public void addFunction(fi_x f,double xmin,double xmax,int