java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. Çıktı 4.17-1 Çok boyutlu lineer olmayan denklem çözümü (köklerini bulma), Broyden metodu Bulmak istediğimiz çözüm setine x* diyelim. Şimdi 0 ile 1 arasında bir  değeri alan bir problem seti düşünelim. Bu sette =0 değeri x(0) çözümüne karşı gelsin ve =1 değeri x(1)= x* çözüm setine karşı gelsin. G(x) fonksiyonunu G(x) = F(x) + (1- F(x) - F(x(0)) ] olarak tanımlayacak olur isek, ve bu denklemden G(x) = 0 çözümünü elde etmek istersek, kök değerini veren çözümler için =0 olduğunda 0=G(x) = F(x) - F(x(0)) olur. =1 olduğunda ise 0=G(x) = F(x) olur. Bu yüzden x(1)=x* çözüm setine eşit olacaktır. Öyleyse bu özellikleri sağlayan bir G(x) fonksiyonu bulabilirsek bu fonksiyonu F(x) fonksiyonunun çözümü için kullanabiliriz. G fonksiyonuna geçiş veya süreklilik fonksiyonu adı veriyoruz(=0 dan =1 e geçiş) Böyle bir fonksiyonu oluşturabilmek için G(x)=0 alınır ve bu fonksiyonun  ya göre kısmi türevi alınırsa. 0 G( , x) G( , x) '  x ( ) buradan x'() çekilirse  x 1  G( , x( )   G( , x( ))  ' x ( )       x ( ) x      ' G(x) = F(x) + (1- F(x) - F(x(0)) ] değerini bu denklemde yerine koya isek  f1 ( x( ))   x1  G ( , x( )   f 2 ( x( ))     x x  f ( x(1  ))  3  x1 f1 ( x( )) x 2 f 2 ( x( )) x 2 f 3 ( x( )) x 2 f1 ( x( ))   x3  f 2 ( x( ))   J ( x ( ) x3  f 3 ( x( ))  x3  Jakobiyen matristir. Ve  G( , x( )     F ( x(0)) x diferansiyel denklem x ' ( )  dx( ) 1  J ( x( )) F ( x(0)) d 0   1 formunu alır. Bu diferansiyel denklem x(0) başlangıç değeri için çözülürse, çözümden elde edilen x(1) değeri bize G(x) = 0 denkleminin çözümünü verecektir. Bunun için herhangi bir diferansiyel denklem çözüm yöntemini kullanabiliriz. Örneğin Buradaki h step boyutudur. Çözüm  , x0(0) ilk değerini kullanarak hesaplamaya başlar, ve her stepte  değerine h ekleyerek değerine kadar devam eder. x0(1) değeri çözüm setimizdir. Diferansiyel denklemlerin çözümü daha detaylı olarak diferansiyel denklemler konusunda görülecektir. Diferansiyel denklemin çözümü bize çözüm fonksiyonunu verdiği için aynı zamanda denklemin köklerini de bulmuş oluruz. Program 4.18-1 de süreklilik denklemini 4 dereceden ve 6ıncı dereceden Runge-Kutta formülleri yardımı ile çözen süreklilik lineer olmıyan denklem çözme programı verilmiştir. // kullanıcının sadece fa fonksiyonunu oluşturması gerekmektedir. import java.util. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. * //============= Tanımı gereken fonksiyon ================ abstract class fi_xi { // multifunction multi independent variable // vector of dependent variables are returned // example f[0]=x[0]+sin(x[1]) // f[1]=x[0]*x[0]-x[1] // func(x) returns the value of f[0] and f[1] System.exit(0) } } Çıktı 4.18-1 Süreklilik yöntemi kullanarak çok boyutlu lineer olmayan denklem çözümü (köklerini bulma) Süreklilik denklem çözüm yöntemini Newton yöntemi gibi bir yöntem için ilk değer tayini için de kullanabiliriz. Bu alt bölümde temelde bu yöntemin çeşitli optimizasyon metodlarına adapte ederek uygulanmasını inceleyeceğiz. fi(xj)=0 denklem sistemini çözmek için g(x j )  n _ denklem  f (x i 0 i j ) *fi (x j ) denkleminin minimum değeri bulunmuştur. Aslında bir çok non-lineer denklem sisteminin geometrik yöntemlerle optimizasyon probleminin çözümü ile kök bulma metodları iç içedir. Çünki optimizasyon(minimum veya maksimum bulma işlemi) fonksiyonun türevinin kökünü bulma işlemi ile aynıdır. Nelder-Mead ya da amip yöntemi detaylarıyla optimizasyon konusunda (bölüm 5.19) verilmiştir. Lütfen detayları için ilgili bölümümüze bakınız. Burada verilen program da Nelder mead programının sadece çıktı kısmını içermektedir. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. * class f1 extends f_xj {//adaptör sınıfı //optimizasyon problemleri kullanarak lineer olmıyan denklem sistemi kökü çözer fi_xi ff1 public f1(fi_xi ffi) {ff1=ffi } public double func(double x[]) { //çözümü istenen fonksiyon double ff=0.0 double fa[]=ff1.func(x) for(int i=0 i<fa.length i++) ff+=fa[i]*fa[i] return ff } } Çıktı 4.19-1 Nelder-Mead optimizasyon yöntemi kullanarak çok boyutlu lineer olmayan denklem çözümü (köklerini bulma) Bu detayları bölüm 5.24 de bulabilirsiniz. Burada sadece bu yöntemin istatistik tabanlı bir yöntem olduğunu ve çözüm setinde istatistiksel sapmalar bekleyebileceğimizi belirtmekle yetineceğiz. Önceki bölümlerimizde kullandığımız aynı örnek problemi bu bölümde de kullandık, çözüm setinin (0.499502180107804, -0.000026702982723, -0.523405164356859) çok kötü olmadığını söyleyebiliriz. Orijinal fonksiyonu – ile çarpıp 10 ilave ettiğimize dikkatinizi çekeriz. Genetik algoritmalar fonksiyonun maksimimunu bulurlar ve fonksiyonun positif değerleri için sonuç verirler. Program 4.20-1 Genetik algoritma optimizasyon yöntemi kullanarak çok boyutlu lineer olmayan denklem çözümü (köklerini bulma) import java.io. * class f1 extends f_xj {//adaptör sınıfı //optimizasyon problemleri kullanarak lineer olmıyan denklem sistemi kökü çözer fi_xi ff1 public f1(fi_xi ffi) {ff1=ffi } public double func(double x[]) { //çözümü istenen fonksiyon double ff=0.0 double fa[]=ff1.func(x) for(int i=0 i<fa.length i++) ff+=fa[i]*fa[i] return 10-ff //minimum değil maxsimum istendiğinden - ile çarptık } } Çıktı 4.20-1 Genetik algoritma optimizasyon yöntemi kullanarak çok boyutlu lineer olmayan denklem çözümü (köklerini bulma) ---------- Capture Output ---------> C \co\java\bin\javaw.exe OPO17DS best= 0.499502180107804 -0.000026702982723 -0.523405164356859 9.999982661442765 > Terminated with exit code 0. Optimizasyon metodlarından olan en dik yamaç metodunun detayları optimizasyon konusunda bölüm 5.20 de verilmiştir. Burada detaylarına girmeyeceğiz. Bir önceki bölümde de belirttiğimiz gibi bu metod da lineer olmıyan denklem sistemlerinin köklerini bulmada kullanılabilir. Program 4.21-1 en dik yamaç optimizasyon yöntemi kullanarak çok boyutlu lineer olmayan denklem çözümü (köklerini bulma) import javax.swing. * import java.util. * import java.awt. * import java.applet.Applet import java.awt.event. * import java.io. * class f1 extends f_xj {//adaptör sınıfı //optimizasyon problemleri kullanarak lineer olmıyan denklem sistemi kökü çözer fi_xi ff1 public f1(fi_xi ffi) {ff1=ffi } public double func(double x[]) { //çözümü istenen fonksiyon double ff=0.0 double fa[]=ff1.func(x) for(int i=0 i<fa.length i++) ff+=fa[i]*fa[i] return ff //minimum değil maxsimum istendiğinden - ile çarptık } } Çıktı 4.21-1 en dik yamaç optimizasyon yöntemi kullanarak çok boyutlu lineer olmayan denklem çözümü (köklerini bulma) Metod detaylarını bölüm 5.23 de bulabilirsiniz. Bu örnek problemde de Bu bölümdeki Program 5.23.1 deki OPO12F.java probleminden adapte edilmiştir. Burada okuyucu haklı olarak böyle bir bölümün optimizasyon bölümünden sonra sunulmasını talep edebilir, ancak aralarındaki zincirleme ilişki hangisinin daha temel olduğunu sınıflamada zorluk yaratmaktadır. Örneğin Newton lineer olmıyan kök bulma metodu bire bir Newton lineer olmıyan optimizasyon metodunun temelini oluşturmaktadır. Program 4.22-1 Davidon-Fletcher-Powell optimizasyon yöntemi kullanarak çok boyutlu lineer olmayan denklem çözümü (köklerini bulma) import java.util. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. * class f1 extends f_xj {//adaptör sınıfı //optimizasyon problemleri kullanarak lineer olmıyan denklem sistemi kökü çözer fi_xi ff1 public f1(fi_xi ffi) {ff1=ffi } public double func(double x[]) { //çözümü istenen fonksiyon double ff=0.0 double fa[]=ff1.func(x) for(int i=0 i<fa.length i++) ff+=fa[i]*fa[i] return ff //minimum değil maxsimum istendiğinden - ile çarptık } } Çıktı 4.22-1 Davidon-Fletcher-Powell optimizasyon yöntemi kullanarak çok boyutlu lineer olmayan denklem çözümü (köklerini bulma) Not geometrinin(küre) gereği h nin değeri 0 dan küçük, d=2r den büyük olamaz. Kabın alabileceği maksimum sıvı miktarı 4.18879 m3 dür (bu veriye problemi çözmek için ihtiyacınız yok, fikir edinebilmeniz için verilmiştir.) . Kök bulma sayısal çözümleme metodu metodu size bırakılmıştır (ikiye bölme, yer değiştirme, newton, sekant, müller...). Kullandığınız metodu ve formülü açık olarak belirtiniz. Çözüme başlarken önce formülü f(h) = 0 formuna getiriniz. 7 değerini kök bulma yöntemlerinden birini kullanarak hesaplayınız. x0=4 ve 7  x  8 değerlerini deneyiniz Newton yöntemini kullanarak hesaplayınız. x0=1 Colebrook denklemi Bu denklem 2    2.185   14.5   f  4.0 1.737 ln 0.269   ln(0.269 )    formundadır. Re sayısı ve /D (pürüzlülük katsayısı/boru çapı) ve yerel basınç düşümü katsayısı verildiğinde borudaki toplam basınç düşümünü hesaplayan bir program yazınız ve test ediniz. f  1,737 * ln (. Re * f )  0,4 Bu denklem 4 * 103 < Re < 3 * 106 aralığında geçerlidir. Reynolds sayısının 5000 değeri için fannning sürtünme katsayısını (f) hesaplayınız. Not 1 Önce kökün(f) bulunduğu aralığı hesaplayınız. Kök değeri (f) 0,001 ile 0.01 arasında değişmektedir. Not 2 S = % 0,01 olana dek işlemi sürdürünüz. Gazlar için van der Waals denklemi olarak verilebilir.Redlich ve Kwong Denklemi P Burada  v  b v(v  b)T 1 / 2 Benedict -Webb-Rubin (BWR) denklemi  C0.10-6 0.0038617 0.0058891 A -0.040507 0.01490 B -0.00027963 0.00198154 c.10-6 -0.00020376 0.000548064 .103 0.008641 0.291545 Java programı geliştirerek (Örnek programlardan yararlanabilirsiniz)T ve v verildiğinde P'yi hesaplayabilen, P ve v verildiğinde T yi hesaplayabilen, P ve T verildiğinde v'yi hesaplayabilen bir program geliştiriniz. A) van der Waals denklemi gaz oksijen ve azot B) Redlich Kwong denklemi gaz oksijen ve azot C) Benedict-webb rubin denklemi gaz oksijen D) Benedict-webb rubin denklemi gaz azot RT Bulunan değerleri ideal gaz denklemi ile karşılaştırınız P  v .103 0.359 0.75 lineer olmıyan denklem sisteminin köklerini a) Newton raphson yöntemi b) Süreklilik yöntemi c) Nelder-Mead yöntemi d) en dik yamaç yöntemi e) Genetik algoritma yöntemlerini kullanarak bulunuz, sonuçları karşılaştırınız .  (1  C * ) denklemi ile tanımlanmaktadır. A) Denklemi sağlayan C* değerinin bulunduğu aralığı belirleyiniz. Çubuğun bulunduğu ortam T∞ = 10 °C sıcaklıkta ve olup ısı taşınım katsatısı h=15 W/m2 °C'dır. Çubuk kesit alanı A=2×10-4 m2, çubuk çevresi P=0.402 m'dir. Yapılan deneyde çubuğun orta noktasının (x=0.025 m) sıcaklığı T=67.5 °C olarak bulunmuştur. Bu koşullarda çubuktaki sıcaklık dağılımı A) Sıcaklık dağılımı denklemini sağlayan m değerinin bulunduğu aralığı belirleyiniz. Bunun için ilk değeri m=5, artımları da 5 olarak alınız. B) NewtonRaphson yöntemini kullanarak m değerini hesaplayınız. C) Bulacağınız değeri kullanarak malzemenin ısı iletim katsayısını (k) hesaplayınız. Bu verilere göre gövde çapını hesaplayınız. B) Gövde çapını(D), ikiye bölme yöntemi ile hesaplayınız. Her adımda yaklaşık bağıl yüzde hatayı hesaplayınız. TL değerindeki bir cihazı hiç peşin ödemeden 6 yılda geri ödemek üzere yılda 4.000.000. TL taksitle satın alıyorsunuz. Borcunuza uygulanan faizin değerini Sekant yöntemini kullanarak hesaplayınız.. Bugünkü değer P, yıllık ödeme A, yıl sayısı n ve faiz oranı i arasındaki bağıntı aşağıda verilmiştir. İp ucu Kökün bulunduğu aralığı 0.05 artımla belirleyiniz ve yaklaşık kök bulunması işlemine alt sınırdan başlayınız. Yaklaşık kök hesaplamasını üç adım yürütünüz ve yaklaşık bağıl yüzde hatayı bulunuz. Metan gazı için gaz sabiti R=0,518 kJ/kgK dir. a) Kökün (v) bulunduğu aralığı, b) Yer değiştirme yöntemini kullanarak bir kg gazın hacmini (v), c) Depolanacak metan gazı kütlesini bulunuz. Not İşlemi üç adım yürütünüz ve her adımda yaklaşık bağıl yüzde hatayı hesaplayınız. Bir maddeyi belli bir sıcaklığa kadar ısıtmak için gerekli enerji Q =  bulunmaktadır. Bu maddeye 733,16 kcal değerinde enerji verilmektedir. A) Ulaşılacak sıcaklığın (kökün) bulunduğu aralığı hesaplayınız. İlk değeri 283 K, artımları ise 5 olarak alınız. B) Son sıcaklığı (kök değerini) ikiye bölme yöntemi ile hesaplayınız. f 1 exp (  0,508 / w )  0,341 / w denklemi ile tanımlanmaktadır. Burada w (kg/s) kütlesel debidir. Bu koşullarda a) f = f(w) denkleminde kütlesel debinin (w) bulunduğu aralığı hesaplayınız. Kök hesaplama işlemini yaklaşık bağıl yanlış %0,5 olana dek sürdürünüz. Burada CP =1,005+1,884*YG ve QV = 2501- 2,44*(TS-273) olarak tanımlanmaktadır. Kurutma havası sıcaklığı TG=70°C, nemi YG =0,01066 ise a) 0 °C ile 100 °C arasında kökün bulunduğu aralığı (artımları en fazla 10 °C olarak alınız), b) malzeme sıcaklığını Bisection yöntemi ile hesaplayınız. m =- Bu verilere göre toplayıcı ısı kayıp katsayısı UL'nin değerini False Position yöntemi ile hesaplayınız. Kök bulma işlemine başlamadan önce kökün bulunduğu aralığı belirleyiniz. 0 < UL < 10 olarak düşününüz. 5 Temel matematik olarak baktığımızda tek boyutlu f(x) fonksiyonu için df(x)/dx = 0 f(x) fonksiyonunun minimum veya maksimumunu tanımlar. Temel tanım olarak minimum veya maksimum arasında işlemsel olarak bir fark yoktur, çünki maksimum (f(x)) = minimum(-f(x)) olarak yazılabilir. Bu yüzden sadece fonksiyonu -1 ile çarparak maksimum veya minimum bulma işlemleri arasına yer değiştirmek mümkündür. Tek boyutlu minimizasyon işlemine ilk örnek olarak grafik çizme yöntemini verelim. Bir fonksiyonun grafiğini çizerek (sabit aralıklarla fonksiyon değerini hesaplayarak) minimumun yeri çizilen grafiknoktalarının arasındaki boşluk hassasiyeti ile saptanabilir. Minimum noktaya yaklaştığınızda yeni daha küçük bir aralık saptıyarak fonksiyonu tekrar bu aralık için tarayabiliriz. Grafik programımız farenin kaoordinatlarını da yansıttığından farereyi minimumun üzerine getirerek ekrandan değeri detaylı olarak okuyabiliriz. Grafik kontrol sayfasıdan x ve y eksenlerinin minumum ve maksimum değerlerini elle değiştirerek optimum noktası civarını daha detaylı çizdirerek noktayı okuma kolaylığı da elde edebiliriz. Grafik yöntemini çok daha büyük adımlarla bir tarama olarak kullanırsak optimumun olduğu bölgeyi saptamak için de kullanabiliriz. Genel yazılımı F(n)=F(n-1)+F(n-2) şeklindedir. F(0)=0, F(1)=1 şeklide tanımlanmıştır. Fibonacci serisinin büyük oranlarında R= lim n F (n  1) 5 1   0.618033989 F ( n) 2 Peki bu oranı optimizasyonda nasıl kullanacağız. Verilen bir (a,c) bölgesinin hangi tarafında bir minimum(veya maksimum) olduğunu kestirebilmek için bu bölgedeki iki ara noktayı değerlendirmemiz gerekir. Minimum arıyorsak iki ara nokta bölgeyi 3 parçaya böleceği için minimum değerin saptandığı noktanın iki tarafındaki bölgeler kalır diğer bölgeyi atarız. Ancak yeni değerlendirmede yine iki ara noktaya ihtiyaç duyulur. Kendimize daha önce hesaplanan ara noktalardan biri tekrar yeni hesapta kullanılamazmı sorusunu sorarsak yanıtımız ara noktaların seçiminde altın oran kullanımı olacaktır. Şekil 5.1-1 Altın oran minimum arama prensibi. Şekil 5.1-1 de görüldüğü gibi a ve c noktaları arasında minimum değeri veren noktayı bulmaya çalışalım bölgenin uzunluğu d0=(c – a) olacaktır. b1 noktasını b1=a+d0*R b2 noktasını b2 = c – d0*R = a + d0*R2 olarak alır isek ve minimumun b1 noktasında olduğunu kabul edersek (b2-c) aralığı iptal olacaktır. yeni aralığımız d1=d0*R olacağından b1 noktasını b1=a+d1*R=a+d0*R2 olarak alırız bu bir önceki b2 noktasının aynısıdır. b2 noktasını b2 = c – d1*R = a + d1*R2 = a + d0*R3 olarak alırız. Bir nokta aynı olduğundan yeni eleme için sadece bir fonksiyon değerlendirmesine ihtiyacımız olacaktır. ve her yeni elemede noktaların biri (sağ veya soldan elememize göre değişerek) daima aynı kalacaktır. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. Çıktı 5.1-1 Fibonacci (altın oran ) minimizasyon programı Örnek fonksiyon Çıktı 5.0-1 deki aynı fonksiyondur. Çözüme ulaşma hızını arttırmak ister isek ikinci dereceden bir arama yöntemine başvurabiliriz. 3 noktadan ikinci dereceden bir polinom geçmesi kuralını kök bulma bölümünde de kullanmıştık. Benzer bir yaklaşımla verilen 3 noktadan (a b ve c noktaları olsun) geçen parabolün minimum(veya maksimum) noktasını parabol denkleminin çözümünden elde edebiliriz. Parabolün minimum noktası d  b  0.5( denklemini kullanarak elde edilebilir. D nokasını bulduktan sonra b noktası yerine d noktasınıalarak yeni bir iterasyon için hesabımıza devam ederiz. Şekil 5.2-1 ikinci derece polinom metodu ile minimum bulunması * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. } Çıktı 5.2-1 ikinci derece polinom optimizasyonu Hermite kübik polinomu P(x)=a(x-x0)3+b(x-x0)2+c(x-x0)+d alınacak olursa, bu polinomun dönüş noktası (minimum maksimum veya ektremum noktası) [x0,x1] aralığı için x  x0  İterasyon formülümüz, minimum sağlamak için 3a x*   x0  Bu 3a katsayıları bulmak için p(x0)=d=f(x0) p'(x0)=c=f'(x0) a=(G-2H)/h h =x1 – x0 b=3H-G F=[f(x1) - f(x0)]/h G==[f'(x1) – f'(x0)]/h H=[F – f'(x0)]/h Formülleri ile hesaplanabilir. Bir önceki quadratik formülde olduğu gibi burada da her bulunan nokta yeni bir noktanın bulunması için kullanılabilir. Formüllerde fonksiyonu kendinin yanında türev değerlerinin de bulunması gerekmektedir. Bu değerler program 5.3-1 de sayısal türevler kullanılarak oluşturulmuştur. Sayısal türev kavramı için ilgili bölümümüzü inceleyebilirsiniz. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. Çıktı 5.3-2 kübik polinom optimizasyonu Kök bulma işlemleri sırasında Newton-raphson yöntemini incelemiştik. Optimizasyonun temel tanımına geri dönersek Minimum (veya maksimum) f(x) demek df(x)/dx=0 anlamına geliyordu. Öyleyse Newton-Raphson metodu ile fonksiyonun türevinin kökünü bulursak burada fonksiyonun bir maksimum veya minimum veya extremun (dönme noktası) bulunacağı anlamına gelir. Minimum f(x)=0 g ( x)  df ( x ) 0 dx Newton raphson formülü Program 5.3-1 de Newton-Raphson optimizasyon programı verilmiştir. Bu programda ikinci türevler sayısal olarak (fark denklemleri ile) bulunmaktadır. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. Çıktı 5.4-1 Newton-Raphson optimizasyon programı x  b  0.5( parabolik formülünü kullanarak minimuma ulaşabileceğimizi görmüştük. Ancak bu formülün temel bir hatası bulunmaktadır. Minimuma ulaşacağı yerde maksimuma ulaşması da mümkündür. Daha emniyetli bir yol izlemek istersek fonksiyon köke yeterince yaklaşmadan önce altın oran gibi daha emniyetli bir metodla gittikten sonra fonksiyonun minimum değere yaklaştığını gördüğümüzde ikinci derece polinom yaklaşımına geçebiliriz. Brent metodu bu işlevi sağlamak için geliştirilmiştir. Brent metodu bir iterasyonda 6 nokta kullanır. A ve b minimumun içinde bulunduğu bölgeyi gösterir. x o ana kadar bulunan minimuma en yakın noktadır. w, x den sonra gelen minimuma en yakın noktadır ve v w'dan sonra gelen minimuma en yakın noktadır. Yeni değerin kabul edilebilmesi için önce a – b bölgesinin içine düşmesi şarttır. Eğer bu şart gerçekleşiyor ise eğer bu gerçekleşmiş ise yeni hesaplanan değerin o ana kadar bulunan en iyi minimum değerinin altına düşmüş olması şartı aranır. Bu ikinci şart iterasyonun minimuma yaklaştığı güvencesini sağlar. Eğer minimum nokta bu kriteri sağlıyor ama yine de yeterince minimuma yaklaşamıyorsa araya bir altın oran arama stepi yerleştirilir. Yalız tek bir kötü adım için bu yapılmaz algoritma ikinci adımda kendini toparlayabilir, bu yüzden altın arama stepine geçilmeden önce bir-kaç adım beklenir. Aynı zamanda değerlendirilen iki nokta arasındaki mesafe daha önceden verilen toleransın altına düşmemelidir. Program 5.5-1 de brent minimizasyon algoritması verilmiştir. Şekil 5-4-1 de bu programdaki örnek fonksiyonun grafiği görülmektedir. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. Math.abs(a) -Math.abs(a)) } public static double MAX(double a,double b) {return (a > b . a b) } public static double brent(f_x f,double ax,double bx,double cx,double tol) { double aa[]=brentf(f,ax,bx,cx,tol) return aa[0] } public static double[] brentf(f_x f,double ax,double bx,double cx,double tol) { // ax,bx,cx üç adet tahmin noktası (bx ax ile cx arasında yer almalıdır) // f fonksiyon (f_x abstract sınıfında tanımlanmış) ax cx) b=((ax > cx) . a-x b-x)) } u=(Math.abs(d) >= tol1 . Çıktı 5.5-1 Brent optimizasyon programı a b intervalinin ortasında yer alan c noktasının türevi bize minimumun sol tarafa mı yoksa sağ tarafamı düştüğü hakında bilgi verir. Böylece bir sonraki arama bölgesinin a-c mi yoksa c-b mi olduğunu bilebiliriz. c noktasın türevi ve ikinci derece interpolasyonla bulunan en iyi noktanın türev değerleri kiriş(sekant) metodu kullanılarak interpole edilir. Eğer yeterli dönüşüm olmuyorsa tekrar altın arama metodunun uygulanmasına gidilir. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. Math.abs(a) -Math.abs(a)) } public static double MAX(double a,double b) {return (a > b . ax cx) b=(ax > cx . Çıktı 5.6-1 Türevli Brent optimizasyon programı Böylece daha yakın bir tahmin değerinden interpolasyon işlemine geçerken minimum olan bir alan seçilmiş olduğuna emin olabiliriz. Mnbrak metodu 3 noktayla verilen arama bölgesini içinde bir minimum değer bulunana kadar genişletir. Bu işle için altın oran arama tekniğini kullanır. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. Math.abs(a) -Math.abs(a)) } public static double MAX(double a,double b) {return (a > b . a b) } public static double[] mnbrak(f_x f,double ax,double dx) { // dx ikinci derece polinom için gerekli iki ek noktayı oluşturmak için // ana noktadan seçilen uzaklık return mnbrak(f,ax,(ax-dx),(ax+dx)) } public static double[] mnbrak(f_x f,double ax) { // dx ikinci derece polinom için gerekli iki ek noktayı oluşturmak için // ana noktadan seçiln uzaklık return mnbrak(f,ax,(ax-0.1),(ax+0.1)) } Çıktı 5.7-1 mnbrak optimizasyon braket tayin programı fonksiyon seti verildiğinde, birinci, ikinci türevler ve x değerleri iterasyon farkları 2 f x1 x2 2 f x22 2 f x1 x2 ... 2 f x2 xn 2 f x1 x3 2 f x21x3 2 f x32 ... 2 f x3 xn ... ... ... ... ... şeklinde verilebilir. (m+1) inci iterasyon için Newton-Raphson denklemi H { m m1 } {f m } şeklinde yazılabilir. Görüldüğü gibi lineer bir denklem sistemi oluşmuştur ve her iterasyonda bu denklem sisteminin çözülmesi gerekir. Sistem çözüldüğünde tüm x değerlerinin yeni iteratif değerleri bulunur . ikinci türev H hessian matrisi ismini alır. Birinci ve ikinci türevler sayısal metodlarla da hesaplanabilir, ancak bu durumda hata olasılıkları doğal olarak artar. Bu denklem   1   Burada H m 1 Hesian matrisinin ters (inverse) matrisidir. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. * //============= Tanımı gereken fonksiyon ================ abstract class fij_xi extends Mathd { // multifunction multi independent variable // vector of dependent variables are returned // example f[0][0]=x[0]+sin(x[1]) f[0][1]=x[0]*x[1] // f[1][0]=x[0]*x[0]-x[1] f[1][1]=x[0]+x[1]*x[0] // func(x) returns the value of f[0][0] and f[0][1] // f[0][1] and f[1][1] // as a two dimensional vector // abstract double[][] func(double x[]) } abstract class fi_xi extends Mathd { // multifunction multi independent variable // vector of dependent variables are returned // example f[0]=x[0]+sin(x[1]) // f[1]=x[0]*x[0]-x[1] // func(x) returns the value of f[0][0] // f[0][1] // as a two dimensional vector // abstract double[] func(double x[]) } abstract class f_xj extends Mathd { // single function multi independent variable // a single value is returned indiced to equation_ref // example f=x[0]+sin(x[1]) // // func(x,1) returns the value of f[1] // func(x,0) returns the value of f[0] abstract double func(double x[]) public static double[] newtond( fi_xi f,fij_xi f1,double x[]) { // lineer olmıyan denklem siteminin kökleri // fj(xi)=0 lineer olmıyan denklem sistemi için çözüm matrisi // türev matrisi dfj/dxi turev alt programıyla hesaplanır. // Newton-Raphson metodu ile lineer olmıyan denklem sistemi çözümü //ti önem katsayısı //x bağımsız değişken vektörü //y bağımlı değişken vektörü //dy bağımlı değişkenin türev fonksiyonları vektörü double ti=1.0 int i,ii,jj int nmax=500 double tolerance=1.0e-15 int n=x.length double b[] b=new double[n] double dy[][] dy=new double[n][n] i=0 for(i=0 i<n i++) { b[i]=1.0 } while( i++ < nmax && Matrix.abs(b) > tolerance ) { for(ii=0 ii<n ii++) { for(jj=0 jj<n jj++) { dy[ii][jj]=dfx(f,x,ii,jj) } Çıktı 5.8-1Çok bilinmiyenli lineer olmayan geometrik Newton-Raphson optimizasyon programı Program 5.8-2 Çok bilinmiyenli lineer olmayan geometrik Newton-Raphson optimizasyon programı , Hessian matrix H sayısal türev kullanılarak hesaplanmış. // ve optimizasyon import java.util. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. public static double[] newtond( fi_xi f,double x[]) { // lineer olmıyan denklem siteminin kökleri // fj(xi)=0 lineer olmıyan denklem sistemi için çözüm matrisi // türev matrisi dfj/dxi turev alt programıyla hesaplanır. public static double[][] H(fi_xi f,double x[]) { int n=x.length double dy[][]=new double[n][n] for(int ii=0 ii<n ii++) { for(int jj=0 jj<n jj++) { //Hessian matrisi dy[ii][jj]=dfx(f,x,ii,jj) } } System.out.println(Matrix.toString(dy)) return dy } public static double[] dy(fi_xi f,double x[]) { //birinci türev int n=x.length double deltay[]=f.func(x) System.out.println(Matrix.toStringT(deltay)) return deltay } public static double[] multiply(double[] left,double right) { //multiplying a vector with a constant int i int n=left.length double b[] b=new double[n] for(i=0 i<n i++) { b[i]=right*left[i] } return b } Çıktı 5.8-2 Çok bilinmiyenli lineer olmayan geometrik Newton-Raphson optimizasyon programı (ikinci türev-Hessian matrisi sayısal olarak hesaplanmış) * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. public static double[] newtond( fi_xi f,double x[]) { // lineer olmıyan denklem siteminin kökleri // fj(xi)=0 lineer olmıyan denklem sistemi için çözüm matrisi // türev matrisi dfj/dxi turev alt programıyla hesaplanır. // Newton-Raphson metodu ile lineer olmıyan denklem sistemi çözümü //ti önem katsayısı //x bağımsız değişken vektörü //y bağımlı değişken vektörü //dy bağımlı değişkenin türev fonksiyonları vektörü double ti=1.0 int i,ii,jj int nmax=500 double dy[][]=new double[n][n] for(int ii=0 ii<n ii++) { for(int jj=0 jj<n jj++) { //Hessian matrisi dy[ii][jj]=dfx(f,x,ii,jj) } } System.out.println(Matrix.toString(dy)) return dy } public static double[] dy(fi_xi f,double x[]) { //birinci türev int n=x.length double deltay[]=f.func(x) System.out.println(Matrix.toStringT(deltay)) return deltay } public static double[] multiply(double[] left,double right) { //multiplying a vector with a constant int i int n=left.length double b[] b=new double[n] for(i=0 i<n i++) { b[i]=right*left[i] } return b } Çıktı 5.8-3 Çok bilinmiyenli lineer olmayan geometrik Newton-Raphson optimizasyon programı (birinci ve ikinci türev-Hessian matrisi sayısal olarak hesaplanmış)     x01   1   1     x1  1.25 Simpleks n boyutlu bir geometrik şekildir. N boyutta (N+1) nokta içerir. İki boyuttaki simpleks bir üçgenden oluşur. Üç boyutta bir üçgenler prizması halini alır (4 yüzeyli). Bir boyutlu minimizasyon prosesinde minimumun sınırlarını saptamak olasıdır. Ancak çok boyuta geçtiğimizde bu olasılık ortadan kalkar. N boyutta en iyi yapabileceğimiz arama prosesine başlamak için N+1 nokta vermektir. Bundan sonra program yüzey topolojisini inceleyerek minimuma doğru hareket etmeye başlar. Bu hareketlerin esası şu şekilde oluşur program verilen tüm noktalarda fonksiyonu analiz ederek en yüksek ve en düşük değerleri bulur, diğer noktaları aynı bırakarak en yüksek değeri en yüksek ve en düşük elemanların üzerinde olduğu yüzeye göre yansıma noktasına taşır. Minimizasyon doğrultusunda yeterli değişim yok ise yansıtma 1 faktöründen daha büyük yada daha küçük bir faktör kullanılarak ta gerçekleştirilebilir. Minimum değere yaklaştığımızda simpleks daralma ile küçülür, bu daralma proseside bir seferde birden fazla nokta için uygulanabilir. Şekil 5.9-1 de bu prosesleri geometrik olarak 3 boyutlu uzay simpleksi için (4 nokta) görüyoruz. Şekil 5.9-1 Nelder-Mead simpleks amip hareketleri N+1 nokta vererek nelder mead iteratif araştırmasına başlamak yerine bir nokta vererek ve bu noktayı xi-1 = Pi +dxj denklemi ile N+1 noktaya genişleterek N+1 noktamızı elde edebiliriz. bu denklemde eğer i=j =1 eğer i  j =0 değeri alır. Böylece simplekse girdi olarak N+1 vektör c   c  c  dc   c          yerine 2 vektör vererek nelder mead iterasyonuna başlayabiliriz. İterasyon stepleri şu şekilde gerçekleşir 1. verilen N+1 Nokta için maksimum (en büyük), maksimumdan sonraki en büyük ve minimum fonksiyon değerlerini veren noktalar bulunur. 2. (yansıtma) maksimum değeri veren nokta tüm diğer noktaların ortalama değeri üzerinden yansıtılarak 1 yeni bir nokta elde edilir. (genişlemeli yansıtma) eğer elde edilen yeni noktanın değeri minimum noktsındaki değerden küçük ise yansıtma doğru yönde bir ilerleme sağlamış demektir, daha büyük ikinci bir yansıtma (genişleme) uygulanabilir eğer f(xyeni1) < f(xminimum) xyeni2 = xyeni1 – (1-)xortalama burada  birden küçük bir sayıdır. a. eğer f(xyeni2) < f(xminimum) xmaksimum = xyeni2 xmaksimum yerine xyeni2 değeri alınır. b. Değilse ) xmaksimum = xyeni1 xmaksimum yerine xyeni1 değeri alınır. 4. Şart 3 daha iyi bir değer vermemiş ise yansıtma prosesi bize iyi bir değer vermeyecek demektir, ancak f(xyeni1) değeri f(xmaksimum) ve f(xmaksimumdan bir küçük) değerleri arasında ise yine a. xmaksimum = xyeni1 alınabilir. b. Aynı zamanda yeni bir nokta araması 1 den küçük bir genleşme sayısı (büzülme) kullanılarak gerçekleştirilebilir. xyeni2 =xmaksimum – (1-)xortalama. Eğer bu proses başarılı ise f(xyeni2) < f(xmaksimum) xmaksimum = xyeni2 xmaksimum yerine xyeni2 değeri alınır. 5. Eğer yukarıdaki şartların hiçbiri başarı sağlamamış ise tüm simpleks elemanları minimumun 1 olduğu noktaya doğru büzülür. Program 5.9-1 Nelder ve Mead simpleks optimizasyon arama programı // Newton metodu ile optimizasyon // import java.util. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. * Çıktı 5.9-1 Nelder ve Mead simleks optimizasyon arama programı Çıktı 5.9-2 Nelder ve Mead simpleks optimizasyon arama örnek çıktısı iter=1p= -2.400000000000000 -2.000000000000000 -2.000000000000000 2.000000000000000 2.400000000000000 2.000000000000000 44.879999999999995 42.320000000000000 36.000000000000000 1.862499999999998 1.149999999999998 0.899999999999998 2.171875000000001 2.062500000000001 1.575000000000000 -0.374042968750002 -0.224687499999993 -0.753749999999998 büyük y i=-0.22468749999999327 1 ikinci büyük y i=-0.3740429687500022 0 küçük y i=-0.7537499999999975 2 iter=13p= 1.862499999999998 2.171875000000001 -0.374042968750002 1.612499999999998 1.684375000000000 -0.686386718750004 0.899999999999998 1.575000000000000 -0.753749999999998 büyük y i=-0.3740429687500022 0 ikinci büyük y i=-0.6863867187500037 1 küçük y i=-0.7537499999999975 2 iter=14p= 0.649999999999998 1.087499999999999 -0.932187499999998 1.612499999999998 1.684375000000000 -0.686386718750004 0.899999999999998 1.575000000000000 -0.753749999999998 büyük y i=-0.6863867187500037 1 ikinci büyük y i=-0.7537499999999975 2 küçük y i=-0.9321874999999984 0 iter=15p= 0.649999999999998 1.087499999999999 -0.932187499999998 1.193749999999998 1.507812500000000 -1.079252929687500 0.899999999999998 1.575000000000000 -0.753749999999998 büyük y i=-0.7537499999999975 2 ikinci büyük y i=-0.9321874999999984 0 küçük y i=-1.0792529296874995 1 iter=16p= 0.649999999999998 1.087499999999999 -0.932187499999998 1.193749999999998 1.507812500000000 -1.079252929687500 0.943749999999998 1.020312499999998 -1.061674804687500 büyük y i=-0.9321874999999984 0 ikinci büyük y i=-1.0616748046875 2 küçük y i=-1.0792529296874995 1 iter=17p= 0.859374999999998 1.175781249999999 -1.096405029296875 1.193749999999998 1.507812500000000 -1.079252929687500 0.943749999999998 1.020312499999998 -1.061674804687500 …………………………………………………………………………………………………………….. iter=49p= 1.000000969021338 1.250005597923464 -1.124999999956208 0.999993292813279 1.249984113824493 -1.124999999786506 1.000019269216091 1.250017992060081 -1.124999999625434 büyük y i=-1.1249999996254345 2 ikinci büyük y i=-1.124999999786506 1 küçük y i=-1.1249999999562075 0 Amip hareketlerini grafik olarak görmek istersek Program 5.9-2 Problem 5.9-1 deki Nelder ve Mead simpleks optimizasyon sonuçlarını görmek amacıyla olan grafik programı import java.io. Çıktı 5.9-3 Nelder ve Mead simpleks optimizasyon arama örneği simpleks hareketi grafik programı çıktısı Grafikte çözüm noktası 0 ile gösterilmiştir. 500 iterasyon sonunda sonuç İkinci bir örnek olarak fabrika yeri problemini inceleyelim Yeni bir ürün için fabrika yeri seçilmek isteniyor.Her şehrin koordinatları ve şehirdeki müşteri sayıları (şehir nüfusları olabilir) verildiğinde minimum mal taşıma maliyetini minimum toplam yol) veren fabrika yerini seçmeyi göz önüne alalım. Bir örnek test fonksiyonu olarak n i 1 Nüfus 10 10 10 10 Şimdi problemi oluşturalım ve çözümü inceleyelim. Program 5.9-3 Fabrika yeri seçimi optimizasyonu problemi, Nelder ve Mead simpleks optimizasyonu // Nelder-Mead metodu ile optimizasyon // import java.util. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. * 32.176000000000000 32.176000000000000 32.800000000000004 büyük y i=32.800000000000004 2 ikinci büyük y i=32.176 0 küçük y i=32.176 0 iter=2p= 0.120000000000000 0.100000000000000 0.130000000000000 0.100000000000000 0.120000000000000 0.130000000000000 32.176000000000000 32.176000000000000 30.951999999999990 büyük y i=32.176 0 ikinci büyük y i=32.176 1 küçük y i=30.95199999999999 2 iter=3p= 0.110000000000000 0.150000000000000 30.983999999999995 0.100000000000000 0.120000000000000 32.176000000000000 0.130000000000000 0.130000000000000 30.951999999999990 büyük y i=32.176 1 ikinci büyük y i=30.983999999999995 0 küçük y i=30.95199999999999 2 iter=4p= 0.110000000000000 0.150000000000000 30.983999999999995 0.160000000000000 0.180000000000000 28.719999999999995 0.130000000000000 0.130000000000000 30.951999999999990 büyük y i=30.983999999999995 0 ikinci büyük y i=30.95199999999999 2 küçük y i=28.719999999999995 1 iter=5p= 0.215000000000000 0.165000000000000 27.737999999999985 0.160000000000000 0.180000000000000 28.719999999999995 0.130000000000000 0.130000000000000 30.951999999999990 büyük y i=30.95199999999999 2 ikinci büyük y i=28.719999999999995 1 küçük y i=27.737999999999985 0 iter=6p= 0.215000000000000 0.165000000000000 27.737999999999985 0.160000000000000 0.180000000000000 28.719999999999995 0.302500000000000 0.257500000000001 23.912499999999984 büyük y i=28.719999999999995 1 ikinci büyük y i=27.737999999999985 0 küçük y i=23.912499999999984 2 iter=7p= 0.215000000000000 0.165000000000000 27.737999999999985 0.456250000000000 0.273750000000001 22.124124999999978 0.302500000000000 0.257500000000001 23.912499999999984 büyük y i=27.737999999999985 0 ikinci büyük y i=23.912499999999984 2 küçük y i=22.124124999999978 1 iter=8p= 0.543750000000001 0.366250000000001 20.792124999999988 0.456250000000000 0.273750000000001 22.124124999999978 0.302500000000000 0.257500000000001 23.912499999999984 büyük y i=23.912499999999984 2 ikinci büyük y i=22.124124999999978 1 küçük y i=20.792124999999988 0 iter=9p= 0.543750000000001 0.366250000000001 20.792124999999988 0.456250000000000 0.273750000000001 22.124124999999978 0.697500000000001 0.382500000000002 22.112499999999997 büyük y i=22.124124999999978 1 ikinci büyük y i=22.112499999999997 2 küçük y i=20.792124999999988 0 iter=10p= 0.543750000000001 0.366250000000001 20.792124999999988 0.538437500000001 0.324062500000001 21.297257812499986 0.697500000000001 0.382500000000002 22.112499999999997 büyük y i=22.112499999999997 2 ikinci büyük y i=21.297257812499986 1 küçük y i=20.792124999999988 0 iter=11p= 0.543750000000001 0.366250000000001 20.792124999999988 0.538437500000001 0.324062500000001 21.297257812499986 0.462890625000000 0.326484375000001 21.259391113281236 büyük y i=21.297257812499986 1 ikinci büyük y i=21.259391113281236 2 küçük y i=20.792124999999988 0 iter=12p= 0.543750000000001 0.366250000000001 20.792124999999988 0.433085937500000 0.390976562500001 20.654544067382805 0.462890625000000 0.326484375000001 21.259391113281236 büyük y i=21.259391113281236 2 ikinci büyük y i=20.792124999999988 0 küçük y i=20.654544067382805 1 iter=13p= 0.543750000000001 0.366250000000001 20.792124999999988 0.433085937500000 0.390976562500001 20.654544067382805 0.539472656250001 0.482871093750001 20.074059600830080 büyük y i=20.792124999999988 0 ikinci büyük y i=20.654544067382805 1 küçük y i=20.07405960083008 2 iter=14p= 0.428808593750000 0.507597656250001 20.205037628173827 0.433085937500000 0.390976562500001 20.654544067382805 0.539472656250001 0.482871093750001 20.074059600830080 büyük y i=20.654544067382805 1 ikinci büyük y i=20.205037628173827 0 küçük y i=20.07405960083008 2 iter=15p= 0.428808593750000 0.507597656250001 20.205037628173827 0.509667968750000 0.547363281250001 20.093470001220710 0.539472656250001 0.482871093750001 20.074059600830080 büyük y i=20.205037628173827 0 ikinci büyük y i=20.09347000122071 1 küçük y i=20.07405960083008 2 iter=16p= 0.476689453125000 0.511357421875001 20.026894905090334 0.509667968750000 0.547363281250001 20.093470001220710 0.539472656250001 0.482871093750001 20.074059600830080 büyük y i=20.09347000122071 1 ikinci büyük y i=20.07405960083008 2 küçük y i=20.026894905090334 0 iter=17p= 0.476689453125000 0.511357421875001 20.026894905090334 0.508874511718750 0.522238769531251 20.022932793140413 0.539472656250001 0.482871093750001 20.074059600830080 büyük y i=20.07405960083008 2 ikinci büyük y i=20.026894905090334 0 küçük y i=20.022932793140413 1 iter=18p= 0.476689453125000 0.511357421875001 20.026894905090334 0.508874511718750 0.522238769531251 20.022932793140413 0.516127319335938 0.499834594726564 20.010404711514713 büyük y i=20.07405960083008 2 ikinci büyük y i=20.026894905090334 0 küçük y i=20.022932793140413 1 iter=52p= 0.500002657994614 0.499999541116936 20.000000000291020 0.499999313009312 0.500000148257349 20.000000000019753 0.499999853685161 0.499998268210034 20.000000000120820 büyük y i=20.00000000029102 0 ikinci büyük y i=20.00000000012082 2 küçük y i=20.000000000019753 1 > Terminated with exit code 0. Denklemimizin türev fonksiyonu  f ( x1 , x2 , x3 ,..., xn )    x1    f ( x1 , x2 , x3 ,..., xn )    x2   f ( x1 , x2 , x3 ,..., xn )   f ( x1 , x2 , x3 ,..., xn )     x3   ...    f ( x1 , x2 , x3 ,..., xn )    xn olarak verilmişti. Bu metoda bir başlangıç noktası seçerek başlarız. Örneğin başlangıç noktası P 0  f ( x10 , x20 , x30 ,..., xn0 ) olsun. Önce her yeni step için türev denklemi hesaplanır. Sonra bu değer kullanılarak  katsayısı cinsinden yeni değere geçilir. kullanılarak bulunur. 1 En dik yamaç formülü d m {f m } f(x0,x1)=3x02-4x0x1+2x12-x0-x1 fonksiyonunun {x}=[-2,2] noktasından başlayarak minimum değerlerini bulunuz.  x11 = 2 +15 Bu değerleri f(x0,x1)=3x02-4x0x1+2x12-x0-x1 fonksiyonunda yerine koyarsak y)2-4(-2 -21)(2 +15)+2(2 +15)2-(-2 -21)-(2 +15) y = 36 +666+3033Birinci derece denklemini buluruz. Bizim optimal noktamız birinci dereceye dönüşmüş olan y fonksiyonunun minimum noktasıdır. Bu yüzden 'nın y yi minimum yapan değerini bulacağız. Programda bunun için brent metodu kullanılmıştır. Burada ise analitik olarak direk çözüm yapalım  x01   0.3056379   x02  0.9544105   =-0.109792284 için  1      =-1.121212 için  2      x1  0.35311572  x1  1.2613973   x3  0.9894   x04   0.9993   =-0.109792284 için  03     =-1.121212 için   4    1.2363 x    1  x1  1.250173  bundan sonra aynı iterasyona görüldüğü gibi devam ederiz. Programda bu işlemi yapan algorimalar mevcuttur, aynı problem çözülmektedir. Program 5.10-1 en dik yamaç algoritması programı import javax.swing. * import java.util. * import java.awt. * import java.applet.Applet import java.awt.event. * import java.io. Math.abs(a) -Math.abs(a)) } public static double MAX(double a,double b) {return (a > b . ax cx) b=((ax > cx) . a-x b-x)) } u=(Math.abs(d) >= tol1 . public static double[] turev(f_xj f_deriv,double x[]) { // df/dxj j=0...x.length // This method calculates turev of a function with more than one independent variable. Çıktı 5.10-1 En dik yamaç metodu çıktısı Burada sadece fonksiyon tanımını yeniden verelim, program aynı olacaktır. Çıktı 5.10-2 En dik yamaç metodu çıktısı Değiştirilmiş Newton metodu Newton metoduyla tepe tırmanma metodunu birleştirir. Program 5.11-1 Değiştirilmiş Newton metodu- türevler sayısal hesaplanıyor import java.util. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. public class OPO12 { public static double turev(f_xj f,double x[],int denklem_ref,int x_ref) { // // verilen fonksiyonun ikinci türevlerinin matrisi // fonksiyon f in denklem_ref sayılı fonksiyonunun(sayılar 0 dan başlar) // x[x_ref] değişkenine göre türevi (sayılar 0 dan başlar) // df_denklem_ref(x)/d_x_ref // bu metod newtond metodu içinde kullanılmak içindir. // // Accuracy of method can be adjusted by changing variables h0 and n // function input should be in the form given in abstract class // f_xj,j=0...x.length = df/dx(x_ref) double a[]=new double[x.length] for(int x_ref=0 x_ref<x.length x_ref++) { a[x_ref]=turev(f_deriv,x,x_ref) } return a } Math.abs(a) -Math.abs(a)) } public static double MAX(double a,double b) {return (a > b . a b) } ax cx) b=((ax > cx) . a-x b-x)) } u=(Math.abs(d) >= tol1 . // linmin ve brent metodunukullanır double ti=1.0 int i,ii,jj int nmax=500 Çıktı 5.11-1 Değiştirilmiş Newton metodu Program 5.11-1 de türevler sayısal olarak hesaplanmıştı. Aynı problemin türevlerin fonksiyon olarak verildiği versiyonu problem 5.11-2 de verilmiştir. Program 5.11-2 Değiştirilmiş Newton metodu- türevler sayısal fonksion olarak verilmiş // Newton metodu ile optimizasyon // import java.util. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. Math.abs(a) -Math.abs(a)) } public static double MAX(double a,double b) {return (a > b . a b) } public static double[] df(f_xj f,double xxi[]) { //Gredyen vektörü // f(x0,x1,x2,...xn) founksiyonunun türev vektörü // [df/dx0, df/dx1,df/dx2,....,df/dxn] // df/dxj j=0...x.length // // bu fonksiyon bilgisayar tarafından hesaplanmaktadır // kullanıcı tarafından tanımlanan f(x) fonksiyonunun // sayısal olarak alınan türevidir. // double a[]=new double[xxi.length] for(int i=0 i<xxi.length i++) { a[i]=dfdx(f,xxi,i) } return a } public static double[] dampednewton(f_xj f,fi_xi df,fij_xi d2f,double x[]) { // Damped Newton metodu // Newton-Raphson metodu ile en dik yamaç metodunu birlikte kullanır. ax cx) b=((ax > cx) . ax cx) x=w=v=bx fw=fv=fx=f.func(x) a-x b-x)) } u=(Math.abs(d) >= tol1 . Bu yöntemlerden birisi daha önceki arama yönlerinin bir kombinasyonunu yeni arama yönünü bulmak için kullanmaktır. İterasyona önce en dik yamaç metodu ile başlarız. Bundan sonra 1 k  n için k  1 En dik yamaç formülü d m {f m } f(x0,x1)=3x02-4x0x1+2x12-x0-x1 fonksiyonunun {x}=[-2,2] noktasından başlayarak minimum değerlerini bulunuz.  f(x0,x1)=3x02-4x0x1+2x12-x0-x1 fonksiyonunda yerine koyarsak y)2-4(-2 -21)(2 +15)+2(2 +15)2-(-2 -21)-(2 +15) y = 36 +666+3033Birinci derece denklemini buluruz. Bizim optimal noktamız birinci dereceye dönüşmüş olan y fonksiyonunun minimum noktasıdır. Bu yüzden 'nın y yi minimum yapan değerini bulacağız. Programda bunun için brent metodu kullanılmıştır. Burada ise analitik olarak direk çözüm yapalım  x1  0.305637982195846  =-0.109792284 için  01     olur. Bu ilk stepimiz en dik yamaç stepi idi  x1  0.353115727002967  şimdi Fletcher-Reeves dik gradyan yöntemini hesaplayabiliriz. =1.138513513513513  x02  1.000000000000001  2    olarak elde ederiz.  x1  1.249999999999998 Problem 5.12.1 Fletcher – Reeves dik gradyan metodu ile optimizasyon, fonksiyon ve türevi verilmiş formül import java.util. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. public static double[] df(f_xj f,double xxi[]) { //Gredyen vektörü // f(x0,x1,x2,...xn) founksiyonunun türev vektörü // [df/dx0, df/dx1,df/dx2,....,df/dxn] // df/dxj j=0...x.length // // bu fonksiyon bilgisayar tarafından hesaplanmaktadır // kullanıcı tarafından tanımlanan f(x) fonksiyonunun // sayısal olarak alınan türevidir. // double a[]=new double[xxi.length] for(int i=0 i<xxi.length i++) { a[i]=dfdx(f,xxi,i) } return a } Math.abs(a) -Math.abs(a)) } public static double MAX(double a,double b) {return (a > b . a b) } public static double linmin(f_xj f,double p[],double xi[]) { double tol=2.0e-4 ax cx) b=((ax > cx) . a-x b-x)) else { d=p/q u=x+d if (u-a < tol2 || b-u < tol2) d=SIGN(tol1,xm-x) } } else { a-x b-x)) } u=(Math.abs(d) >= tol1 . Çıktı 5.12.1 Fletcher – Reeves dik gradyan metodu ile optimizasyon, fonksiyon ve türevi verilmiş formül Problem 5.12.2 Fletcher – Reeves dik gradyan metodu ile optimizasyon, fonksiyon verilmiş ve türevi sayısal olarak hesaplanıyor import java.util. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. // double a[]=new double[xxi.length] for(int i=0 i<xxi.length i++) { a[i]=dfdx(f,xxi,i) } return a } Math.abs(a) -Math.abs(a)) } public static double MAX(double a,double b) {return (a > b . a b) } ax cx) b=((ax > cx) . a-x b-x)) } u=(Math.abs(d) >= tol1 . } } Bu tanımı biraz değiştirirsek, (g ) (g ) k  Problem 5.12.2 polak-Ribiere dik gradyan metodu ile optimizasyon import java.util. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. // double a[]=new double[xxi.length] for(int i=0 i<xxi.length i++) { a[i]=dfdx(f,xxi,i) } return a } Math.abs(a) -Math.abs(a)) } public static double MAX(double a,double b) {return (a > b . a b) } public static double linmin(f_xj f,double p[],double xi[]) { double tol=2.0e-4 int n=p.length double pcom[],xicom[] int j double xx,xmin,bx,ax f1dim f1=new f1dim(f,p,xi) ax=0.0 xx=1.0 bx=2.0 double aa[]=mnbrak(f1,ax,xx,bx) ax=aa[0] xx=aa[1] bx=aa[2] xmin=brent(f1,ax,xx,bx,tol) return xmin } public static double[][] linminiter(f_xj f,double p[],double xi[]) { // yeni iterasyon noktasını verir int n=p.length double xmin=linmin(f,p,xi) double aa[][]=new double[2][n] for (int j=0 j<n j++) { xi[j] *= xmin p[j] += xi[j] aa[0][j]=p[j] aa[1][j]=xi[j] } return aa } public static double[] brentf(f_x f,double ax,double bx,double cx,double tol) ax cx) b=((ax > cx) . a-x b-x)) } u=(Math.abs(d) >= tol1 . } //SHFT(ax,bx,cx,u) {ax=bx bx=cx cx=u } //SHFT(fa,fb,fc,fu) {fa=fb fb=fc fc=fu } aa[0]=ax aa[1]=bx aa[2]=cx } return aa } public static double brent(f_x f,double ax,double bx,double cx,double tol) { double aa[]=brentf(f,ax,bx,cx,tol) return aa[0] } // 4. { k 1}   H k  {f k } 1 {x k 1}  {x k 1}  H k  {f k } 1 şeklinde çözüme ulaşabiliyorduk. Bu denkleme adım miktarını ayarlayabileceğimiz (en dik yamaç metodunda olduğu gibi) k faktörünü eklersek, genel denklem 1 {x k 1}  {x k 1}   k H k  {f k } formunu alır. Bu metodumuzda ikinci türev, hessian yerine türevi hesaplamadan onun yerine geçebilecek bir fonksiyon oluşturmaya çalışacağız. Qk  H k  1 ,k  0 olarak tanımlayalım. Davidon – Fletcher – Powell metodu Q yu hesaplamak için Qk 1  Qk  r k (r k )T x k (x k )T  , 0k n (r k )T g k (x k )T g k formülünü kullanır. Program 5.13-1 de Davidon-Fletcher-Powell metodu algoritması verilmiştir. Programımımızda Q hesaplanmasında ikinci bir versiyon daha kullanılmıştır ikinci denklemde yeni Q değeri bir önceki değer kullanılarak modifiye edilmektedir. k  r k (r k ) T x k (x k )T ]  , 0k n (r k )T g k (x k )T g k (x k )T x k , 0k n (r k )T g k Q0=I  k katsayısı birinci dereceden tek boyutlu optimizasyon metodlarından birisi kullanılarak bulunur. Bizim programımızda brent yöntemi kullanılmıştır. Bu birinci step temel olarak tepe tırmanma metodudur. Daha sonra Q değerleri verilen denklemle hesaplanarak Davidon-Fletcher-Powell iterasyon stepleri hesaplanır. Her n stepte Q=I değerine geri dönülerek bir step tepe tırmanma metodu kullanılır ve tekrar DavidonFletcher-Powell iterasyon steplerine dönülür. 1 En dik yamaç formülü d m {f m } f(x0,x1)=3x02-4x0x1+2x12-x0-x1 fonksiyonunun {x}=[-2,2] noktasından başlayarak minimum değerlerini bulunuz.  6 x  4 x1  1  21 f   0    4 x1  4 x0  1  15   x00  2   0     x1   2  f(x0,x1)=3x02-4x0x1+2x12-x0-x1 fonksiyonunda yerine koyarsak y)2-4(-2 -21)(2 +15)+2(2 +15)2-(-2 -21)-(2 +15) y = 36 +666+3033Birinci derece denklemini buluruz. Bizim optimal noktamız birinci dereceye dönüşmüş olan y fonksiyonunun minimum noktasıdır. Bu yüzden 'nın y yi minimum yapan değerini bulacağız. Programda bunun için brent metodu kullanılmıştır. Burada ise analitik olarak direk çözüm yapalım  x1  0.305637982195846  =-0.109792284 için  01     olur. Bu ilk stepimiz en dik yamaç stepi idi 0.353115727002967 x    1 şimdi Davidon-Fletcher-Powell dik gradyan yöntemini hesaplayabiliriz. Qk 1  Qk  r k (r k )T x k (x k )T  (r k )T g k (x k )T g k 0.447456314953212 0.432131073481232   0.432131073481232 0.662335969913257 f(x0,x1)=3x02-4x0x1+2x12-x0-x1 fonksiyonunda yerine koyarsak ve çözersek  =1.1402077151335304 bulunur. Buradan da  x02  1.000000000000000  2     x1  1.250000000000000  olarak ikinci iterasyon sonuçlarını elde ederiz. Program 5.13-1 Davidon-Fletcher-Powell metodu (türev sayısal olarak hesaplanıyor) // OPO12F Davidon-Fletcher-Powell optimizasyonu // Metod Referansı Numerical Analysis, 8th edition Richard L. Burden, J. Douglas Faires 3 // sayfa 617 import java.util. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. * class f1 extends f_xj { public double func(double x[]) { //çözümü istenen fonksiyon double ff Math.abs(a) -Math.abs(a)) } public static double MAX(double a,double b) {return (a > b . a b) } public static double linmin(f_xj f,double p[],double xi[]) { double tol=2.0e-4 int n=p.length double pcom[],xicom[] int j double xx,xmin,bx,ax f1dim f1=new f1dim(f,p,xi) ax=0.0 xx=1.0 bx=2.0 double aa[]=mnbrak(f1,ax,xx,bx) ax cx) b=((ax > cx) . a-x b-x)) } u=(Math.abs(d) >= tol1 . x+d x+SIGN(tol1,d)) fu=f.func(u) if (fu <= fx) { if (u >= x) a=x else b=x {v=w w=x x=u } {fv=fw fw=fx fx=fu } } else { if (u < x) a=u else b=u Çıktı 5.13-1 Davidon-Fletcher-Powell metodu Program 5.13-2 Davidon-Fletcher-Powell metodu (türev vektörü fonksiyon olarak verilmiş) // OPO12F Davidon-Fletcher-Powell optimizasyonu // Metod Referansı Numerical Analysis, 8th edition Richard L. Burden, J. Douglas Faires 3 // sayfa 617 import java.util. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. public static double turev(f_xj f,double x[],int denklem_ref,int x_ref) { // // verilen fonksiyonun ikinci türevlerinin matrisi // fonksiyon f in denklem_ref sayılı fonksiyonunun(sayılar 0 dan başlar) // x[x_ref] değişkenine göre türevi (sayılar 0 dan başlar) // df_denklem_ref(x)/d_x_ref // bu metod newtond metodu içinde kullanılmak içindir. // Accuracy of method can be adjusted by changing variables h0 and n // function input should be in the form given in abstract class // f_xj,j=0...x.length = df/dx(x_ref) double a[]=new double[x.length] for(int x_ref=0 x_ref<x.length x_ref++) { a[x_ref]=turev(f_deriv,x,x_ref) } return a Math.abs(a) -Math.abs(a)) } public static double MAX(double a,double b) {return (a > b . a b) } ax cx) b=((ax > cx) . a-x b-x)) } u=(Math.abs(d) >= tol1 . Çıktı 5.13-2 Davidon-Fletcher-Powell metodu (türev vektörü fonksiyon olarak verilmiş) Metodumuzu Hessian matrisinin direk olarak yine benzer dik iki vektör döngüsel yöntemleriyle hesaplanıp ters matrisinin çözümle hesaplanması şeklinde de oluşturabiliriz. Bu tür metod örneği olarak Broyden-Fletcher-Goldberg ve Shanno metodunu verebiliriz. Bu metodu Bir algoritma olarak adım adım tanımlıyalım 1. Bir ilk tahmin vektörü, x(0) verelim. Hessian matrisinin ilk tahmin değeri olarak birim vektörü alalım. H(0) = I. Dönüştürme parametresi  ve maksimum döngü (iterasyon) sayısı nmax'ı tanımlıyalım. K=0 olarak döngüye başlayalım c( 0)  f ( x ( 0) ) birinci türev (gradyan) vektörünü hesaplayalım. 2. Birinci türev (gradyan) vektörünün normunu c (k ) hesaplayalım. Eğer c (k )   ise döngüyü durduralım sonuca ulaşmış bulunuyoruz. 3. 4. d yönündeki optimum değer olan (k) değerini f(x(k)+(k)d(k)) tek boyutlu fonksiyonunun minimum değerini bularak saptayalım. Hessian matrisinin yeni değerini hesaplayalım (k ) (k ) (k ) c( k 1)  f ( x( k 1) ) 7. k'yi bir arttır k=k+1 ve step 2 ye geri dön. Eğer k değeri maksimum döngü (iterasyon) sayısı nmax a ulaşmışsa uyarı mesajı ver ve en son döngü değerlerini çıktı olarak ver. Bu algoritmada birinci türev (gradyan) vektörü dışarıdan girilen bir sınıfta tanımlanacağı gibi, sayısal türv programları tarafından da hesaplanabilir. Örnek programımızda iki durum için de metod verilmiştir. Örnek olarak yine bir önceki bölümde incelediğimiz f(x0,x1)=3x02-4x0x1+2x12-x0-x1 fonksiyonunun {x}=[-2,2] noktasından başlayarak minimum değerlerini bulma problemini irdeleyelim. Birinci ve ikinci döngü değerlerini elde hesaplama ödev olarak size bırakılmıştır. Program 5.14-1 Broyden - Fletcher-Goldfarb-Shanno (BFGS) metodu // Broyden - Fletcher-Goldfarb-Shanno (BFGS) metodu // Metod Referansı Intruduction to Optimum Design, Second Edition * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. double h0=0.256808 // [df/dx0, df/dx1,df/dx2,....,df/dxn] // df/dxj j=0...x.length // // bu fonksiyon bilgisayar tarafından hesaplanmaktadır // kullanıcı tarafından tanımlanan f(x) fonksiyonunun // sayısal olarak alınan türevidir. { for(i=0 i<n-m i++) { T[i][m]=(h[i]*h[i]*T[i+1][m-1] h[i+m]*h[i+m]*T[i][m-1])/(h[i]*h[i] - h[i+m]*h[i+m]) } } double xx=T[0][n-1] return xx } public static double[] turev(f_xj f_deriv,double x[]) { // df/dxj j=0...x.length // This method calculates turev of a function with more than one independent variable. Math.abs(a) -Math.abs(a)) } public static double MAX(double a,double b) {return (a > b . a b) } public static double linmin(f_xj f,double p[],double xi[]) { double tol=2.0e-10 int n=p.length double pcom[],xicom[] int j double xx,xmin,bx,ax f1dim f1=new f1dim(f,p,xi) ax=0.0 xx=1.0 bx=2.0 double aa[]=mnbrak(f1,ax,xx,bx) ax=aa[0] xx=aa[1] bx=aa[2] xmin=brent(f1,ax,xx,bx,tol) return xmin } public static double[][] linminiter(f_xj f,double p[],double xi[]) { // yeni iterasyon noktasını verir int n=p.length double xmin=linmin(f,p,xi) double aa[][]=new double[2][n] for (int j=0 j<n j++) { xi[j] *= xmin p[j] += xi[j] aa[0][j]=p[j] aa[1][j]=xi[j] } ax cx) b=((ax > cx) . a-x b-x)) } u=(Math.abs(d) >= tol1 . x+d x+SIGN(tol1,d)) fu=f.func(u) if (fu <= fx) { if (u >= x) a=x else b=x {v=w w=x x=u } {fv=fw fw=fx fx=fu } } else { if (u < x) a=u else b=u if (fu <= fw || w == x) { v=w } public static double[] multiply(double[] left,double right) { //multiplying a vector with a constant int i int n=left.length double b[] b=new double[n] for(i=0 i<n i++) { b[i]=right*left[i] } return b } Süreklilik metodunu kullanarak lineer olmıyan bir denklemin köklerini bulma işlemi detayları ile bölüm 4.13 de verilmişti. Newton metodundan hatırlayacağımız gibi optimizasyon problemi f(x1,x2,x3,…,xn) fonksiyon seti verildiğinde, birinci, ikinci türevler ve x değerleri iterasyon farkları 2 f x1 x2 2 f x22 2 f x1 x2 ... 2 f x2 xn 2 f x1 x3 2 f x21x3 2 f x32 ... 2 f x3 xn ... ... ... ... ... şeklinde verilebilir. (m+1) inci iterasyon için H { m m1 } {f m } şeklinde yazılabilir. Veya   1   Burada H m 1 Hesian matrisinin ters (inverse) matrisidir. Newton-Raphson yönteminde bu matrisi iteratif olarak çözüyorduk. Burada ise bölüm 4.13 de gördüğümüz süreklilik(continuity) yöntemini kullanacağız. Bu yöntemi, Newton-Raphson yöntemi gibi bir yöntem için ilk değer tahmini sağlamak amacı ile de kullanabiliriz. // kullanıcının türev fonksiyonu tanımlaması gerekmez import java.util. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. Math.abs(a) -Math.abs(a)) } public static double MAX(double a,double b) {return (a > b . a b) } public static double[] df(f_xj f,double xxi[]) { //Gredyen vektörü // f(x0,x1,x2,...xn) founksiyonunun türev vektörü // [df/dx0, df/dx1,df/dx2,....,df/dxn] // df/dxj j=0...x.length // // bu fonksiyon bilgisayar tarafından hesaplanmaktadır // kullanıcı tarafından tanımlanan f(x) fonksiyonunun // sayısal olarak alınan türevidir. // double a[]=new double[xxi.length] for(int i=0 i<xxi.length i++) { a[i]=dfdx(f,xxi,i) } return a } Çıktı 5.15-1 Süreklilik(Continuity-homotopy) yöntemi kullanarak optimizasyon Bu formül temel olarak Kiriş (Secant) kök bulma yönteminin çok boyutlu bir uygulamasıdır. Bir optimizasyon problemi olarak f(x) fonksiyonunun minimumunu bulmak istiyorsak bu prosesi daha önce de Newton metodu ve diğer metodlarda birinci türev vektörünün köklerini bulma olarak tanımlamıştık. Problemimiz f(x)'in minimumunu bulma olsun, burada x={x 1, x1,…, xn-1, xn} çok boyutlu değişken setidir. Bu durumda kiriş metodunu uygulayarak türev fonksiyonunu yaklaşık değerini oluşturabiliriz. Hatırlanacağı gibi, Newton-Raphson denkleminde f(x1,x2,x3,…,xn) fonksiyon seti verildiğinde, birinci, ikinci türevler ve x değerleri iterasyon farkları  f   x   1 ( x1m1  x1m )  f   m1  x  m  ( x2  x2 )  2  g  f   f  ve  m1  ( x3m1  x3m ) ve    x  ...    3 ( xnm1  xnm )  ...   f     xn  2 f x1 x2 2 f x1 x3 ... 2 f x22 2 f x21x3 ... 2 f x1 x2 2 f x32 ... ... ... ... 2 f x2 xn 2 f x3 xn ... g1 x2 g1 x3 g 2 x2 g 2 x3 g3 x2 g3 x3 ... g n x2 ... g n x3 g1  xn   g 2  ... xn   g3  ...  xn  ... ...   g n  xn  ... şeklinde verilebilir. (m+1) inci iterasyon için Newton-Raphson denklemi H { m m1 } {f m } =gm şeklinde verilebilir. Burada g j xk ( x(i ) )  h gibi bir formülle hesaplayabiliriz. Formüldeki h küçük bir sonlu değişim miktarı, ek ise k inci bileşeni 1 diğer bileşenleri 0 olan bir vektördür. Buradaki (i) iterasyon sayısını belirtir. Kiriş yöntemi uygulandığında Newton-raphson formülünün kök civarındaki hızlı yakınsaması yerini daha yavaş bir yakınsama hızına bırakır. Bu yüzden burada standart kiriş yöntemi yerine yakınsama hızı birim hesaplama başına daha etkin olan Broyden yöntemini inceleyeceğiz. Broyden yönteminde x(0) ilk iterasyonu verilmiş ise x(1) iterasyonunuNewton metodunu kullanarak hesaplayabiliriz. Bundan sonraki stepler için şu yaklaşımı kullanırız [ H ( x(0) )] {x(1)  x( 0) } = - {g ( x(0) } denklemi [ A1 ] {x(1)  x( 0) } = {g ( x(1)  g ( x(0) } şeklini alabilir. Bu denklemin geçerli olabilmesi için [ A1 ] vektörünün her z vektörü için [ A1 ] {z} = [g ( x(0) )]z [ A1 ] formülünü oluşturabiliriz. {x(1)  x( 0) }t z  0 tanımlarını gerçekleştirmesi gerekir. Bu temel tanımdan [ A1 ]  H ( x (0) )  buradaki [{g ( x (1) )  g ( x (0) )}  H ( x (0) )( x (1)  x (0) )]*( x (1)  x (0) )t x (1)  x ( 0) x (1)  x (0) 2 2 2 2 ifadesi 2 normudur. Norm tanımları 3. bölümümüzde verilmişdi. [ A1 ] değerini bulduktan sonra x vektörünün yeni değerini oluşturabiliriz. x(2)  x(1)  A11 g ( x(1) ) x ( 2) bulunduktan sonra bu değeri aynı yolla x (3) ü hesaplamak için kullanırız. Genel olarak formülümüz [ Ai ]  [ Ai 1 ]  [{g ( x (1) )  g ( x (0) )}  [ Ai 1 ]( x (1)  x (0) )]*( x (1)  x (0) )t x (1)  x (0) 2 2 x(i 1)  x(i )  Ai 1 g ( x(i ) ) formunu alır. Bu formülde her seferinde A matrisinin ters matrisini çözme zorunluluğumuz mevcuttur. Bu işlemi Gauss eleme yöntemi gibi bir yöntem kullanarak gerçekleştirebiliriz. Ancak Gauss yöntemide oldukça yüksek hesaplama zamanına ihtiyaç gösterir. Daha iyi bir alternatif iteratif Sherman-Morrison formülünü kullanmaktır. Sherman_Morrison formülü Ai-1 değerini direk olarak Ai-1-1 değerinden hesaplıyabilmemizi sağlar. Bu formülü şu stepleri kullanarak oluştururuz si  {x(1)  x(i 1) } yi  {g ( x(i ) )  g ( x(i 1) )} ( A  xy t )1  A1     1 yi  Ai 1si t  1 Ai   A  si  2   si 2   1 bu denklem sadece matris çarpımlarını kapsadığından toplam işlem olarak yapılması çok daha kolaydır. Bu denklemleri kullanarak oluşturulmuş Broyden optimizasyon algoritması Program 5.15-1 de verilmiştir. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. Çıktı 5.16.1 Sherman-Morrison Formüllü Broyden kiriş optimizasyon algoritması Adından da anlaşılacağı gibi temelini evrim kuramından almıştır. Temel olarak problemlerin evrim prosesinin en iyilerin hayatta kalması prensibine dayanır. Genetik algoritmalar canlı yapıların Darwin teorisinde belirtildiği gibi doğaya uyum mekanizması içinde kendi kendilerini genlerdeki değişmeyle değiştirmelerinin fonksiyonlara optimizasyon problemi olarak uyarlanmış halidir. Darwin teorisi anne ve babaların özelliklerinin çocuklara geçtiğini, bazen de anne ve babada olmayan yeni bazı özelliklerin mutasyon denilen mekanizmayla oluştuğunu, bu özellikler türün yaşama şansını arttırıyorsa bu bireylerin çoğalarak bu özellikleri kendi çocuklarına geçirdiği, özellikler başarısızsa ölecekleri için başarısız özellikleri gelecek nesillere geçiremeyecekleri böylece ancak doğaya uyumda başarılı olan özelliklerin daha sonraki nesillerde birikmesi sonucu doğaya uyum sağlayan türlerin oluşabileceğini getirmiştir. Daha sonra Genetik biliminin gelişmesiyle bu prensibin altındaki biokimyasal yapılar (genler) bulunmuş ve bu sistemin matematiksel ve istatistiksel olarak nasıl çalıştığı daha detaylı anlaşılmıştır. Genler 4 amino asitin yapısı içinde sıralanması ile canlı yapıların özelliklerinin anahtarını oluştururlar. Bu özellikler, anne ve babadan gelen genlerle çocuklara aktarıldığı gibi bu aktarma prosesinde zaman zaman oluşabilen hatalarda darwinin tanımladığı mutasyon prosesini oluşturmaktadır. Evrimsel hesaplama ilk defa 1960'lı yıllarda I Rechenberg'in Evolutionsstrategie in original evrim statejileri çalışmasında yer almıştır. Fikir daha sonra başka araştırıcılarca geliştirilmiştir. Genetik algoritmalar John Holland ve öğrencileri tarafından ilk defa bu günkü anlamıyla oluşturulmuştur. 1975 yılında basılan Adaption in Natural and Artificial Systems kitabında yazar bu tekniğin nasıl kullanılacağını açıklamıştır 5.17.1 Her hücre bir veya daha fazla kromozom seti barındırır. Ve tüm organizmanın modelini içlerinde barındırırlar. Kromozom DNA'lardan oluşan gen bloklarını barındırır. Her genin belli bir özelliğin kodunu taşıdığı söylenebilir, örneğin göz rengi gibi. Bu özelliklerin alabildiği değerlere de gen değerleri adı verilir(örneğin kahverengi göz, yeşil göz). Kromozomların hepsi bir arada canlının karekterlerini oluşturur, buna cenom denir. Cenomdaki belli bir özelliği oluşturan guruba cenotip ismi verilir. Canlıların doğumdan sonra çevresel etkiler yoluyle oluşan özeliklerine de fenotip ismi verilir. Üreme esnasında önce rekombinasyon oluşur, anne ve babaları genleri bölünerek birleşirler ve yeni bir gen yapısı oluştururlar. Doğal Uyum organizmanın hayatta kalma başarısı ile ölçülen ve gen guruplarının direk olarak etkilediği bir olaydır. Genetik algoritmalar yukarda değindiğimiz mekanizmanın yeni nesiller üretmekte ve yeni nesillerin doğaya uyum mekanizmasını açıklayan Darwin teorisinden yola çıkarak oluşturulmuştur. Algoritma kromozomlardan oluşan bir gurup çözüm setinden oluşur. Başarılı bireylerin daha fazla üreme olasılığı olacağından genlerinin bir sonraki nesle geçme olasılığı daha yüksektir. Bireylerde aynı zamanda mutasyon yoluyla tamamen yeni özellikler oluşabilir, bu özellikleri bir kısmı bu bireylerin başarısını azaltırken bazen de daha başarılı yeni bireyler de oluşabilir. Eğer üreme olmadı ise eski nesli koruyun. Gen veya kromozon genetik hesaplamada kullanılan temel elemanlardır. Matematiksel olarak düşünürsek n değişkenli bir sistemde her değişkeni bir gen olarak düşünürüz. Tüm değişken setini bütün olarak kromozon olarak adlandırabiliriz. Kromozonların yapıları kromozom A kromozon B kromozon C kromozom D (+ x (/ 5 y)) kromozom E ( do_until step wall ) Gibi birbirinden çok farklı eleman tipleri kullanılarak oluşturulabilir. Doğadaki gerçek genlerde uyum dediğimizde doğada hayatta kalabilme yeteneğini anlıyoruz. Matematiksel olarak optimizasyon(maksimizasyon) için bu kavramı kullanacak olursak burada fonksiyonun değeridir. Daha sonra bu uyum değerleri toplanarak yüzde şekline çevrilebilir. Bu yüzdeye çevrilmiş uyum değer fonksiyonlarının arasından tesadüfi olarak seçim yaparsak, tesadüfi seçimde sayıların toplanmış yüzde olasılığı daha iyi uyum gösteren (maksimum fonksiyon değerini alan) birey için daha yüksektir. Uyum gösteren bireyler arasından tesadüfi olarak seçilen kısmının bir sonraki nesli üretmesine(çoğalmasına) izin verilir. Çoğalma prosesi anne ve baba diyebileceğimiz iki bireyin genlerinin birleşerek yeni bir birey (çocuk) oluşturmasıdır. Matematiksel olarak buna çaprazlama prosesi denir. Çaprazlama anne ve baba genlerinin bir kısmının (tesadüfi olarak) seçilerek bir araya getirilmesi ile gerçekleşir. Örneğin binari rakamlardan oluşan bir gen için Eğer tek çaprazlama metod kullanırsak, bu metodda tek bir tesadüfi sayı gen gurubunu belli bir oranda böler. Aynı oranda bölünen genin bir kısmı anneden diğer kısmı da babadan alınır. Ve yeni bireyi oluşturur. Genlerin bölme oranı tesadüfi olarak belirlenir. Örneğin 8 bitten oluşan bir gurup için 8*random(0-1) = 5 ise ilk 5 bitti anneden, son 3 biti babadan alarak yeni bireyi oluştururuz. 11001011 + 11011111 = 11001111 Kromozom 1 (Anne) 11011 | 00100110110 Kromozom 2 (Baba) 11011 | 11000011110 1. Çocuk 2. Çocuk 11011 | 11000011110 11011 | 00100110110 Eğer çift çaprazlama uygulamak istersek, bu metodda iki tesadüfi sayı gen gurubunu belli bir oranda üç parçaya böler. Aynı oranda bölünen genin bir kısmı anneden diğer kısmı da babadan sonra kısım tekrar anneden alınır (veya tersi yapılır). Ve yeni bireyi oluşturur. Genlerin bölme oranı tesadüfi olarak belirlenir. Örneğin 8 bitten oluşan bir gurup için Random1=8*random(0-1) = 2 Random2=8*random(0-1) = 6 ise ilk 2 biti anneden, 3 den 6ıncı bite kadar babadan ve 7 ve 8 inci biti tekrar biti babadan alarak yeni bireyi oluştururuz. 11001011 + 11011111 = 11011111 Eğer düzenli çaprazlama uyulamak istersek, bu metodda her gen tesadüfi olarak anneden veya babadan seçilerek yeni birey(çocuk) oluşturulur. 11001011 + 11011111 = 11001011 Optimizasyon (Minimizasyon-Maksimizasyon) problemi Matematiksel olarak f(x1,x2,x3,…..xi) fonksiyonunun maksimumunu bulma olarak tanımlanabilir. Bu işlemi oluştururken önce maksimum ve minimum işleminin aynı işlem olduğunu unutmıyalım max [ f(x) ] = min [- f(x) ] = min [ g(x) ] Fonksiyon oluşturmada göz önüne alınması gereken diğer bir konu da fonksiyon değerine sabit bir değer ilave ettiğimizde maximum değerin yerinin değişmiyeceğidir. max [ f(x) ] = max [ f(x) + C ] = max [ g(x) ] Bu özelliği kullanarak fonksiyonumuzun çözümünün her zaman pozitif bölgeye düşmesini sağlıyabiliriz. Mühendislik optimizasyonunda çözdüğümüz sayıların çoğu gerçek sayılar olmak zorundadır. Ancak bu gerçek bir sayıyı bir binari sayılar dizini olarak ifade etmek her zaman mümkündür. Programi optimizasyon problemi olarak düşündüğümüzde bir gurup bağımsız değişkenimiz mevcuttur (x0,x1,x2,..xi..xn) Genetik algoritmaları uygulamak için her bağımsız değişkenin sınır değerlerinin (maksimum ve minumum) bilinmesi zorunludur. Bu yüzden değişken gurubumuz için xo xo_minimum xo_maximum x1 x1_minimum x1_maximum …. xi xi_minimum xi_maximum … xn xn_minimum xn_maximum Tanımları yapılır. Her bağımsız değişken için ayrıca değişkenin binari eşdeğerinin kaç bir olacağının tanımlanması gerekir. Bağımsız değişkenimiz xi_min <= xi <= xi_max N bit binary Olarak tanımlanmış ise Binary eşdeğeri veya binari olarak verilmiş sayının gerçek sayı eşdeğeri iki adımlık bir prosesle hesaplanabilir. N digitlik bir binary gurubu tamsayıya N 1 Denklemi ile dönüştürülebilir. x' 10 tabanından bir tamsayıdır. Buna karşı gelen gerçek sayı ise  x_max - x_min  x  x_min  x'   2N 1   İfadesiyle hesaplanır. Aynı işlem ters olarak yapılarak da gerçek sayıdan binari sayıya ulaşılabilir Bağımsız değişkenler her biri bir gen olmak için NDEĞİŞKEN kapsayan bir gurupta genlerin tek bir uzun binari dizide toplanması ile veya geni ihtiva eden sınıfın dizini olarak ifade edilebilir. Dizinlerden elde edilen bağımsız değişkenler optimizasyonu yapılacak fonksiyonda girdi olarak kullanılarak fonksiyonun değeri hesaplanır. Programlama yapılırken değişik fonksiyonlar girilebilecek şekilde yapılırsa kodlama açısından daha genel bir kod elde edebilirsiniz. Bir veya daha fazla cenotip kromozomlar olarak bir araya gelebilir. (bir veya birden fazla fonksiyon bir arada değerlendirilebilir). Kromozon sayılarını da birden fazla düşünebiliriz. Bu sistem hep birlikte toplumumuzun bireylerini oluşturur (Optimize edilecek denklem sistemi ve bağımsız değişkenler sınır değerleri) Programlayıcı veya program kullanıcısı tarafından toplumuzun kaç bireyden oluşacağı önceden belirlenir. Bu sayıya eşdeğer birey bağımsız değişken değerleri tesadüfi sayılardan oluşan(sayını verilen limit değerleri içinde) bir set olarak oluşturulur. Fonksiyon değerleri de her cenotip için hesaplanır. (Mühendislik optimizasyon problemlerinde genelde çok değişkenli bir fonksiyon mevcuttur). Bu değerler genin uyum değerleridir. Tüm toplum bireylerinin uyum değerleri toplanarak toplam uyum hesaplanır. Sonra uyum değerleri toplam uyuma bölünerek göreceli uyum değerleri elde edilir. Göreceli uyum değerleri de birinci bireyden itibaren her birey için toplanarak toplanmış göreceli (kümülatif) uyum değerleri saptanır. Listedeki ilk bireyin toplanmış göreceli uyum değeri göreceli uyum değerine eşittir. Son bireyin ise bir'e eşittir. Toplanmış göreceli uyum değerleri olasılıkları, uyumun büyüklüğüne göre oluşmuştur. Eğer listemizden tesadüfi rakamlar aracılığı ile yeni bir nesil için seçme yapacak olursak tesadüfi rakamlar göreceli olarak eşit dağılacağından, daha yüksek uyuma sahip bireylerin seçilme şansı daha yüksektir. Aynı bireyin birden fazla kere seçilmesine de müsaade edilir. Seçilen yeni toplum bireyleri arasında kullanıcılar tarafından belirlenen bir yüzde içerisinde kalan kısmının mutasyon prosesine girmesine izin verilir. Kullanıcı toplumdaki mutasyon yüzdesini tanımlar. Bu bireyin değeri ayrı bir yerde tutularak tüm proses boyunca takip edilebilir. Eğer istenirse her nesilde en başarılı olan birey bir sonraki nesillere aktarılabilir. Gen yapısını taklit etmek için bizim kurduğumuz modelde bilgisayar bitleri kullanılmıştır. Gene sınıfı gerekli prosesleri bit olarak yapar, eşdeğer olarak double değerini de hesaplayabiliriz, double-bit değişkenini kendi isteğimize göre yapabiliriz. Değişkenin bit uzunluğu da isteğe göre değişken olarak verilmiştir. Gene sınıfı değişkeni maksimum 64 bit (0-63) olmak üzere ayarlanabilir. Gene sınıfı içersinde çaprazlama ve mutasyon yapma metodlarını da barındırır.