Çaprazlama olarak yukarda belirtilen 3 çeşit çaprazlama mümkündür (düzenli çarprazlama, tek çaprazlama, çift çaprazlama). Sınıf double değerden veya 00110100111 gibi bir bit String değerinden de okuma yapabilir. 5.17.3 Program 5.17.3-1 Gene sınıfı İmport java.util. * import java.io. * b=(BitSet)g.b.clone() xN=Math.pow(2.0,N)-1 xmin=g.xmin xmax=g.xmax } public Gene copyGene() { Gene g=new Gene(this) return g } public Gene(Gene Father,Gene Mother) { //crosovertype will be selected randomly double ix=Math.random() if(ix<0.1) setGene(Father,Mother, regular ) else if(ix>0.9) setGene(Father,Mother, single ) else setGene(Father,Mother, double ) } } } s+= ) +getX() return s } public boolean boolean_random() { if(Math.random()<=0.5) return false else return true } public int int_random() { int x1=(int)(Math.random()*N) return x1 } public double double_random() { return (xmin+Math.random()*(xmax-xmin)) } public void setbits() { b.clear() for(int i=0 i<N i++) { if(boolean_random()) b.set(i) } } public void flip(int i) { b.flip(i) } public void mutate() { //fip one bit of data int i1=int_random() if(i1<0) i1=0 b.flip(i1) } } Gene sınıfının biraz daha açılabilmesi için çeşitli örnekler verilmiştir. İlk örneğimizde 63 bitlik 5 adet Gene tipi değişken oluşturuyoruz. Değişken değerleri gelişigüzel yüklenmektedir. Program 5.17.3-2 geneTest sınıfı ile çeşitli 63 bitlik Gen'ler oluşturma (sayı 0 ile 10 arası) public class geneTest { public static void main(String arg[]) { Gene x1=new Gene(0,10,63) for(int i=0 i<5 i++) { x1.setbits() System.out.println(x1.toString()) } } } Genetik anlamda bakıldığında kromozona eşdeğerdir. Matematik olarak düşünüldüğünde ise n boyutlu f(x1,x2,x3,…,xn) fonksiyonun tüm değişkenlerine karşı gelen bir toplam değişken setidir. Fonksiyon uyum değerlerini ve kümülatif uyum değerlerini hesaplar. Bu sınıfta genetik optimizasyon gerçekleştirilmektedir. Burada bazı değişkenler kullanıcı tarafından verilmelidir. Genetic sınıfı tüm Genetik optimizasyon proseslerini barındırır. Bu işlemlerden evaluate bireylerin uyumlarını (fonksiyon değerlerini) hesaplar. Genetik algoritmalarda fonksiyon değerlendirmesinde önemli olan bir konuda tüm fonksiyon değerlerinin pozitif olma gerekliliğidir. – olarak değerlendirilen fonksiyonlar sabit bir değer eklenerek artı olarak değerlendirilecek fonksiyonlara dönüştürülebilir. Bu proses fonksiyonun optimum noktasını değiştirmez. f(x1,x2,x3,…,xn) fonksiyonunun maksimumu g(x1,x2,x3,…,xn) = f(x1,x2,x3,…,xn) + C fonksiyonunun maksimumuyla aynıdır. Bu proses kümülatif uyumu hesaplarken bir hata olmasını önler. Evaluate prosesi bireylerin uyum değerlerini ve kümülatif uyum değerlerini hesaplar Select metodu kümülatif uyumdaki başarılı bireyler arasından yeni nesli üretme hakkına sahip olacakları tesadüfi proses kullanarak seçer. Crossover prosesi select prosesi tarafından seçilen bireylerden yeni bireyler üretir. Mutate prosesi verilen belli bir yüzdedeki populasyonu mutasyona uğramasını sağlar Calculate prosesi tüm üstteki prosesleri sırayla ve toplam nesil sayısına göre itere ederek toplam nesil sayısı sonundaki nufusu(populasyonu) elde eder. Program 5.17.3-5 genotype1 sınıfı ve Genetic1 sınıfı İmport java.io. * import java.text. * import java.util.Locale abstract class f_xj { // single function multi independent variable // a single value is returned indiced to equation_ref // example f[0]=x[0]+sin(x[1]) // f[1]=x[0]*x[0]-x[1] // func(x,1) returns the value of f[1] // func(x,0) returns the value of f[0] abstract double func(double x[]) } public void setGene(int val) { G[val]=new Gene(Lower[val],Upper[val],N) } İlk örnek fonksiyon olarak f(x0,x1)=2x0 x1+2x0-x02-2x12+10 fonksiyonuna bakalım. bu fonksiyon örneğin Program 5.10-1 da kullanılan f(x0,x1)=2x0 x1+2x0-x02-2x12 fonksiyonun aynısıdır, ancak burada artı değeri her zaman sağlayabilmek için fonksiyonumuza 10 değeri ilave edilmiştir. Bu tür bir fonsiyonda geometrik metodlarında bize rahatlıkla çözüm verebildiğini anımsayalım. Program 5.17.3-6 OPO17 örnek problem sınıfı (iki bilinmyenli fonksiyon) İmport java.io. Çıktı 5.17.3-5 OPO17 örnek problem sınıfı ---------- Capture Output ---------> C \co\java\bin\java.exe OPO17 best= 2.000240326844509 1.000251770979961 11.999999936480407 > Terminated with exit code 0. İkinci örnek fonksiyon olarak f(x0)=x0 sin(x+1 fonksiyonuna bakalım. Bu fonksiyonu -1 ile 2 arasındaki maksimum değerini bulmak istiyoruz. Fonksiyonu değerlendirecek olur isek değerleri -1 ile 3 arasında değiştiğini görürüz. Dönüşümü garanti altına alabilmek için fonksiyona 2 değeri eklersek f(x0)=x0 sin(x+3 şekline dönüşür. Bu fonksiyonun geometrik metodlarla çözülmesi oldukça zordur. Çıktı 5.17.3-7 de fonksiyonun grafiğini görmekteyiz. Buradan da görebileceğiniz gibi bu fonksiyonda bir çok yerel maksimum bulunmaktadır. Bu yüzden de geometrk algoritmalarımız bu yerel maksimumlarda takılarak bize global çözüm sağlamadan duracaklardır. Program 5.17.3-7 OPO17A örnek problem sınıfı (bir bilinmeyenli fonksiyon) import java.io. class OPO17A { public static void main(String args[]) throws IOException { Çıktı 5.17.3-6 OPO17A örnek problem sınıfı (bir bilinmeyenli fonksiyon) ---------- Capture Output ---------> C \co\java\bin\java.exe OPO17A best= 1.850596811663863 4.850271542089701 > Terminated with exit code 0. Çıktı 5.17.3-7 OPO17A örnek problem sınıfı grafik gösterimi (bir bilinmeyenli fonksiyon) Bu fonksiyonu geometrik bir arama yönteminde kullanamaya çalıştığımızda başarılı olamadığımızı görebiliriz. Son olarak iki boyutlu kompleks geometriye sahip bir fonksiyonu inceleyelim Program 5.17.3-8 OPO17B örnek problem sınıfı (iki bilinmeyenli fonksiyon) İmport java.io. * Çıktı 5.15.3-8 OPO17B örnek problem sınıfı (iki bilinmeyenli fonksiyon) ---------- Capture Output ---------> C \co\java\bin\java.exe OPO17B best= 11.625012683916792 5.800000000000000 38.925010694354235 > Terminated with exit code 0. Çıktı 5.17.3-9 OPO17B örnek problem sınıfı (iki bilinmeyenli fonksiyon) üç boyutlu grafik çıktısı Bu fonksiyonun da geometrik optimizasyon metodları ile çözümü zor olabilir. Bitirirken son bir noktaya tekrar dikkatinizi çekmek istiyoruz. Genetik algoritmaların bulduğu değerler istatistik proses sonucu bulunduğundan her zaman aynı değeri vermeyecektir. Örneğin yukarıdaki problem için çıktıyı tekrar aldığımda Çıktı 5.17.3-10 OPO17B örnek problem sınıfı (iki bilinmeyenli fonksiyon) ---------- Capture Output ---------> C \co\java\bin\javaw.exe OPO17B best= 11.624436662432336 5.800000000000000 38.920512521726340 > Terminated with exit code 0. Görüldüğü gibi sonuçlar tam olarak aynı değildir. Genetik algoritmaların veya genelde istatistik yaklaşımlı metodların geometrik yöntemlerden en önemli farklarından birisi de budur. Geometrik yöntemler aynı şartlar verildiğinde hep aynı sonuca ulaşırlar. Geometrik formüllerle çözmesi zor olabilecek bir fonksiyon daha verelim Program 5.17.3-9 OPO19C örnek problem sınıfı (iki bilinmeyenli fonksiyon) İmport java.io. * import javax.swing. * class fa extends f_xj { Çıktı 5.16-3-11 OPO19C örnek problem sınıfı (iki bilinmeyenli fonksiyon) Çıktı 5.17.3-12 OPO19C örnek problem sınıfı (iki bilinmeyenli fonksiyon) üç boyutlu grafik çıktısı 5.17.4 Üstte verdiğimiz genetik algoritma modelinde binary bit modelinden yararlanarak temel gen yapımızı oluşturmuştuk. Şimdi aynı temel gen kavramını farklı bir şekilde oluşturmaya çalışacağız. Bu versiyonumuzda temel olarak gauss dağılımlı tesadüfi rakam kavramından yararlanacağız. Şu ana kadar eşit dağılımlı tesadüfi rakam kavramından sıkça yararlandık. Gauss tesadüfi rakamları verilen aralıkta her nokta için eşit ağırlıkta tesadüfi sayılar yerine verilen bir ortalama değer civarında daha fazla kümeleşen çan eğrisi şeklinde dağılım gösteren tesadüfi sayılar üretir. Oluşturulan 500000 rakam için dağılım grafiğide çıktı 5.16.4-2 de verilmiştir. tesadügi sayının bellibirnoktada yoğunlaşması anne ve baba bireylerinden çocuk bireyi oluştururken anne ve baba bireylerin özelliklerinin çocuklara geçirilmesi yönünde önemlidir. Böylece oluşan yenitesadüfi sayı üretildiği bireyin özelliklerini belli bir oranda korur, ancak aynı olmak veya her zaman çok yakın olmak zorunda da değildir. Program 5.17.4-1 Gauss dağılımlı tesadüfi rakam kontrolu 500000 rakam oluşturulduğunda dağılım grafiği import java.io. Gen sınıfı işlevsel olarak, yukarıda oluşturulmuş olan Gene sınıfı ile aynı işlevi görür. Temelfark Gene sınıfında mutasyon çaprazlama işlemleri bitler üzerinden gerçekleştirilirken, burada gauss tesedüfi sayıları üzerinden gerçekleştirilmektedir. // Gen Class // Gen class generates a double number represent a gene import java.util. * import java.io. * public class Gen extends Object { public double xmin,xmax //maximum and minimum limits of double number public double x public static double gaussrandom(double ixmin,double ixmax,double ix) { double d1=ixmax-ix double d2=ix-ixmin double d=Math.abs(Math.min(d1,d2)) ix=gaussrandom(ix,d) return ix } public static void gaussrandom() { double d1=xmax-x double d2=x-xmin double d=Math.abs(Math.min(d1,d2)) x=gaussrandom(x,d) } public Gen() { xmin=0 xmax=1.0 x=xmin+Math.random() } public Gen(Gen g) { xmin=g.xmin xmax=g.xmax x=g.x } public void copyGen(Gen g) { xmin=g.xmin xmax=g.xmax x=g.x } public Gen copyGen() { Gen g=new Gen(this) return g } public Gen(Gen Father,Gen Mother) {setGen(Father,Mother) } public void setGen(Gen Father,Gen Mother) { xmin=Father.xmin xmax=Father.xmax double r1=xmax-xmin double r=Math.random() double d1=xmax-Father.x double d2=Father.x-xmin double d=Math.abs(Math.min(d1,d2)) double r2=gaussrandom(Father.x,d) d1=xmax-Mother.x d2=Mother.x-xmin d=Math.abs(Math.min(d1,d2)) double r3=gaussrandom(Mother.x,d) x=r2*r+r3*(1-r) System.out.println( r2= +r2+ r3= +r3+ r= +r) if(x<xmin) x=xmin else if(x>xmax) x=xmax } public void cross1(double crossratio,Gen Father,Gen Mother) {xmin=Father.xmin xmax=Father.xmax double r1=xmax-xmin double d1=xmax-Father.x double d2=Father.x-xmin double d=Math.abs(Math.min(d1,d2)) double gr1=gaussrandom(Father.x,d) d1=xmax-Mother.x d2=Mother.x-xmin d=Math.abs(Math.min(d1,d2)) double gr2=gaussrandom(Mother.x,d) x=gr1*crossratio+gr2*(1-crossratio) if(x<xmin) x=xmin else if(x>xmax) x=xmax } public void cross2(double crossratio,Gen Father,Gen Mother) {xmin=Father.xmin xmax=Father.xmax double r1=xmax-xmin double d1=xmax-Father.x double d2=Father.x-xmin double d=Math.abs(Math.min(d1,d2)) double gr1=gaussrandom(Father.x,d) d1=xmax-Mother.x d2=Mother.x-xmin d=Math.abs(Math.min(d1,d2)) double gr2=gaussrandom(Mother.x,d) x=gr1*(1.0-crossratio)+gr2*crossratio if(x<xmin) x=xmin else if(x>xmax) x=xmax } public double getX() {//return double number equivalent of bit set number return x } public boolean boolean_random() { if(Math.random()<=0.5) return false else return true } public double double_random() { return (xmin+Math.random()*(xmax-xmin)) } public void mutate() { double r=(xmax-xmin) double d1=xmax-x double d2=x-xmin double d=Math.abs(Math.min(d1,d2)) x=gaussrandom(x,d) }} Gen Gauss tesadüfi sayı-double değişken türünün bir anlamda boyutlu değişkeni gibi düşünülebilir. Genetik anlamda bakıldığında kromozona eşdeğerdir. Matematik olarak düşünüldüğünde ise n boyutlu f(x1,x2,x3,…,xn) fonksiyonun tüm değişkenlerine karşı gelen bir toplam değişken setidir. Fonksiyon uyum değerlerini ve kümülatif uyum değerlerini hesaplar. Program 5.17.4-3 Gentype sınıfı Gauss tesadüfi sayı üzerinden temel gen işlemlerini(mutasyon, çaprazlama) hesaplayan gen sınıfının boyutlu şeklini içerir (canlılardaki kromozona eşdeğerdir) import java.io. * import java.text. Yapı olarak Genetik1 sınıfının aynı yapısı korunmuştur(sadece alt değişken sınıfları değiştirilmiştir) Bu sınıfta genetik optimizasyon gerçekleştirilmektedir. Burada bazı değişkenler kullanıcı tarafından verilmelidir. Genetic2 sınıfı tüm Genetik optimizasyon proseslerini barındırır. Bu işlemlerden evaluate bireylerin uyumlarını (fonksiyon değerlerini) hesaplar. Genetik algoritmalarda fonksiyon değerlendirmesinde önemli olan bir konuda tüm fonksiyon değerlerinin pozitif olma gerekliliğidir. – olarak değerlendirilen fonksiyonlar sabit bir değer eklenerek artı olarak değerlendirilecek fonksiyonlara dönüştürülebilir. Bu proses fonksiyonun optimum noktasını değiştirmez. f(x1,x2,x3,…,xn) fonksiyonunun maksimumu g(x1,x2,x3,…,xn) = f(x1,x2,x3,…,xn) + C fonksiyonunun maksimumuyla aynıdır. Bu proses kümülatif uyumu hesaplarken bir hata olmasını önler. Evaluate prosesi bireylerin uyum değerlerini ve kümülatif uyum değerlerini hesaplar Select metodu kümülatif uyumdaki başarılı bireyler arasından yeni nesli üretme hakkına sahip olacakları tesadüfi proses kullanarak seçer. Crossover prosesi select prosesi tarafından seçilen bireylerden yeni bireyler üretir. Mutate prosesi verilen belli bir yüzdedeki populasyonu mutasyona uğramasını sağlar Calculate prosesi tüm üstteki prosesleri sırayla ve toplam nesil sayısına göre itere ederek toplam nesil sayısı sonundaki nufusu(populasyonu) elde eder. Program 5.17.4-4 Genetic2 sınıfı temel genetik algoritma hesaplarını içerir. Şimdi sonuçları görmek için bir örnek problem verelim. Örnek problem olarak yukarda bit temelli genetik algoritmada kullandığımız aynı test fonksiyonunu aldık. Program 5.17.4-5 Genetic2 sınıfı test programı. import java.io. return ff //maksimum testi } } Çıktı 5.17.4-2 Genetic2 sınıfı test programı. ---------- Capture Output ---------> C \co\java\bin\javaw.exe OPO17C best= 2.001822704663157 0.991019679146159 11.999802648477040 > Terminated with exit code 0. Yukarda da kullandığımız bu test fonksiyonunun çözüm seti 2 ve 1 değerleridir. Bu bölümde ise temel gen yapısını long tipi değişken kullanarak oluşturacağız. Bildiğiniz gibi burada asıl amacımız double tipi sayılar oluşturmak ancak bu sayıları her zaman için verilen sınırlar içinde tutara oluşturmaktır. Aynı zamanda eger sayı bir anne baba setinden oluşturuluyorsa o setlerin genetik karekterlerini (özeliklerini) belli bir oranda taşımalıdır. Matematiksel olarak baktığımızda bu rakamlardan çok farklı olmamalıdır diyebiliriz. İki değişkenli set (burada long ve double) bize birinci değişken olası tüm değerleri alırken ikinci değişkenin verilen değişken aralığında kalmasını sağlar. Burada da Genotype3 ve Gene3 sınıflarında daha önceki aynı yapı korunmuş, sadece temel değişken olarak Gene3 sınıfını kullanması sağlanmıştır. 5.17.5 * import java.io. * public class Gene3 extends Object { //long imin=0 int N=9 long imax=999999999 public long ix public double x //Limit value for integer(2^N-1) public double xmin,xmax //maximum and minimum limits of double number public Gene3(double ixmin,double ixmax) {//randomly generate the gene xmin=ixmin xmax=ixmax ix=(long)(imax*Math.random()) x=xmin+(xmax-xmin)*(double)ix/(double)imax } public Gene3(Gene3 g) { // copy a Gene from another one copyGene(g) } public void copyGene(Gene3 g) { ix=g.ix x=g.x xmin=g.xmin xmax=g.xmax } public Gene3 copyGene() {Gene3 g=new Gene3(x,xmin,xmax) return g } public Gene3(Gene3 Father,Gene3 Mother) {cross(Math.random(),Father,Mother) } public Gene3(double xi,double maxi,double mini) {setGene(xi,maxi,mini) } public Gene3(double crossratio,Gene3 Father,Gene3 Mother) { if(boolean_random()) cross(crossratio,Father,Mother) else cross(crossratio,Mother,Father) } public void setGene(long iix,double ixmin,double ixmax) { xmin=ixmin xmax=ixmax ix=iix x=xmin+(xmax-xmin)*(double)ix/(double)imax } public void setGene(double idx,double ixmin,double ixmax) { xmin=ixmin xmax=ixmax if(idx>=xmin && idx<=xmax) x=idx else if(idx<xmin) x=xmin else x=xmax ix=(long)((x-xmin)/(xmax-xmin)*imax) } public void setGene(double idx) { if(idx>=xmin && idx<=xmax) x=idx else if(idx<xmin) x=xmin else x=xmax ix=(long)((x-xmin)/(xmax-xmin)*imax) } public void cross(Gene3 Father,Gene3 Mother) {double crossratio=Math.random() cross(crossratio,Father,Mother) } Program 5.17.5-2 genotype3 ve Genetic3 sınıfları import java.io. * import java.text. public void setRFCF(genotype3 Pi[]) { //calculates relative and cumulative fitness functions int mem int PN=Pi.length double sum=0.0 //total fitness of population for(mem=0 mem<PN mem++) {sum+=Pi[mem].Fitness } //System.out.println( sum= +sum) //calculate relative fitness of each genotype3 for(mem=0 mem<PN mem++) {Pi[mem].setRFitness(sum) } //calculate cumulative fitness Pi[0].setCFitness(Pi[0].getRFitness()) for(mem=1 mem<PN mem++) {Pi[mem].setCFitness(Pi[mem-1].getCFitness()+Pi[mem].getRFitness()) } } public void toString(genotype3 Pi[]) { int mem int PN=Pi.length for(mem=0 mem<PN mem++) { //list them System.out.println( Population[ +mem+ ]= +Pi[mem].toString()) } } public void select(f_xj fi) { //select the new generation members of population double r int mem setRFCF(Population) //create a new population genotype3 Po[]=copyPopulation(fi) select(fi) crossover(fi) mutate(fi) evaluate(fi) //if(report) //System.out.println(report()) } return getBest() } } Program 5.17.5-3 Gene3 sınıfı testi Gene3test public class Gene3test { public static void main(String arg[]) { Gene3 x1=new Gene3(0.0,10.0) System.out.println( x1 = +x1.toString()) Gene3 x2=new Gene3(0.0,10.0) System.out.println( x2 = +x2.toString()) double xx=Math.random() Gene3 x3=new Gene3(xx,x1,x2) System.out.println( xx = +xx+ x3 = +x3.toString()) x3.mutate() System.out.println( mutasyon sonucu x3 = +x3.toString()) } } Çıktı 5.17.5-1 Gene3 sınıfı testi ---------- Capture Output ---------> C \co\java\bin\java.exe Gene3test x1 = x = 8.792631687926317ix = 87926316xmin = 0.0xmax = 10.0 x2 = x = 8.852918088529181ix = 88529180xmin = 0.0xmax = 10.0 xx = 0.8077212904815896x3 = x = 8.887598688875986ix = 88875986xmin = 0.0xmax = 10.0 mutasyon sonucu x3 = x = 8.887498688874986ix = 88874986xmin = 0.0xmax = 10.0 > Terminated with exit code 0. Program 5.17.5-4 Genetik optimizasyon örneği 1 , bir boyutlu fonksiyon import java.io. Çıktı 5.17.5-1 optimizasyon örneği 1 , bir boyutlu fonksiyon ---------- Capture Output ---------> C \co\java\bin\java.exe OPO17A3 best= 1.852909818529098 4.845173160789873 > Terminated with exit code 0. Program 5.17.5-5 Genetik optimizasyon örneği 2 , çok boyutlu fonksiyon import java.io. * import javax.swing. Çıktı 5.17.5-2 optimizasyon örneği 2 , iki boyutlu fonksiyon Nokta sayısı çok arttığında istatistik olarak tüm alan taranmuş olur. Bu yöntem temel olarak grafik yöntemine benzetilebilir, ancak toplam fonksiyon değerlendirme sayısı grafik yönteminden bile çok fazla olmalıdır. Temel olarak çok pratik bir yöntem olmamakla birlikte yazılması ve kullanılmasındaki kolaylık nedeniyle kullanılabilir. * import java.io. * abstract class f_xj extends Mathd { // single function multi independent variable // a single value is returned indiced to equation_ref // example f[0]=x[0]+sin(x[1]) // f[1]=x[0]*x[0]-x[1] // func(x,1) returns the value of f[1] // func(x,0) returns the value of f[0] abstract double func(double x[]) } public class monte_carlo_opt extends Object { int N public double max[] public double min[] public double x public monte_carlo_opt(int Ni,double imin[],double imax[]) { max=new double[imin.length] min=new double[imin.length] N=Ni int n=imin.length for(int i=0 i<n i++) {min[i]=imin[i] max[i]=imax[i] } } public double[] monte_carlo_max(f_xj fi) { int n=min.length double x[]=new double[n] double xmax[]=new double[n] double max_number=-1e99 double f for(int k=0 k<N k++) { for(int i=0 i<n i++) {x[i]=min[i]+(max[i]-min[i])*Math.random() } f=fi.func(x) if(f>max_number) { max_number=f for(int i=0 i<n i++) {xmax[i]=x[i] } } } return xmax } } ---------- Capture Output ---------> C \co\java\bin\java.exe Gene3test x1 = x = 8.792631687926317ix = 87926316xmin = 0.0xmax = 10.0 x2 = x = 8.852918088529181ix = 88529180xmin = 0.0xmax = 10.0 xx = 0.8077212904815896x3 = x = 8.887598688875986ix = 88875986xmin = 0.0xmax = 10.0 mutasyon sonucu x3 = x = 8.887498688874986ix = 88874986xmin = 0.0xmax = 10.0 > Terminated with exit code 0. Program 5.18-2 Monte-Carlo metodu bir boyutlu test programı import java.io. Program 5.18-3 Monte-Carlo metodu iki boyutlu test programı import java.io. * class fa extends f_xj { //çözümü istenen fonksiyon double func(double x[]) { double ff= 1.0+Math.cos(Math.PI*(x[0]-3.0))*Math.cos(2.0*Math.PI*(x[1]-2.0))/ (1+(x[0]-3.0)*(x[0]-3.0)+(x[1]-2.0)*(x[1]-2.0)) return ff //maksimum testi } } class fb extends f_xj { public double func(double x[]) { //çözümü istenen fonksiyon double ff fa fx=new fa() return -fx.func(x) //minimum testi } } class OPO19MC { public static void main(String args[]) throws IOException { fb fx=new fb() Global optimumu bulmak için standart tepe tırmanma yöntemi yeterli değildir, çünki yerel çözüme ulaşınca durur. Eğer global bir metod oluşturmak ister isek yerel en iyi çözümü bulduktan sonra arama bölgesini değiştirerek işleme devam etmek gereklidir. İterasyonlu tepe tırmanma metodunu bir algoritma olarak yazacak olursak İteratif tepe tırmanma algoritması başla t=0 while local=false vc değişkenini tesadüfi olarak seç vc için fonksiyonu hesapla while vc nin yakınlarında 30 civarında komşu nokta seç ve bu noktaları değerlendir. Buradaki önemli problemlerden birisi komşu noktalar nasıl tespit edeceğimizdir. Örneğin genetik programlamada kullandığımız Gene sınıfından yararlanabiliriz. Vc Gene sınıfında oluşturulmuşsa bir bit değerini değiştirmek komşu bir nokta elde etmemizi sağlayacaktır. Program 5.19-1 İterasyonlu tepe tırmanma – gene-genotyoe sınıfını kullanan versiyon import java.io. * import java.text. Şekil 5.19-1 Program 5.18-2 deki örnek fonksiyonun grafik çıktısı Program 5.19-2 İterasyonlu tepe tırmanma – gene sınıfını kullanan versiyon çıktı programı //iterated hillclimber //iterasyonlu en dik yamaç tırmanıcı import java.io. * import javax.swing.JOptionPane Çıktı 5.19-1 İterasyonlu tepe tırmanma – gene sınıfını kullanan versiyon çıktı programı Program 5.19-3 İterasyonlu tepe tırmanma – double sınıfını ve Gauss tesadüfi fonksiyonlarını kullanan versiyon import java.io. * import java.text. * import java.util.Locale public void toString(genotype Pi[]) { int mem int PN=Pi.length for(mem=0 mem<PN mem++) { //list them System.out.println( Vn[ +mem+ ]= +Pi[mem].toString()) } } public double[] getBest(double[] b,f_xj fi) { Program 5.19-4 İterasyonlu tepe tırmanma – double sınıfını kullanan versiyon // iterated hill climbing // import java.io. * import javax.swing.JOptionPane Çıktı 5.19-2 iterasyonlu tepe tırmanma metodu çıktısı Bir metal ergime sıcaklığının üzerine ısıtıldığında atomları yüksek enerjili gelişigüzel harekete başlar. Sıcaklık düşürüldüğünde atomların hareketleri daha az enerjili hale dönüşür ve düşük eneji seviyesine kayar. En sonunda atomlar minimum enerji seviyesindeki hal durumlarını oluşturacak kristal yapılar halinde kendilerini organize ederler. Bu proses tavlama olarak bilinir. Tavlanmış metalin enerji durumunu Bolzman dağılımı gösterir. Tavlama doğal bir optimizasyon olayı olarak kabul edilebilir ve bu olay bilgisayar programlamasında taklit edilebilir. f(x1,x2,x3,…,xn) fonksiyonunu minimize etme problemini göz önüne alalım. Bu tür bir model oluşturabilmek için T değerinin suni olarak oluşturulan bir sıcaklık faktörü olduğunu düşünelim. T'nin büyük bir değerinden optimizasyona başlıyabiliriz(tavlamanın başında metalin sıcaklığı yüksektir). Başlangıç için x0=(x1,x2,x3,…,xn)0 vektörünü alalım. Eğer x vektöründe x tesadüfi hareketini yapar isek, bu x x noktası etrafında gauss değişimi ile dağılan bir tasadüfi dağılımla dağıldığını kabul edebiliriz (x0 vek törüne komşu bir x1 vektörünü bununla x1=x0+x yeni vektörünü elde etmiş< oluyoruz. f=f(x1)-f(x0)). Gauss dağılımı p(x j )   , 1  j  n  Eğer f>=0 ise bu otomatik olarak red edilmesi anlamına gelmez. Yine de kabul edilebilmesi mümkündür. Bunun için Boltzman dağılımına bakarız. p(f )  1   f  exp  kT  kT  Eğer p(f) > z ise x1 değeri yeni değer olarak kabul edilir. Değil ise reddedilir, ve yeni bir doğrultu oluşturmak için yeni bir x hesaplanır. Zaman içinde T sıcaklık fonksiyonu azaltılır. İterasyonun başlangıcında T değeri büyük olduğundan f>=0 ın kabul olasılığı büyüktür. T küçüldükçe arama f>=0 durumlarının kabulünde daha tutucu hale gelir. Bu prosesi bir algoritma halinde yazarsak Tavlama simulasyonu (simulated annealing) algoritması başla t=0 T sıcaklığının değerini oluştur. vc değişkenini tesadüfi olarak seç vc için fonksiyonu hesapla while while vc noktası komşu bölgesinde vn yeni vektörünü seç if f(vc) < f(vn) then vc = vn (yeni noktayı kabul et) else if tesadüfi sayı(0-1) < exp[(f(vn)-f(vc))/T] then vc = vn (yeni noktayı f(vc) >= f(vn) olamasına rağmen kabul et) until (çıkış şartı) t=t+1 until (bitirme şartı) bitir T fonksiyonunun değerlendirilmesi çeşitli şekillerde olabilir. Birkaç örnek verecek olursak T0 T 1  log(1  t ) T T  T log(t 0 ) t log(t ) T0 1 t program olarak iki versiyon geliştirilmiştir. Birinci versiyonda yeni seçilen noktanın bir önceki noktanın komşu bölgesinde olmasını sağlamak için genetik algoritmada kullandığımız genotype1 sınıfından yararlandık (bit yapısında 1 biti tesadüfi olarak değiştirdik) Program 5.20-1 Tavlama simulasyonu (simulated annealing) metodu (genotype1 mettodu ile) İmport java.io. * import java.text. * import java.util.Locale //calculate cumulative fitness Pi[0].setCFitness(Pi[0].getRFitness()) for(mem=1 mem<PN mem++) {Pi[mem].setCFitness(Pi[mem-1].getCFitness()+Pi[mem].getRFitness()) } } public void toString(genotype1 Pi[]) { int mem int PN=Pi.length for(mem=0 mem<PN mem++) { //list them System.out.println( Vn[ +mem+ ]= +Pi[mem].toString()) } } } while(k<MAX) return getBest(best) } } Program 5.20-2 Tavlama simulasyonu çıktı programı metodu (genotype1 mettodu ile) // simulated annealing // import java.io. * import javax.swing.JOptionPane Çıktı 5.20-1 Tavlama simulasyonu çıktı programı metodu (genotype1 mettodu ile) İkinci program versiyonumuzda ise double sayıları gauss tesadüfi sayılarını kullanarak komşu bölgeleri oluşturduk. Program 5.20-3 Tavlama simulasyonu(Simulated annealing) programı metodu (double vektör ile) import java.io. * import java.text. * import java.util.Locale public void toString(genotype Pi[]) Program 5.20-4 Tavlama simulasyonu(Simulated annealing) çıktı metodu (double vektör ile) // simulated annealing // import java.io. * import javax.swing.JOptionPane { //çözümü istenen fonksiyon // newton metodu minimumaçalışıyor bu yüzden //- işaretitanımladık. Çıktı 5.20-3 Tavlama simulasyonu(Simulated annealing) programı metodu (double vektör ile) Sınırlamalı optimizasyon problemi genel olarak Minimum f(x) Sınır şartları p(x)=0 q(x)  0 olarak tanımlanabilir. Genelde bu tür sınır şartlarını denkleme ekliyerek yeni bir denklem oluştururuz. Birinci denklem p(x)=0 r İçin P( x)  P( x0 , x1 ,..)   pk2 ( x) olarak tanımlansın İkinci denklem q(x)  0 için k 0 r Q( x)  Q( x0 , x1 ,..)   min 2 {0, qk ( x)} k 0 burada min fonksiyonu 0 ile qk(x) in minimum olanını seçer. Minimumunu bulmamız gereken fonksiyon F ( x)  f ( x)  [ P( x)  Q( x)] şeklini alır. Denklemdeki  ceza katsayısı ismini alır. İkinci denklem q(x)  0 için Q(x) denklemimizi r Q( x)  Q( x0 , x1 ,..)   min 2 {0, [qk ( x)   ]} şeklinde değiştirerek de kullanabiliriz. Burada >0 çok k 0 küçük bir sayıdır. Bu küçük değişiklikle optimal değerin tam sınıra gelmesi durumunda orijinal fonksiyonun çözümü reddetmesini engelleyici bir etki yaratmış oluruz. Örnek problemde Fletcher-Reeves metodu kullanılmıştır, doğal olarak sınırlandırılmış optimizasyon hesaplarında gördüğümüz tüm optimizasyon metodlarından yararlanabiliriz. Program 5.21-1 Fletcher-Reeves optimizasyon metodu kullanılarak Sınırlandırılmış optimizasyon İmport java.util. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. public static double norm(double v[]) { // vector norm double total=0 for(int i=0 i<v.length i++) {total+=v[i]*v[i] } return Math.sqrt(total) } public static double turev(f_xj f,double x[],int denklem_ref,int x_ref) { // // verilen fonksiyonun ikinci türevlerinin matrisi // fonksiyon f in denklem_ref sayılı fonksiyonunun(sayılar 0 dan başlar) // x[x_ref] değişkenine göre türevi (sayılar 0 dan başlar) // df_denklem_ref(x)/d_x_ref // bu metod newtond metodu içinde kullanılmak içindir. //Gredyen vektörü // f(x0,x1,x2,...xn) founksiyonunun türev vektörü // [df/dx0, df/dx1,df/dx2,....,df/dxn] // df/dxj j=0...x.length // // bu fonksiyon bilgisayar tarafından hesaplanmaktadır // kullanıcı tarafından tanımlanan f(x) fonksiyonunun // sayısal olarak alınan türevidir. Math.abs(a) -Math.abs(a)) } public static double MAX(double a,double b) {return (a > b . a b) } ax cx) b=((ax > cx) . a-x b-x)) } u=(Math.abs(d) >= tol1 . Çıktı 5.21-1 f(x)=(x0-1)2+(x2-2)2+(x3-3)2 fonksiyonunun sınır şartı olmadan optimizasyonu, y=1.232595164407831E-32 Çıktı 5.21-2 f(x)=(x0-1)2+(x2-2)2+(x3-3)2 fonksiyonunun p(x)=x1+x2-2=0 sınır şartıyla optimizasyonu, y=0.4975124378109452 Çıktı 5.21-3 f(x)=(x0-1)2+(x2-2)2+(x3-3)2 fonksiyonunun q(x)=x2-x3-3  0 sınır şartıyla optimizasyonu, y=7.960202985538945 Çıktı 5.21-4 f(x)=(x0-1)2+(x2-2)2+(x3-3)2 fonksiyonunun p(x)=x1+x2-2=0 ve q(x)=x2-x3-3  0 sınır şartıyla optimizasyonu, y=13.87126018223184 Şimdi de aynı problemi genetik algoritmalara uyarlanmış bir versiyon olarak verelim. Program 5.21-2 Genetik algoritma kullanarak optimizasyon metodu kullanılarak Sınırlandırılmış optimizasyon import java.io. * class fa extends f_xj { public double func(double x[]) { //çözümü istenen fonksiyon double ff double mu1=0.0 double mu2=0.0 ff=(x[0]-1.0)*(x[0]-1.0)+(x[1]-2.0)*(x[1]-2.0)+(x[2]-3.0)*(x[2]-3.0)+mu1*P(x)+mu2*Q(x) return 400-ff } public double P(double x[]) {// p(x)=0 sınırlama durumu int n=x.length return (x[0]+x[1]-2.0)*(x[0]+x[1]-2.0) Çıktı 5.21-5 f(x)=(x0-1)2+(x2-2)2+(x3-3)2 fonksiyonunun sınır şartı olmadan genetik algoritmalar kullanılarak optimizasyonu, ---------- Capture Output ---------> C \co\java\bin\java.exe OPO17H best= 0.996059402692424 1.992156952503023 3.007862121056064 399.999861145351300 > Terminated with exit code 0. Çıktı 5.21-6 f(x)=(x0-1)2+(x2-2)2+(x3-3)2 fonksiyonunun p(x)=x1+x2-2=0 sınır şartıyla genetik algoritmalar kullanılarak optimizasyonu, ---------- Capture Output ---------> C \co\java\bin\java.exe OPO17H best= 0.513650946239266 1.491437879325406 3.125011920974430 399.486611572372500 > Terminated with exit code 0. Çıktı 5.21-7 f(x)=(x0-1)2+(x2-2)2+(x3-3)2 fonksiyonunun q(x)=x2-x3-3  0 sınır şartıyla genetik algoritmalar kullanılarak optimizasyonu, ---------- Capture Output ---------> C \co\java\bin\java.exe OPO17H best= 1.000064850100899 3.908706316781298 0.927699766921108 392.026333022443450 > Terminated with exit code 0. Çıktı 5.21-8 f(x)=(x0-1)2+(x2-2)2+(x3-3)2 fonksiyonunun p(x)=x1+x2-2=0 ve q(x)=x2-x3-3  0 sınır şartıyla genetik algoritmalar kullanılarak optimizasyonu ---------- Capture Output ---------> C \co\java\bin\java.exe OPO17H best= 0.000610353890815 2.501230244561174 0.000801089481695 339.613193023138360 > Terminated with exit code 0. Herşeyden önce günümüzde oldukça yoğun kullanılan bir problem olması ilginçliğini arttırır. Problem göreceli olarak basittir. Bir satıcı n şehre uğrayarak mallarını satacaktır. Şehirlerin koordinatları bellidir. Satıcı en kısa yolu giderek bu turu nasıl yapailir. Problemi iki temel alt versiyona ayırabiliriz. Birinci versiyonda başlangıç ve bitiş noktaları belirlenmiş olabilir. Örneğin 2 şehir arasında bir telefon (veya internet) bağlantısı kurulacaksa bu versiyon geçerlidir. İkinci versiyonda başlangıç ve bitiş noktaları verilen listeden en kısa yolu oluşturacak şekilde seçilebilir. Formülle tanım yapmak istersek n  Mesafe   ( xi  xi 1 ) 2  ( yi  yi 1 ) 2  burada xi ve yi i'nci şehrin koordinatlarıdır. Aynı formülü sabit i 1 başlangıç vebitiş koordinatları için yazarsak  Mesafe  ( x0  xb ) 2  ( y0  yb ) 2 ( x bitiş   n    ( xi  xi 1 ) 2  ( yi  yi 1 ) 2   i 1 Olur. Buradaki (xb, yb) seyahatin başlama koordinatları, (xbitiş, ybitiş) seyahatin bitiş noktalarıdır. Gezgin satıcı (Travelling Salesman Problem- kısaca TSP) probleminin normal versiyonunda aynı şehrin sadece bir kere ziyaret edilmesi zorunluğu vardır, ancak bazı gerçek problemlerde bu zorunluk mevcut değildir. Bu problemin çözümünde her şehir için geri kalan şehirlerin uzaklıklarını hesap ederek en yakı olanını seçmek kullanılabilecek bir yaklaşım gibi görülsede şehir sayısı 20 lerin üzerine çıktığında olasılıklar çok büyüdüğünden kullanılabilir bi metod oluşturmaz. Şimdi değişik Gezgin satıcı problem çözümlerine göz atalım. İlk önce Genetik algoritmalara göz atacağız. Ancak bu problem için kendine özgü şartlar altında geliştirilmelidir. Burada vereceğimiz örneklerde temel geni geliştirmek için javadaki ArrayList yapısını kullanarak verilen şehirlerin sıralanma sırasını oluşturur. Bunun için önce seyehat edilecek şehirlerin koordiatları liste olarak verilir. 30.901699437494738 58.778525229247315 80.90169943749474 95.10565162951535 100.0 95.10565162951536 80.90169943749474 Sonraki koordinatlar ziyaret edilebilecek şehirlerin koordinatlarıdır. Dosyada ikinci sıradan sonraki şehir koordinatları aynı zamanda sıralamayı vermektedir. Örneğin dosyadaki üçüncü sıradaki şehrin numarası 0 dördüncü satırdaki şehrin numarası 1, beşinci satırdaki şehrin numarası 2 dir. Listenin programdaki düzenleme şekli aynı şehrin 2 kere tekrarlamasını engellemektedir. Programımız satici_gen ve satici_genetik olarak 2 sınıftan oluşmaktadır. 1. Sınıf yukarda verdiğimiz en yapısını tanımlar, bu genin çoğalması( anne ve baba bireylerden çocuk bireyinin gen yapısını-ArayList dizgisini oluşturmak) ve mutasyon oluştuğunda oluşacak yapıları oluşturma görevini üstlenmiştir. Her bireyin sadece 1 geni vardır. İkinci programımız satici_genetik verilen nüfus için yeni bireyleri oluşturmaka, gerekirse olasılıklara göre mutasyona izin vermekte ve istenilen kadar yeni nesil üretmektedir. Her nesilde en iyi çözüm yeni nesle değişmeksizin aktarılmaktadır. Seyahati daha iyi izleyebilmek için satici_gen programına plot() metodu da eklenmiştir. GA nın istatiksel karekteristiğinden dolayı sonucun en iyi sonucayaklaşacağını umabiliriz, ancak her zaman en iyi sonucu yakalayamıyacağımızı hatta her zaman aynı sonucu yakalayamıyacağımızı hatırlatmakta yarar görüyoruz. Altaki ilk listede satici_gen.java programı, İkinci listede satici_genetik.java programı verilmiştir. import java.util. * import java.awt. * import javax.swing. * import java.awt.event. * //çıkış ve varış noktaları belirlenmiş tur public class satici_gen { public int n public double xcikilan,ycikilan public double xvarilan,yvarilan public double x[],y[] public double Fitness // uyum değeri public double RFitness // relatif uyum public double CFitness // kümülatif uyum public boolean Breeder ArrayList<String> v String dizi public satici_gen(double xi[],double yi[]) {n=xi.length-2 v=new ArrayList<String>(n) x=new double[n] y=new double[n] xcikilan=xi[0] ycikilan=yi[0] xvarilan=xi[1] yvarilan=yi[1] Breeder=false for(int i=0 i<n i++) {x[i]=xi[i+2] y[i]=yi[i+2] v.add( +i) } Collections.shuffle(v) //swap() mesafe() } public void mutate() { int n1=(int)(n*Math.random()) int n2=(int)(n*Math.random()) //System.out.println( n= +n+ n1= +n1+ n2= +n2) if(n1.=n2) Collections.swap(v, n1, n2) } } public ArrayList<String> bilesim(ArrayList<String>list1, int a) { ArrayList<String> bilesimVectoru = new ArrayList<String>() String s1,s2 Iterator n1=list1.iterator() String b=new String( +a) while(n1.hasNext()) { s1=(String)n1.next() bilesimVectoru.add(s1) } s2=(String)b if(.bilesimVectoru.contains(s2)) bilesimVectoru.add(s2) return bilesimVectoru } public ArrayList<String> bilesim(ArrayList<String> list1, ArrayList<String> list2) { ArrayList<String> bilesimVectoru = new ArrayList<String>() String s1,s2 Iterator n1=list1.iterator() Iterator n2=list2.iterator() while(n1.hasNext()) { s1=(String)n1.next() bilesimVectoru.add(s1) } while(n2.hasNext()) { s2=(String)n2.next() if(.bilesimVectoru.contains(s2)) bilesimVectoru.add(s2) } return bilesimVectoru } public ArrayList<String> altküme(ArrayList<String> list1, int nn) { ArrayList<String> bilesimVectoru = new ArrayList<String>() String s1,s2 Iterator n1=list1.iterator() for(int i=0 i<nn i++) { s1=(String)n1.next() bilesimVectoru.add(s1) } return bilesimVectoru } public ArrayList<String> kalanküme(ArrayList<String> list1, int nn) { ArrayList<String> bilesimVectoru = new ArrayList<String>() String s1,s2 Iterator n1=list1.iterator() for(int i=0 i<nn i++) { s1=(String)n1.next() } while(n1.hasNext()) { s1=(String)n1.next() bilesimVectoru.add(s1) } return bilesimVectoru } public ArrayList<String> s_cocuk(ArrayList<String> anne, ArrayList<String> baba) {int nn=(int)(n*Math.random())+1 //System.out.println( nn= +nn) ArrayList<String> anne1=altküme(anne,nn) ArrayList<String> anne2=kalanküme(anne,nn) ArrayList<String> baba1=altküme(baba,nn) ArrayList<String> baba2=kalanküme(baba,nn) ArrayList<String> cocuk=bilesim(anne1,baba1) ArrayList<String> cocuk1=bilesim(cocuk,anne2) ArrayList<String> cocuk2=bilesim(cocuk1,baba2) return cocuk2 } public String ciktiS() { Iterator enm = v.iterator() String s= ( +xcikilan+ , +ycikilan+ )\n String s1= int a=0 while(enm.hasNext()) { s1=(String)enm.next() a=Integer.parseInt(s1) s+=s1+ ( +x[a]+ , +y[a]+ ) \n } s+= ( +xvarilan+ , +yvarilan+ ) \n return s } public String[] ciktiSA() { Iterator enm = v.iterator() String s[]=new String[n] int i=0 while(enm.hasNext()) { s[i]= (String)enm.next()+ i++ } return s } public String toString() { String s=ciktiS()+ mesafe = +mesafe() return s } } Başlangıç ve bitiş noktaları sabitlenmiştir. import java.io. * import java.text. İlk sonucumuz tam doğru bir sonuç vermektedir, çünkü test verimiz bir dairenin etrafındaki aynı şehirde başlayan vebiten bir turu gösteriyordu. Şekil 5.22.1-1 Gezgin satıcı problemi GA satici_genetik çözüm 1 grafik çıktı sabit başlangıç ve bitiş şehirleri verilmiş. Şekil 5.22.1-3 Gezgin satıcı problemi GA satici_genetik çözüm 2 grafik çıktı sabit başlangıç ve bitiş şehirleri Eğer gezgin satıcı probleminde başlangıç ve bitiş noktaları sabitlenmemişse, yani tura herhangi bir şehirden başlanabiliyorsa ve tur herhangi bir şehirde bitebiliyorsa programlama kodu bir üsttekine benzer ancak biraz değişiktir. İlk ve son şehir koordinatları hem okunan listeden hem de program kodundan kaldırılarak hesaplamalar gerçekleştirilir. Program kodları satici_gen1 ve satici_genetik1 altta verilmiştir. Başlangıç ve bitiş noktaları sabitlenmemiştir. import java.util. * import java.awt. * import javax.swing. * import java.awt.event. * //çıkış ve varış noktaları belirlenmemiş tur public class satici_gen1 { public int n public double x[],y[] public double Fitness // uyum değeri public double RFitness // relatif uyum public double CFitness // kümülatif uyum public boolean Breeder ArrayList<String> v String dizi public satici_gen1(double xi[],double yi[]) {n=xi.length v=new ArrayList<String>(n) x=new double[n] y=new double[n] Breeder=false for(int i=0 i<n i++) {x[i]=xi[i] y[i]=yi[i] v.add( +i) } Collections.shuffle(v) mesafe() } public void mutate() { int n1=(int)(n*Math.random()) int n2=(n1+1)%n //int n2=(int)(n*Math.random()) Collections.swap(v, n1, n2) } {double a[][]=Text.readDouble(dosya) n=a[0].length v=new ArrayList<String>(n) x=new double[n] y=new double[n] for(int i=0 i<n i++) {x[i]=a[0][i] y[i]=a[1][i] v.add( +i) } Collections.shuffle(v) mesafe() } public satici_gen1(satici_gen1 anne, satici_gen1 baba) { n=anne.n x=new double[n] y=new double[n] for(int i=0 i<n i++) {x[i]=anne.x[i] y[i]=anne.y[i] } ArrayList<String> cocuk=s_cocuk(anne.v,baba.v) v=kopye(cocuk) mesafe() } public satici_gen1(ArrayList<String> anne,double xi[],double yi[]) { v=kopye(anne) Collection torba=v n=xi.length x=new double[n] y=new double[n] for(int i=0 i<n i++) {x[i]=xi[i] y[i]=yi[i] } mesafe() } public void plot() { double xi[]=new double[n] double yi[]=new double[n] int a=0 int b=0 String s1= String s2= Iterator i=v.iterator() int j=0 double mesafe=0 dizi= 0 s1=(String)i.next() a=Integer.parseInt(s1) xi[j]=x[a] yi[j]=y[a] j++ while(i.hasNext()) { s2=(String)i.next() b=Integer.parseInt(s2) mesafe+=Math.sqrt((x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b])) xi[j]=x[b] yi[j]=y[b] j++ a=b } Plot pp=new Plot(xi,yi) double wx[]=new double[2] double wy[]=new double[2] wx[0]=xi[0] wy[0]=yi[0] wx[1]=xi[n-1] wy[1]=yi[n-1] pp.addData(wx,wy) pp.addData(xi,yi) pp.setPlotType(1,32) pp.setPlotType(2,22) pp.setPlabel( Genetik satıcı problemi mesafe = +mesafe) pp.setXlabel( x, km ) pp.setYlabel( y, km ) pp.plot() } } public ArrayList<String> bilesim(ArrayList<String>list1, int a) { ArrayList<String> bilesimVectoru = new ArrayList<String>() String s1,s2 Iterator n1=list1.iterator() String b=new String( +a) while(n1.hasNext()) { s1=(String)n1.next() bilesimVectoru.add(s1) } s2=(String)b if(.bilesimVectoru.contains(s2)) bilesimVectoru.add(s2) return bilesimVectoru } public ArrayList<String> bilesim(ArrayList<String> list1, ArrayList<String> list2) { ArrayList<String> bilesimVectoru = new ArrayList<String>() String s1,s2 Iterator n1=list1.iterator() Iterator n2=list2.iterator() while(n1.hasNext()) { s1=(String)n1.next() bilesimVectoru.add(s1) } while(n2.hasNext()) { s2=(String)n2.next() if(.bilesimVectoru.contains(s2)) bilesimVectoru.add(s2) } return bilesimVectoru } public ArrayList<String> altküme(ArrayList<String> list1, int nn) { ArrayList<String> bilesimVectoru = new ArrayList<String>() String s1,s2 Iterator n1=list1.iterator() for(int i=0 i<nn i++) { s1=(String)n1.next() bilesimVectoru.add(s1) } return bilesimVectoru } public ArrayList<String> kalanküme(ArrayList<String> list1, int nn) { ArrayList<String> bilesimVectoru = new ArrayList<String>() String s1,s2 Iterator n1=list1.iterator() for(int i=0 i<nn i++) { s1=(String)n1.next() } while(n1.hasNext()) { s1=(String)n1.next() bilesimVectoru.add(s1) } return bilesimVectoru } public ArrayList<String> s_cocuk(ArrayList<String> anne, ArrayList<String> baba) {int nn=(int)(n*Math.random())+1 //System.out.println( nn= +nn) ArrayList<String> anne1=altküme(anne,nn) ArrayList<String> anne2=kalanküme(anne,nn) ArrayList<String> baba1=altküme(baba,nn) ArrayList<String> baba2=kalanküme(baba,nn) ArrayList<String> cocuk=bilesim(anne1,baba1) ArrayList<String> cocuk1=bilesim(cocuk,anne2) ArrayList<String> cocuk2=bilesim(cocuk1,baba2) return cocuk2 } public String ciktiS() { Iterator enm = v.iterator() String s= int a=0 String s1= while(enm.hasNext()) { s1=(String)enm.next() a=Integer.parseInt(s1) s+=s1+ ( +x[a]+ , +y[a]+ ) \n } return s } public String[] ciktiSA() { Iterator enm = v.iterator() String s[]=new String[n] int i=0 while(enm.hasNext()) { s[i]= (String)enm.next()+ i++ } return s } public String toString() { String s=ciktiS()+ mesafe = +mesafe() return s } } Başlangıç ve bitiş noktaları sabitlenmemiştir. import java.io. * import java.text. Ancak Gezgin satıcı problemi için çok iyi bir alternatif oluşturmaz. Burada bu yöntem özellikle geçerli çözüme ulaşamadığımız göstermek amacıyla verilmiştir. Temel olarak genetik algoritmada kullandığımız satici_gen sınıfından yararlanılmıştır. Programımızda 100 milyon tesadüfi yol oluşturulmuş ve bu yollardan en kısası seçilmiştir. Başlangıç ve bitiş noktaları sabitlenmiştir. import java.io. * import java.text. Başlangıç ve bitiş noktaları sabitlenmiştir. i=75000000 i=76000000 i=77000000 i=78000000 i=79000000 i=80000000 i=81000000 i=82000000 i=83000000 i=84000000 i=85000000 i=86000000 i=87000000 i=88000000 i=89000000 i=90000000 i=91000000 i=92000000 i=93000000 i=94000000 i=95000000 i=96000000 i=97000000 i=98000000 i=99000000 Çıktı 9-2.2 satici_montecarlo.java programı gezgin satıcı montecarlo algoritması Final çözüm grafik formatı. Başlangıç ve bitiş noktaları sabitlenmiştir. Grafik 5.22.3 Satıcı problemi olarak bilinen n nokta arasındaki en kısa yolu (tüm n noktaya uğramak şartı ile) bulma problemi günlük hayatta sıkça karşımıza çıkabilir. Günümüzdeki en yaygın kullanım alanları, telefon internet gibi elektronik bağlantıları en kısa yol üzerinden yapma eylemidir. Burada bu problemin özel bir çözümü üzerinde duracağız. Karınca simulasyonu. Karınca simulasyon yöntemi, yakın zamanda geliştirilmiş olan ( 90 ların sonları ) bir tür stokastik (tesadüfi sayı sistemleri kullanan) kombinasyonal optimizasyon yöntemidir. Temel özellikleri pozitif geribesleme ( positive feedback ), dağıtılmış hesaplama (distributed computing), ve üretken açgözlü sezgiselliğin (constructive greedy heuristic) kullanımıdır. Pozitif geribesleme, uygun sonuçların çabuk bulunmasında dağıtılmış hesaplama, erken (kusurlu) yakınsamanın engellenmesinde açgözlü sezgisellik ise, arama işleminin ilk kademelerinde kabul edilebilir sonuçlar bulunmasında etkilidir. Bu simulasyonun temeli gerçek dünyadan, karıncaların yiyeceğe giden yolu bulma prensibinden ortaya çıkmıştır. Karıncalar yuvalarından yiyecek buldukları yere giderken feremon denen koku salan bir kimyasal madde yayarlar. Diğer karıncalar bu kokuyu algılayabilir. Kokunun varlığı ve şiddeti, diğer karıncaların yol tercihinde etkili olur. Ancak kimyasal madde zamanla uçtuğundan koku zaman içinde yok olur. Bu şekilde karıncaların takipettiği bir kokuizi oluşur. Bu şekilde yenigelen karıncalar yiyecek kaynağına daha kolaylıkla bu koku yolunu izleyerek ulaşabilirler. Her geçen karınca da yeni feromen bırakacağından çok kullanılan yolun kokuyoğunluğu artarken kullanılmayan yollarda olan feromen de uçacağından koku yok olur. Eğer bir yol daha kısa ise o yol üzerinde biriken feromen miktarı da karıncalar yuvaya daha hızlı dönebildikleri de hesaba katılırsa daha yoğun olacaktır. Şekil 5.22-1 Karıncaların bir engel karşısındaki davranışı (yol seçimi) Şimdi bu prensibi bilgisayar algoritmasına nasıl çevirebileceğimizi irdeleyelim Karıncaların 1 ve 2 gibi iki değişik yoldan yiyecek kaynağına ulaştıklarını varsayalım. Bu durumda t zamanında (m+1) inci karıncanın birinci yolu seçme olasılıği olarak yazılabilir. Buradaki m1ve m2 birinci yolu kullanan ve ikinci yolu kullanan karınca sayısıdır.k ve h sabitlerdir. (m+1) inci karıncanın ikinci yolu seçme olasılığı da P2(m+1)= 1 – P1(m+1 Şeklinde yazılabilir. Bilgisayar simulasyonunda kullanılan ajan karıncalar, gerçek hayattaki karıncalara göre belirli farklılıklar gösterirler. Bunlar 1. 2. 3. Ajan karıncaların hafızası vardır. Örneğin gezgin satıcı probleminde daha önce gittikleri yerleri bir Tabu listesinde saklarlar, hatırlarlar. Tamamiyle kör değillerdir. Örneğin seçtikleri yolu, uzunluğuna göre de irdelerler. Zamanın ayrık olduğu bir çevrede yaşarlar. Şekil 5.22-2 Karıncaların iki yol problemlerindeki yol seçiminin zaman içindeki dağılımı Şekil 5.20-2'de ajan karıncaların nasıl bir davranış içinde oldukları izlenebilir     t = 0 anında E'den A'ya doğru, A'dan da E'ye doğru 30'ar karınca yola çıkmaktadır. Henüz yollarda feramon birikmesi olmadığı için, karıncalar eşit olasılıkta B ve D şehirlerinden H ve C şehirlerine doğru yönleceklerdir. Bu durumda 15'er li iki grup oluşacaktır. B – C – D yolu daha kısa olduğu için, burada daha fazla feramon birikecektir. t = 1 anında B – C – D yolunda daha fazla feramon biriktiği için, karıncalar ağırlıklı olarak bu güzergahı tercih edecektir. Karınca Kolonilerinin Gezgin Satıcı Programine Uygulaması Bilindiği üzere gezgin satıcı problemi, verilen n tane şehirden oluşan kümedeki her şehire bir kez uğrayarak oluşturulan en kısa yolun bulunmasını kapsar. Tanımlar Şehirlerin bulunduğu uzayı, Öklid uzayı olarak kabul edersek Şehir sayısı i ile j numaraları birbirine birleştiren Öklid mesafesi t anındaki, i şehirdeki karınca sayısı Toplam karınca sayısı n n dij bi(t) m m   bi t  i 1  ij t   t anında ij yolundaki izin yoğunluğu  ijk ij yolunda, k'ıncı karınca tarafından bırakılmış izin, yol uzunluğuna oranı  ijk =  ijk = 0 Buharlaşma oranı sonsuz feramon birikmesini ve yerel minimalara takılmayı engellemek için1 den küçük olmalıdır. Q Eğer k ıncı karınca bu yolu kullandıysa Lk Eğer k ıncı karınca bu yolu kullanmadıysa  ij  pijk t  k ıncı karıncanın gittiği şehirlerin listesi Görünürlük 1 d ij i inci şehirden j inci şehire geçiş olasılığı Eğer j şehri tabu listesinde yoksa p t   k ij  t      ij  ij     t     ik ik eden değişkenlerdir Eğer j şehri tabu listesinde var ise pijk t   0 Algoritma 1. 3. 4. pijk t  olasılığına bağlı olarak seç ii. k ıncı karıncayı j inci şehre götür iii. Q Lk Eğer k ıncı karınca bu yolu kullandıysa  ijk = Eğer k ıncı karınca bu yolu kullanmadıysa  ijk = 0  ij   ij   ijk 5. a.  ij t  n  değerini hesapla  ij t  n   ij t    ij t=t+n NC = NC + 1 Her ij yolu için a. b. Eğer NC < NCmaks bütün tabu listelerini temizle ve 2. maddeye git Değilse en kısa mesafeyi yaz ve dur. (tıkanma davranışı / stagnation behaviour) Her ij yolu için  ij  0 6. Literatürde farklı karınca kolonileri algoritmaları mevcuttur. Bazıları sadece feramon bırakılış şekline alternatif getirirken bazıları koloni şeklini değiştirmektedir. Bunlardan bazıları 1. Karınca Döngüsü ( Ant Cycle ) Bu bir önceki sayfada açıklanmış algoritmadır. 2. Karınca Yoğunluğu ( Ant density ) Bu metodaki farklılık feramonlar güncellenirken, karıncanın toplam katettiği yola bakılmaz. 3. Eğer k ıncı karınca bu yolu kullandıysa  ijk = Eğer k ıncı karınca bu yolu kullanmadıysa  ijk = 0 Q Karınca Sayı ( Ant Quantity ) Bu metodda ise feramonlar güncellenirken, karıncanın toplam katettiği yol yerine, ij şehirleri arasındaki mesafe kullanılır. Q d ij Eğer k ıncı karınca bu yolu kullandıysa  ijk = Eğer k ıncı karınca bu yolu kullanmadıysa  ijk = 0 Bu iki yöntem arasındaki fark, birinde karıncanın bıraktığı feramon miktarındaki artış, şehirler arasındaki mesafeyle ters orantılı iken diğerinde mesafeden bağımsızdır. 4. Ardışık Karınca Kolonisi ( Sequential Ant Colony Optimization ) Bu metodda sadece tek karınca bütün düğümleri, bir olasılıksal geçiş kuralına göre gezer[2]. 5. Elitist Karınca Kolonisi (Elitist Strategy ) Bu yöntem genetik algoritmalarındaki, elitist stratejiye benzer. En iyi yola, o yola doğru gidişi arttırmak açısından e*Q/L miktarında feramon eklenir. Burada e, en iyi karınca sayısı L ise en kısa tur mesafesidir. Satıcı problemi için karınca optimizasyonu Program 5.29-1 de verilmiştir. Örnek test veri girdisi olarak bir çemberin üzerine dizilmiş noktalar aldık. Girdi xi,yi koordinat verileri dosya sehirler.txt de verilmiştir. Sonuçta şehirlerin girdi vektörü sırasına göre sıralaması verilmektedir. Program 9-3.1 Satıcı problemi çözüm yöntemi olarak karınca optimizasyonu import java.io. * import java.math. * class harita { double[][] sehirler public double mesafe(double x1,double x2,double y1,double y2) { double mesafe mesafe=Math.pow((Math.pow((x2-x1),2)+Math.pow((y2-y1),2)),0.5) return mesafe } public harita(sehiroku x) { sehirler=new double[x.sehirsayisi][x.sehirsayisi+3] for(int i=0 i<x.sehirsayisi i++) { sehirler[i][0]=i //.ehrin ID si sehirler[i][1]=x.sehirler[i][0] //.ehrin x koordinat. sehirler[i][2]=x.sehirler[i][1] //.ehrin y koordinat. temp[0]=x[k][0] x[k][2]=x[j][2] x[k][1]=x[j][1] x[k][0]=x[j][0] x[j][2]=temp[2] x[j][1]=temp[1] x[j][0]=temp[0] k++ j-- } }while(k<=j) if(y<j) { quicksort(x,y,j) } if(k<z) {quicksort(x,k,z) } } public double readMesafe() {return minmesafe } public int[] ant_optimization(String dosya,double vaporizarion,double feramoni,int nkarinca ) { double tolerans=1.0e-5 double dx=0.1 //vaporization 0-1 double buharlasmaorani=vaporizarion //feramonun buharlasma oranı //feramoni=5 (örneğin) double feramon=feramoni //feramon double beta=3 // double alfa=1 // double baslangicferamonu=1 //t=0 anindaki yoldaki feramon miktar. //int sakkarinca=10 //iterasyon aras. korunacak maksimum kar.nca say.s. //int sakis //saklanacak karınca işareti sehiroku sehir=new sehiroku(dosya) //şehirlerin okunması harita bolge=new harita(sehir) //haritanın hazırlanması double[][] feramondurumu=new double[sehir.sehirsayisi][sehir.sehirsayisi] //yolların feramon durumunun kaydedileceği double[][] deltaferamon=new double[sehir.sehirsayisi][sehir.sehirsayisi] //int karincasayisi=1000 //koloni büyüklüğü int karincasayisi=nkarinca int it=0 int maxit=10 //maksimum iterasyon sayisi int ilksehir int yolsayisi double toplamolasilik=0 double[][] olasiliklar=new double[sehir.sehirsayisi][sehir.sehirsayisi] double minolasilik=0 double maxolasilik=0 double tolasilik=0 double mesafe minmesafe=0 double minmesafeeski=0.1 dx=Math.abs(minmesafe-minmesafeeski) int minid=0 int[] minguzergah=new int[sehir.sehirsayisi] karincaorj[] karincaordusu=new karincaorj[karincasayisi] //karincaorj[] sakkar=new karincaorj[sakkarinca] yolsayisi=0 //yolsayisinin hesaplanması while (it<maxit && dx>tolerans){ minmesafeeski=minmesafe yolsayisi=0 for(int i=1 i<sehir.sehirsayisi-1 i++){ yolsayisi=yolsayisi+sehir.sehirsayisi-i } yolsayisi=yolsayisi+1 //System.out.println(yolsayisi) double[][] olasilikpasta=new double[yolsayisi][3] //t=0 anındaki feramonun yollara konulması if(it==0){ for(int i=0 i<(sehir.sehirsayisi-1) i++) { for(int j=i+1 j<(sehir.sehirsayisi) j++) { if(i==j){ feramondurumu[i][j]=0 }else{ feramondurumu[i][j]=baslangicferamonu for(int i=1 i<sehir.sehirsayisi i++){ for(int j=0 j<karincasayisi j++){ karincaordusu[j].yuru(bolge,olasilikpasta,i,yolsayisi) } } minmesafe=karincaordusu[0].kmesafe minguzergah=karincaordusu[0].gyol for(int j=0 j<karincasayisi j++){ if(karincaordusu[j].kmesafe<minmesafe){ minmesafe=karincaordusu[j].kmesafe minguzergah=karincaordusu[j].gyol } } for(int j=0 j<karincasayisi j++){ karincaordusu[j].ferguncel(deltaferamon) } for(int i=0 i<(sehir.sehirsayisi-1) i++) { for(int j=i+1 j<(sehir.sehirsayisi) j++) { if(i==j){ feramondurumu[i][j]=0 }else{ feramondurumu[i][j]=feramondurumu[i][j]*buharlasmaorani+deltaferamon[i][j] } } } it++ dx=Math.abs(minmesafe-minmesafeeski) } return minguzergah } } Program 9-3.2 Satıcı problemi çözüm yöntemi olarak karınca optimizasyonu, test programı public class anttest { public static void main(String args[]) { double buharlasmaorani=0.90 //feramonun buharlasma oran. double feramon=5 //feramon int toplamkarinca=1000 ant x=new ant() int[] tur=x.ant_optimization( sehirler.txt ,buharlasmaorani,feramon,toplamkarinca) for(int i=0 i<tur.length i++){System.out.print(tur[i]+ ) } System.out.println( \nminimum mesafe = +x.readMesafe()) } } Program 5.22 Satıcı problemi çözüm yöntemi olarak karınca optimizasyonu, test verisi 100 0 95.10565163 30.90169944 80.90169944 58.77852523 58.77852523 80.90169944 30.90169944 95.10565163 6.12E-15 100 -30.90169944 95.10565163 -58.77852523 80.90169944 -80.90169944 58.77852523 -95.10565163 30.90169944 -100 1.22E-14 -95.10565163 -30.90169944 -80.90169944 -58.77852523 -58.77852523 -80.90169944 -30.90169944 -95.10565163 -1.84E-14 -100 30.90169944 -95.10565163 58.77852523 -80.90169944 80.90169944 -58.77852523 95.10565163 -30.90169944 100 -2.45E-14 Nispeten kolay olan lineer optimizasyon metodları, bir çok lineer optimizasyon problemiyle karşılaştığımız için önemlidir. Lineer problemler tanımı icabı sadece sınırlar ile beraber anlam taşırlar sınırsız lineer optimizasyon tanımlı değildir. Lineer optimizasyon problemini en genel olarak Maksimum Z=a0x0+ a1x1+ a2x2+ a3x3+……+ anxn Sınır şartları b00x0+ b01x0+ b02x0+ b03x0+……+ b0nx0 <= A0 b10x0+ b11x0+ b12x0+ b13x0+……+ b1nx0 <= A1 b20x0+ b21x0+ b22x0+ b23x0+……+ b2nx0 <= A2 ………………………………………………………………………… bn0x0+ bn,1x0+ bn2x0+ bn3x0+……+ bnnx0 <= An şeklinde tanımlıyabiliriz. Sistemde maksimum yerine minimum olduğunda veya <= yerine >= gibi değişik şartların gelmesini işaret değiştirerek çözebiliriz. Bir örnek yazarsak problem Maksimum Z=60x+50y Sınır şartları 2x+4y<=80 3x+2y<=60 şeklinde verilebilir. Denklemi simpleks metodu ile çözmek için önce formunda değişiklik yapmak gerekir. denklem Z-a0x0- a1x1- a2x2- a3x3-……- anxn = 0 Sınır şartları b00x0+ b01x1+ b02x2+ b03x3+……+ b0nxn + W0 = A0 b10x0+ b11x1+ b12x2+ b13x3+……+ b1nxn + W1 = A1 b20x0+ b21x1+ b22x2+ b23x3+……+ b2nxn + W2 = A2 ………………………………………………………………………… bn0x0+ bn,1x1+ bn2x2+ bn3x3+……+ bnnxn + Wn = An şekline getirilir. Denklem matris formunda yazılırsa   a0 b  00  b1 0   ...  bn 0   a1  a2 ....  an 0 0 ... 0 b0 1 b1 1 ... bn1 b0 2 b1 2 ... bn 2 1 0 ... 0 0 1 ... 0 .... b0 n .... b1n .... ... .... bn n ... ... ... ... 0 0 ... 1  x0  x   1  x2     0    ....  A   x   0    n    A1   W0     W  ....   1   An   W    2   ....   Wn  şeklini alır. Görüldüğü gibi matrisin satır ve sütun sayıları uymadığından direk bir denklem çözme sistemi ie çözülmesi mümkün değildir. Bunun yerine Simpleks metodu simi verilen bir metod kullanacağız. Bu metodun uygulanması temel olarak şu şekilde yapılır Ana denklemde katsayıları negatif olarak en büyük olan sütun seçilir. Bu sütuna kritik sütun adı verilir. Şart denklemlerinin ikinci tarafı kritik sütundaki değere bölünerek değerleri bulunur. Değeri en küçük olan sütun kritik sütun olarak alınır. 3. kritik sütunla kritik satırın kesim noktasına kritik eleman adı verilir. 4. kritik satır, kritik elemana bölünerek normalize edilir 5. kritik satır dışındaki satırlar yeni değer = eski değer – [kritik sütundaki aynı satıra gelen değer]*[kritik satırdaki aynı sütuna gelen değer]/kritik eleman formülü kullanılarak hesaplanır. 2. şeklinde tanımlanabilir. 1. iterasyonda anahtar sütunun -60 ın yer aldığı sütun olduğu görülür. Örneğin 0 ıncı sütundaki x değerini 0 yapmak için 3 satır(kritik sayır) 60 ile çarpılarak o satırla toplanır. Bu durumda değerleri 0 10 0 20 1200 olacaktır. birinci sütundaki x değerini 0 yapmak için 3 satır(kritik sayır) -2 ile çarpılarak 1. satırla toplanır. Aynı iteratif işlemi bir daha tekrarlarız. Elimine prosesi sonucunda matris 35  1350 2  1  15  4  1 10  2  formunu alır. Şimdi aynı örnek problemi bilgisayar ortamında çözersek Program 5.23-1 Lineer simpleks optimizasyonu class simplex { public static double[] simplex(double[][] a) { int n=a.length //satır int m=a[0].length //sütun System.out.println( m= +m+ n= +n) int m1=m-1 //x,y lerin sayısı int n1=n-1 int m2=m1+n1 int m3=m2+1 int keyrow=0 int keycolumn=0 double keynumber=0.0 double ratio=1.0 double b[][]=new double[n][m3] double d[]=new double[m] String s[]=new String[m] for(int i=0 i<n i++) { b[i][m2]=a[i][m1] } for(int i=0 i<n-1 i++) { for(int j=0 j<m1 j++) {b[i][j]=a[i][j] } for(int j=m1 j<m2 j++) {if(i==(j-m1)) b[i+1][j]=1.0 System.out.println( i= +i+ j= +j+ bij= +b[i+1][j]) } } double max double min System.out.println(Matrix.toString(b)) for(int k=0 k<n1 k++) { max=-9.999e30 min=9.999e30 for(int j=0 j<m1 j++) {if( (b[0][j]<0) && Math.abs(b[0][j])>max) {max=Math.abs(b[0][j]) keycolumn=j }} for(int i=1 i<n i++) { ratio=b[i][m2]/b[i][keycolumn] if(ratio<min) {min=ratio keyrow=i } } keynumber=b[keyrow][keycolumn] double c[][]=new double[n][m3] for(int i=0 i<n i++) { for(int j=0 j<m3 j++) {c[i][j]=b[i][j] }} for(int i=0 i<n i++) { if(i.=keyrow) {for(int j=0 j<m3 j++) {b[i][j]=c[i][j]-c[keyrow][j]*c[i][keycolumn]/keynumber }} else {for(int j=0 j<m3 j++) {b[i][j]=c[i][j]/keynumber }} } System.out.println( keynumber = +keynumber) System.out.println( keyrow = +keyrow+ keycolumn = +keycolumn) System.out.println(Matrix.toString(b)) } d[m1]=b[0][m2] s[m1]= y=f(x) for(int j=0 j<m1 j++) { s[j]= x[ +j+ ] } for(int i=1 i<n i++) { for(int j=0 j<m1 j++) { if((b[i][j]==1.0)&& (b[0][j]==0.0)) { d[j]=b[i][m2] } } } Text.print(d,s, Simplex algorithm ) return d } public static void main(String arg[]) { double a[][]=Text.readDouble_TextArea() double d[]=simplex(a) System.out.println(Matrix.toString(d)) } } Girdi 5.22-1 Lineer simpleks optimizasyonu Çıktı 5.22-1 Lineer simpleks optimizasyonu ---------- Capture Output ---------> C \co\java\bin\java.exe OPO25 -60.000000000000000 -50.000000000000000 2.000000000000000 4.000000000000000 3.000000000000000 2.000000000000000 0.000000000000000 1.000000000000000 0.000000000000000 0.000000000000000 0.000000000000000 1.000000000000000 0.000000000000000 80.000000000000000 60.000000000000000 0.000000000000000 1.000000000000000 0.000000000000000 20.000000000000000 -0.666666666666667 0.333333333333333 1200.000000000000000 40.000000000000000 20.000000000000000 3.750000000000000 0.375000000000000 -0.250000000000000 17.500000000000000 -0.250000000000000 0.500000000000000 1350.000000000000000 14.999999999999998 10.000000000000002 10.000000000000002 14.999999999999998 1350.000000000000000 Çıktı 5.23-2 Lineer simpleks optimizasyonu İkinci bir örnek problem Bir spor malzemesi üreten şirketin tenis raketleri üreten 3 fabrikası bulunmaktadır. Tenis raketlerinin Ağır, orta ve hafif olarak 3 türü bulunmaktadır. Bu üç türün hepsi de 3 fabrikada da üretilebilmektedir. Fabrikaların kapasiteleri günde 550, 650 ve 300 raketle sınırlıdır. Her tür raketin fabrikaya göre kar oranları değişik prosesler kullanıldığından farklıdır. Fabrikalara göre raketlerin kar oranları aşağıdaki tabloda verilmiştir. Raket tipi Ağır Orta Hafif Satış bölümü yıllık satış tahminlerini ağır raketler için 700 birim, orta raketler için 850 birim ve hafif raketler için 750 birim olarak vermiştir. En fazla kar etmek için( Karı maksimize etmek için) her fabrikada hangi türden kaç raket üreteceğimizi bulunuz. Denklem seti Maximum 10xh1+8xh2+12xh3+7xm1+9xm2+8xm3+8xl1+5xl2+4xl3 Sınır şartları xh1+xm1+xl1<=550 xh2+xm2+xl2<=650 xh3+xm3+xl3<=300 xh1+xh2+xh3<=700 xm1+xm2+xm3<=850 xl1+xl2+xl3<=750 olarak verilir. Denklemi simpleks fromunda yazarsak z-10xh1-8xh2-12xh3-7xm1-9xm2-8xm3-8xl1-5xl2-4xl3=0 xh1+xm1+xl1+W1=550 xh2+xm2+xl2+W2=650 xh3+xm3+xl3+W3=300 xh1+xh2+xh3+W4=700 xm1+xm2+xm3+W5=850 xl1+xl2+xl3+W6=750 şimdi katsayılar matrisini programımıza girelim -8 -8 -5 -4 0 0 0 0 8 0 0 0 0 0 3600 550 650 300 400 850 750 0 7600 150 650 300 400 850 750 0 550 650 300 700 850 750 0 13450 150 650 300 400 200 750 0 14650 0 150 0 650 0 300 0 400 0 200 1 750 0 14650 0 150 0 650 0 300 0 400 0 200 1 750 0 14650 0 150 0 650 0 300 0 400 0 200 1 750 400 0 300 0 650 0 150 0 0 14650 Sonuçlar Not x[0]=xh1, x[1]=xh2, x[2]=xh3, x[3]=xm1, x[4]=xm2, x[5]=xm3, x[6]=xl1, x[7]=xl2, x[8]=xl3 toplam kar=14650 TL simplex verisi çok büyüdüğünde veriyi dosyadan okumak daha kolay olabilir. Veriyi dosyadan okuyan, hesaplamayı üstteki simpleks programındaki metodla yapan küçük bir ana program altta verilmiştir Program 5.23-2 Lineer simpleks optimizasyonu dosyadan okuyan versiyonu import java.io. * import javax.swing. Sıvı fazda en yüksek tolüen saflığı elde etmek için ( karışımdaki tolüen oranını maksimize etmek için)tank hangi sıcaklıktaçalıştırılmalıdır. x tolüenPdoyma_tolüen + x benzenPdoyma_benzen = P = 760 mmHg Reaksiyona girmemiş A reaktöre geri beslenmektedir. Sistemin toplam maliyetini minimum yapacak şekilde her iki reaktörün de dönüşümünü (x A1 ve xA2) bulun. Fonksiyon ve tepe noktasının -10 <= x <= 10 ve 0 <= y <= 20 sınırları arasında kaldığı bilgisi verildiğine göre derişikliğin tepe noktasının gerçek yerini belirleyiniz. 320 cm3 hacim istenmekte ve estetik kısıtlar çapın 3 ile 10 cm arasında yüksekliğin de 2 ile 10 cm arasında olmasını gerektirmektedir. Kutunun üst ve altkapak dahil aynı kalınlıkta aynı malzemeden yapıldığını varsayarak maliyeti minimum yapacak boyutu ve kutu başına maliyeti bulunuz. Kompresör çıkışı 27 bardır. Kompresör iş girişini minimize eden ara basınç değerlerini hesaplayınız Her kademe için iş W=Cp(Ti – Te)=CpTi(1-Te/Ti)=kRTi/(k-1)*[1-(Pe/Pi)(k-1)/k] Üç kademe için toplam iş İpucu interpolasyon polinomları kulanarak bir fonksiyon tanımına gidebilirsiniz. Maksimumunu bulunuz. g = 2*c/(4+0.8c+c2+0.2c3) çoğalmanın maksimum olduğu c değerini bulunuz. bu yüzden c = 10 mg/L den büyük değerleri incelemeye gerek yoktur. Not istediğiniz yöntemi kullanabilirsiniz ancak çözüme başlamadan önce fonksiyon değerlendirmesi ile maksimumun olduğu bölgeyi sınırlandırabilirsiniz, bu size işlem kolaylığı sağlayacaktır. x2  y2   fonksiyonunun  20  x  20 ve  20  y  20 noktaları arasında =1e-2 için P(18,18) noktasından başlayarak maksimum değerini bulunuz fonksiyonunun  4  x  4 ve  4 y  4 noktaları arasında P(3,3) noktasından başlayarak minimum değerini bulunuz 2 ) Bir evin su oluğunu yapmak için düz bir metal levha iki tarafından şekilde görüldüğü gibi eğilmiştir. Oluğun su alma kapasitesi V(d,) = Z(d2sin cos + (L-2d)dsinşeklinde yazılabilir. Burada z oluğun boyudur (levha alanı zL dir). Oluğun su alma kapasitesini maksimum yapacak d ve değerlerini bulunuz. L=10 cm olsun. Tüm şehirlerden çıkan yollar P ortak noktasında birleşmektedir. Toplam yol uzunluğunu minimum yapan P noktasını bulunuz. Üç boyutlu grafikte bu noktayı görünüz, sonra (0,0) noktasından başlayarak minimum bulma metodlarıyla minimumu bulunuz. f ( x)  15 x fonksiyonunun maksimumunu 0 ile 10 aralığında bulunuz. (4 x  3x  4) 2 En temel optimizasyon problemlerinden birisi belli bir hacmi içinde barındıracağımız kutuyu en ucuza imal etmektir. Kutu maliyetleri temel olarak yüzey alanının fonksiyonudur. Bu yüzden verilen hacim için yüzey alanını minimize etmemiz gerekir. D3 4V  olarak bulunur. Buradan çözüm D  3  =0.086025401 m dir. D 2 Şimdi bu değerleri bilgisayar ortamında sayısal yöntemlerle çözelim 0.01<=D<=0.2 arasında Bu değeri h teriminde yerine koyarsak h  Elektrik akım taşıyan bir tel etrafında yarıçapı r olan plastik bir izolasyon bulunmaktadır. Teldeki elektriksel direnç ısı oluşturmaktadır. Bu ısı plastik izolasyondan ısı iletim mekanizmalarıyla akmakta ve ısı taşınımıyla T sıcaklığındaki çevre havasına taşınmaktadır. Telin sıcaklığı q  ln(r / a) 1  T    T denklemiyle verilir. Burada  2  k hr  q = teldeki ısı oluşumu = 50 W/m T sıcaklığını minimum yapacak r yarıçapını bulunuz. Mukavva kutu yapılmak için şekilde görüldüğü gibi kıvrılmaktadır. En az miktarda mukavva harcamak için a ve b boyutlarının ne olması gerektiğini hesaplayınız. Silindir şeklindeki bir kabın kütlesi M ve boş ağırlık merkezi C=0.43H dir. Kabın içindeki suyun derinliği h ise su ve kabın ortak ağırlık merkezinin mümkün olduğu kadar aşağıda olması için x değerinin ne olması gerektiğini hesaplayınız. iki değişik çaptaki silindir kesitli bir kiriş şekildeki gibi yerleştirilmiştir. Kirişin mümkün olan en düşük kesit alanına sahip olması istenmektedir. 2   8PL =sağ kısımdaki maksimum gerilim  r23 r1 ve r2 yi hesaplayınız. Şekilde görülen koni tabanlı açık üst taraflı silindirik kabın V hacminin 1 m3 olması istenmektedir. b  V   r2  h 3       12   V  4     r  r    minimum yapan   r    6   denklemiyle tanımlanır. Buradaki  ve  sabit değerlerdir. V potansiyelini  değerini bulunuz.   C (27  18  2 2 )e / 3   zr / a0 1 C 81 3  z     a0  fonksiyonu ile tanımlanabilir. Buradaki z = çekirdek yük miktarı a0 = Bohr yarıçapı r =radyal mesafedir.  dalga fonksiyonunu minimum yapan  değerini bulunuz. 6. Genellikle bilim insanları ölçtükleri bu değerlerin sonuçlarını çeşitli formüller şeklinde genelleştirirler. Sayısal olarak elde edilen verilerden matematiksel genel formüller oluşturma işlemine eğri uydurma diyoruz. Kullanılacak olan formüllerin formu genellikle ilgili fiziksel yasalardan yola çıkılarak irdelenen bilimdalı tarafından gebellenir veya araştırıcı istediği formül formunu serbest olarak kendi seçer. Bu formüllerde genellikle veriye en iyi uyan bir katsayı setinin hesaplanması söz konusudur. Bu katsayılar formülün içine lineer olarak yerleştirilebildiği gibi lineer olmıyan bir formda da olabilirler. Katsayının formıuna göre eğri uydurma prosesi lineer ve lineer olmıyan diye 2 ye ayrılır. Her iki durumda da eğri uydurma temel olarak bir optimizasyon prosesidir. Aradeğr hesabı da eğri uydurarak veya direk hesapla elimizdeki verilere en uygun ra değerleri hesaplama yöntemidir. Genellikle aradeğer hesaplarında her zaman veri verilen noktalardan geçer. Eğri uydurmada böyle bir zorunluluk yoktur. m f ( x)   a (j m ) j ( x) j 0 j inci derece polinomu verilmiş olsun. Bu polinoma xi,fi, i=0...n verisini uydurmak istiyoruz. Bu veri seti için en uygun aj(m) değerlerini bulmak istiyoruz. 2 fonksiyonunun minimum değerini bulmamız gerekir.   k  0,.....,m k  0,.....,m Bu denklem temel olarak m+1 lineer denklem sistemidir. Şimdi problemin özel bir formuna göz atalım. m f ( x)   a (j m ) j ( x) j 0 halini alır. Aynı zamanda ağırlık fonksiyonunu da 1 olarak alalım( w( xi )  1 ). n  f xk  i 1 i i x k  0  i k  0,....., m k  0,....., m şeklini alır. Bu matrisi açık formda yazacacak olursak n n  xi  xi  xi  xi  xi  xi .... m 2  xi i 1 n i 1 n 2 4 i 1 i 1 i 1 n i 1 n 2 3 5 i 1 n i 1 ....           Bu matris lineer matris çözüm yöntemlerini kullanarak rahatlıkla çözülebilir. Belirlenen katsayılar matriste yerine konularak kullanılır. Aşağıda polinom en küçük kareler matrisi ugulama programımız verilmiştir. Program 6.1-1 En küçük kareler metodu programı İmport java.io. * import javax.swing. {z[0][k]=xi[i] z[1][k]=funcEKK(E,z[0][k]) k++ for(int j=0 j<aradegersayisi j++) {dx=(xi[i+1]-xi[i])/((double)aradegersayisi+1.0) z[0][k]=z[0][k-1]+dx z[1][k]=funcEKK(E,z[0][k]) k++ } } z[0][k]=xi[i] z[1][k]=funcEKK(E,z[0][k]) return z } Çıktı 6.1-1 En küçük kareler metodu programı grafik çıktısı p j (x) j inci dereceden bir polinom olsun. m'inci dereceden en küçük kareler polinom fonksiyonunu da m Eğer xi,fi i=1,…,n verisi için j 0 2 i 1   k  0,.....,m k  0,.....,m denklemi daha kısa ifade edebilmek için  n  k  0,.....,m  n  i 1  k  0,....., m olarak adlandırır isek, bu durumda denklemimizi   m Halini alır. Denklemin bu şekilde yazılması hesaplama bakımından bana bir avantaj getirmemiştir. Ancak pk ( xi ) fonksiyonunu özel bir form olan ortogonal polinom olarak alır isek, ortogonal polinomların özelliği gereği n Bu durumda sistemimiz çok daha basit bir denklem olan i 0   Burada bj(m) değerini çözmek için denklem sistemi çözümü yerini basit bölme işlemine bırakmış olur.  b   (m) j p0(x) = 1 p-1(x) = 0 şeklindedir. j+1 ve j hesaplanması gereken polinom sabitleridir. n k   w( xi ) xi pk 1 ( xi ) pk ( xi ) i 1 n  w( xi ) xi [ pk 1 ( xi )] i 1 n k  2 n   w( xi )[ pk ( xi )] i 1 n 2  w( xi )[ pk 1 ( xi )] 2 i 1 2 2 i 1 Bu sabitleri kullanarak en küçük kareler hesabını şu şekilde gerçekleştiririz. n  bj  j j n Ortogonal polinom eğri uydurma , denklem sistem çözmediği için denklem sistemi çözümünden oluşan hataları da barındırmıyacaktır, bu yüzden polinom eğri uydurmaya göre tercih edilebilir, ancak polinom denkleminin basitliği bu denkleme yoğun bir uygulama alanı getirmiştir. Program 6.2-1 Ortogonal polinom eğri uydurma import java.io. Çıktı 6.2-1 Ortogonal polinom eğri uydurma veri çıktısı 0.0 -1.3331314685310902E-4 0.4666666666666668 0.4497794627972029 0.011111111111111112 0.011022273501971321 0.4777777777777779 0.4596700067265246 0.022222222222222223 0.02217203082505974 0.48888888888888904 0.46950495493798394 0.03333333333333333 0.03331477390831393 0.5 0.044444444444444446 0.04444931783763565 0.5111111111111111 0.48900332455092227 0.05555555555555556 0.05557447769892668 0.5222222222222221 0.49866437612420494 0.06666666666666667 0.06668906857808862 0.5333333333333332 0.5082650923232322 0.07777777777777778 0.0777919055610234 0.5444444444444443 0.5178042882339059 0.08888888888888889 0.0888818037336327 0.5555555555555554 0.5272807789421277 0.1 0.5666666666666664 0.5366933795337994 0.09995757818181823 0.4792831225174825 0.11111111111111112 0.1110180439914818 0.5777777777777775 0.5460409050948227 0.12222222222222223 0.1220620162485252 0.5888888888888886 0.5553221707110993 0.13333333333333333 0.13308831003885008 0.6 0.5645359914685315 0.14444444444444443 0.14409574044835827 0.611111111111111 0.15555555555555553 0.15508312256295145 0.6222222222222221 0.5827565587504675 0.5736811824530201 0.16666666666666663 0.16604927146853146 0.6333333333333332 0.5917609354467753 0.17777777777777773 0.17699300225099998 0.6444444444444443 0.6006931276278452 0.18888888888888883 0.1879131299962589 0.6555555555555553 0.6095519503795791 0.2 0.19880846979020986 0.6666666666666664 0.6183362187878786 0.2111111111111111 0.20967783671875456 0.6777777777777775 0.6270447479386455 0.2222222222222222 0.22052004586779472 0.6888888888888886 0.6356763529177815 0.2333333333333333 0.23133391232323228 0.7 0.6442298488111887 0.2444444444444444 0.24211825117096894 0.711111111111111 0.6527040507047684 0.25555555555555554 0.25287187749690637 0.7222222222222221 0.6610977736844225 0.26666666666666666 0.2635936063869464 0.7333333333333332 0.6694098328360527 0.2777777777777778 0.2742822529269907 0.7444444444444442 0.6776390432455609 0.2888888888888889 0.2849366322029412 0.7555555555555553 0.6857842199988488 0.3 0.2955555593006993 0.7666666666666664 0.693844178181818 0.3111111111111111 0.30613784930616705 0.7777777777777775 0.7018177328803704 0.32222222222222224 0.31668231730524615 0.7888888888888885 0.7097036991804079 0.33333333333333337 0.32718777838383845 0.8 0.3444444444444445 0.3376530476278455 0.8111111111111111 0.7252081269285447 0.3555555555555556 0.3480769401231691 0.8222222222222222 0.7328242185484475 0.7175008921678322 0.36666666666666675 0.35845827095571103 0.8333333333333333 0.740347982113442 0.3777777777777779 0.3687958552113731 0.8444444444444443 0.7477782327094304 0.388888888888889 0.379088507976057 0.8555555555555554 0.7551137854223142 0.4 0.38933504433566435 0.8666666666666665 0.7623534553379951 0.41111111111111115 0.3995342793760972 0.8777777777777775 0.7694960575423752 0.4222222222222223 0.40968502818325714 0.8888888888888886 0.7765404071213559 0.4333333333333334 0.4197861058430459 0.9 0.7834853191608392 0.44444444444444453 0.42983632744136524 0.9111111111111111 0.7903296087467265 0.45555555555555566 0.439834508064117 0.9222222222222222 0.7970720909649198 0.9333333333333332 0.8037115809013209 0.9444444444444443 0.8102468936418314 0.9555555555555554 0.8166768442723531 0.9666666666666665 0.8230002478787879 0.9777777777777775 0.8292159195470372 Çıktı 6.2-2 Ortogonal polinom eğri uydurma grafik çıktısı Ortogonal fonksiyonlarla eğri uydurmaya ikinci bir örnek daha verelim.Bu örneğimizde ortogonal fonksiyon olarak Chebychev polinomlarını kullanacağız. Chebychev polinomları (-1,1) bölgesinde tanımlanır. Genel tanımı Tn(x)=cos(n arccos(x)) şeklindedir. Bu terimi açarsak T0(x)=1 T1(x)=x T2(x)=2x2-x ….. Tn+1(x)=2x Tn(x)- Tn-1(x) Şeklinde bir dizi olarak hesaplanabilen bir polinom fonksiyon olduğunu görürüz. Chebchev fonksiyonları için ağırlık fonksiyonu 1 w( x)  fonksiyonudur. Chebchev fonksiyonunun kökleri Eğri uydurma için verilerimizin kök 2n  2 noktalarındaki değerini bilmemiz gerekir. Ancak Chebchev polinomlarının kökleri (-1,1) bölgesinde olduğundan bundan başka bie (a,b) bölgesinde verilmiş bir verimiz varsa bunu değişken değişimi ile ayarlamamız gerekir. k 0 Chebyschev polinomu ortogonal olduğundan bu işlem için bir matris çözümü gerekmez, katsayılar direk olarak bulunur. C0  Cj  j=1,2,…n Örnek problem olarak f(x)=ex fonksiyonunun 0 ile 2 arasındaki değerlerini değerlendirerek bir veri seti oluşturduk yk 1.010231 1.094577 1.276664 1.583059 2.050877 2.718282 3.602877 4.66758 5.787784 6.750604 7.314228 xk değerlerinin Chebychev kök değerlerinde olduğuna tekrar dikkatinizi çekelim. Program 6.2-2 Chebychev ortogonal polinom eğri uydurma import java.io. Çıktı 6.2-3 Chebychev ortogonal polinom eğri uydurma Çıktı 6.2-4 Chebychev ortogonal polinom eğri uydurma, grafik çıktısı Bu programda yapacağımız küçük bir değişiklikle, Chebychev polinom programını verilen bir fonksiyona verilen aralıkta Chebychev serisi uydurmada da kullanabiliriz. Örnelk olarak yine f(x)=e x fonksiyonuna 0 ile 2 aralığında Chebychev polinomu uyduralım. Program 6.2-3 Chebychev ortogonal polinomları ile fonksiyona eğri uydurma import java.io. //System.out.println( dx= +dx+ i = +i+ x= +z[0][i]+ y= +z[1][i]) } return z } public static void main(String args[]) throws IOException { f1 ff=new f1() double a=0 double b=2.0 double z[][]=funcChebyshev(a,b,ff,20,10) Text.print(Text.T(z), Chebyschev ortogonal en küçük kareler yöntemi eğri uydurma ) System.out.println( dx=\n +Matrix.toStringT(xi(a,b,10))) } } Çıktı 6.2-5 Chebychev ortogonal polinomu ile fonksiyona eğri uydurma Bölüm 6-1 de en küçük kareler metodunun genel hali f ( x)   a (j m ) j ( x) fonksiyonu için verilmişti. j 0   k  0,.....,m k  0,.....,m w( xi ) =1 olarak seçilirse genel en küçük kareler metodu n  2    0 ( xi )  i 1  n   0 ( xi )1 ( xi )  i 1  n   0 ( xi )2 ( xi )  i 1 ....   n  0 ( xi )m ( xi )  i 1 n  0 ( xi )1 ( xi ) i 1 n  0 ( xi )2 ( xi ) i 1   ( x ) ( x ) 1 n i 1 i 2 i 1 ....  1 ( xi )m ( xi ) i 1 2 2 2 ( xi )  i n i i .... n   ( x ) ( x ) 1 1 i 1 .... .... .... n   ( x ) i 1 2 i m ( xi ) .... n   2 ( xi ) i 1 n ....   0 ( xi )m ( xi )  formunu alır. Genel en küçük kareler yöntemi bazı problemler için özel polinom gibi önceden tam olarak bilinen fonksiyonlara göre daha problem spesifik fonksiyonların tanımlanmasına olanak verir. Örneğin gaz R142B gazı yoğunluk denklemi kaynaklarda  ' / c  13  (E i 10 i 11 ) i / 3  E25 ln( ) (Tc – T)/Tc ve  = T/Tc ' kaynayan sıvının yoğunluğu c kritik yoğunluk T sıcaklık Tc kritik sıcaklık şeklinde verilmiştir.görüldüğü gibi böyle bir denklem standart polinom tanımına uymamaktadır, ancak tüm katsayıları lineer olduğundan rahatlıkla en küçük kareler yöntemi kullanılarak katsayıları hesaplanabilir. Program 6.3-1 de Genel en küçük kareler metodu tanımlanmıştır. Program 6.3-1 Genel en küçük kareler metodu ile eğri uydurma import java.io. * import java.util. çözüm seti \n +Matrix.toStringT(z)) Plot pp=new Plot(c[0],c[1]) pp.setPlabel( Genel En küçük kareler yöntemi ile R134a sıcaklık - doyma sıvı yoğunluğu eğrisi uydurma ) pp.setXlabel( T derece C ) pp.setYlabel( ro sıvı kg/m^3 ) pp.addData(z[0],z[1]) pp.plot() }} Girdi 6.3-1 Genel en küçük kareler metodu ile eğri uydurma girdi R123trol.txt dosyası verisi (çıktıyla karşılaştırma amacıyla verilmiştir) -100.0 -99 -98 -97 -96 -95 -94 -93 -92 -91 -90 1580.5 1577.8 1575 1572.3 1569.5 1566.8 1564.1 1561.3 1558.6 1555.8 1553.1 -59 -58 -57 -56 -55 -54 -53 -52 -51 -50 -49 1468 1465.2 1462.4 1459.6 1456.9 1454.1 1451.3 1448.5 1445.7 1442.9 1440.1 -18 -17 -16