} public boolean isEmpty() {return firstNode==null } //türkçe eşdeğer metodlar public boolean bosmu() {return isEmpty() } public synchronized void oneEkle(Object o) {insertAtFront(o) } public synchronized void arkayaEkle(Object o) {insertAtBack(o) } public synchronized Object ondenCikar() {return removeFromFront() } public synchronized Object arkadanCikar() {return removeFromBack() } public void print() { if(bosmu()) { System.out.print( Bos +name) return } System.out.print( +name+ ) ListNode current=firstNode while(current.=null) { System.out.print(current.data.toString()+ ) current=current.next } System.out.println( \n ) } } } catch(EmptyListException e) {System.out.println( \n +e.toString()) } } } ListTest programının sonucu List yapısını kullanan örnek program ListTest.java nın çıktısı Liste true Liste $ true Liste 34567 $ true Liste hello 34567 $ true hello cikarildi Liste 34567 $ true 34567 cikarildi Liste $ true true cikarildi Liste $ $ cikarildi Bos Liste Burada List sınıfının girdisinin Object sınıfı olduğun dikkatinizi çekelim. Object sınıfı yine dinamik object değişken yapıları olarak tanımlanan Double, Byte, String, Integer, Boolean, Float, Short, Long gibi değişken türleri için kullanılan sınıfların abstract sınıfını teşkil eder. Bu yüzden bu sınıfların hepsini temsil edebilir ve yerlerine kullanılabilir (genel bir sınıftır.). Bu sınıflar normal değişken türlerine dönüştürülebilirler. (daha önce de kullandığımız intValue(), doubleValue() gibi metotları kullanarak) Object sınıfının temel tanımı (metodtanımları olmadan) şu şekildedir. package java.lang public class Object { private static native void registerNatives() static { registerNatives() } public final native Class getClass() public native int hashCode() public boolean equals(Object obj protected native Object clone() throws CloneNotSupportedException public String toString() public final native void notify() public final native void notifyAll() public final native void wait(long timeout) throws InterruptedException public final void wait(long timeout, int nanos) throws InterruptedException public final void wait() throws InterruptedException protected void finalize() throws Throwable } burada geçen native sözcüğünün anlamak istiyorsanız, 14 üncü bölümü inceleyebilirsiniz. Bu terim metodun anadilde (native) yazıldığını belirtir. Java.util paketinde List sınıfı tanımlanmıştır. Yukarıda kendi tanımladığımız List ile yapabildiklerimizi ve daha fazlasını tanımlı List paketiyle a gerçekleştirebiliriz. package java.util public interface List extends Collection { int size() boolean isEmpty() boolean contains(Object o) Iterator iterator() Object[] toArray() Object[] toArray(Object a[]) boolean add(Object o) boolean remove(Object o) boolean containsAll(Collection c) boolean addAll(Collection c) boolean addAll(int index, Collection c) boolean removeAll(Collection c) boolean retainAll(Collection c) void clear() boolean equals(Object o) int hashCode() Object get(int index) Object set(int index, Object element) void add(int index, Object element) Object remove(int index) int indexOf(Object o) int lastIndexOf(Object o) ListIterator listIterator() ListIterator listIterator(int index) List subList(int fromIndex, int toIndex) } List sınıfıyla birlikte kullanılmak üzere ListIterator interface'i tanımlanmıştır. /* package java.util public interface ListIterator extends Iterator { boolean hasNext() Object next() boolean hasPrevious() Object previous() int nextIndex() int previousIndex() void remove() void set(Object o) void add(Object o) } Şimdi bu iki sınıfın kullanımını bir örnekle gösterelim. s = (String)lit.previous() lit.remove() lit.next() lit.next() lit.add(s) Iterator it = planets.iterator() String ss= while (it.hasNext()) {ss+=it.next()+ \n } JOptionPane.showMessageDialog(null,ss) System.exit(0) } } LinkedList sınıfı List sınıfında olmayan ilave metodlar tanımlamıştır. public class LinkedList extends AbstractSequentialList implements List, Cloneable, java.io.Serializable { private transient Entry header private transient int size public LinkedList() public LinkedList(Collection c) public Object getFirst() public Object getLast() public Object removeFirst() public Object removeLast() public void addFirst(Object o) public void addLast(Object o) public boolean contains(Object o) public int size() public boolean add(Object o) public boolean remove(Object o) public boolean addAll(Collection c) public boolean addAll(int index, Collection c) public void clear() public Object get(int index) public Object set(int index, Object element public void add(int index, Object element) public Object remove(int index) public int indexOf(Object o) public int lastIndexOf(Object o) */ public ListIterator listIterator(int index) } Program çıktısı dizin listeye göre daha sınırlı olan şu koşullara sahiptir     Dizide son elemandan sonra listeye dinamik eleman ilavesi yapılabilir. Dizinin herhangibir ara noktasına yeni eleman ilave edilemez. Dizinin sadece son elemanı listeden çekilebilir. Listenin herhangi bir ara noktasından eleman çekilemez. dizi yapısını kullanan örnek program diziTesti.java'nın çıktısı dizi true dizi $ true dizi 34567 $ true dizi hello 34567 $ true hello diziden cekildi dizi 34567 $ true 34567 diziden cekildi dizi $ true $ diziden cekildi dizi true true diziden cekildi Bos dizi yukarıda tanımlanan LinkedList sınıfının addFirst()/removeFirst() metotlarını kullanarak da stack oluşturabiliriz. java.util paketinde vector sınıfının yanı sıra Stack sınıfı da tanımlanmıştır. Java Stack sınıfında push, pop ve peek metotları vardır. push ve pop dizin programını aynısıdır. peek ise listenin en sonundaki elemanın değerini bu elemanı listeden uzaklaştırmadan alır. (pop ile push beraber kullanılarak da aynı işi yapabilirler) Bu sınıfın tanımı public class Stack extends Vector { public Stack() public Boolean empty() public synchronized Object peek() public synchronized Object pop() public synchronized Object push(Object obj) public synchronized int search(Object obj) } Stack sınıfının metotlarının ne olduğunu daha detaylı inceleyecek olursak push public Object push(Object item) stack'in üstüne yeni eleman ilave eder pop public synchronized Object pop() Stakin en tepesindeki elemanı çeker (Stack dizisinden kaldırır ve değerini return eder) Stack'in boş olması halinde EmptyStackException gönderir. peek public synchronized Object peek() Stack'in en tepesindeki elemanın değerini okur(Stack dizisinden kaldırmaz ve sadece değerini Stack'in boş olması halinde EmptyStackException gönderir. empty public boolean empty() Stack'in boş olup olmadığını kontrol eder, boş ise true, dolu ise false değeri gönderir. Tests if this stack is empty. search public synchronized int search(Object o) Stack'in içindeki istenen Object'in yerini verir. Eğer object Stack'de yok ise -1 değeri verir return eder) Burada hemen Stack sınıfının Vector sınıfının alt sınıfı olduğunu ve Vector sınıfında mevcut olan tüm metotlar Stack metodunda da geçerli olduğunu da hatırlatalım. * public class StackTesti { public static void main(String args[]) { StackTesti st=new StackTesti() Stack d=new Stack() Boolean b=new Boolean(true) Character c=new Character('$') Integer i=new Integer(34567) String s=new String( hello ) d.push(b) st.print(d) d.push(c) st.print(d) d.push(i) st.print(d) d.push(s) st.print(d) Object bakilan Object cekilen try { while(true) { bakilan=d.peek() System.out.println(bakilan.toString()+ de§erine bakildi ) st.print(d) cekilen=d.pop() System.out.println(cekilen.toString()+ de§eri listeden cekildi ) st.print(d) System.out.println( --------------------- ) } } catch(EmptyStackException e) {System.err.println( \n +e.toString()) } } public void print(Stack di) { Enumeration enum=di.elements() StringBuffer buf=new StringBuffer() while(enum.hasMoreElements()) buf.append(enum.nextElement()).append( ) System.out.println(buf.toString()) } } java.util kütüphanesinde yer alan Stack yapısını kullanan örnek program StackTesti.java nın çıktısı true true $ true $ 34567 true $ 34567 hello hello degerine bakildi true $ 34567 hello hello degeri listeden cekildi true $ 34567 --------------------34567 degerine bakildi true $ 34567 34567 degeri listeden cekildi true $ --------------------$ degerine bakildi true $ $ degeri listeden cekildi true --------------------true degerine bakildi true true degeri listeden cekildi --------------------- sıra listeye göre daha sınırlı olan şu koşullara sahiptir  Sırada son elemandan sonra listeye dinamik eleman ilavesi yapılabilir.  Sıranın herhangibir ara noktasına yeni eleman ilave edilemez.  Sıranın sadece ilk elemanı listeden çekilebilir.  Sıranın herhangi bir ara noktasından eleman çekilemez. Sıra kavramının oldukça yaygın olarak kullanıldığı ülkemizde oldukça yararlı olabilecek bir sınıfı değilmi. Yukardaki List tanımını kullanarak oluşturduğumuz sıra programı ve sırayı kullanan bir test programı aşağıda verilmiştir. public class sira extends List { public sira() {super( sira ) } public synchronized void sirayagir(Object o) {arkayaEkle(o) } public synchronized Object siranGeldi() throws EmptyListException {return ondenCikar() } public boolean isEmpty() {return super.isEmpty() } public boolean bosmu() {return super.isEmpty() } public void print() {super.print() } } sira sınıfını kullanan siraTesti.java dosyasının çıktısı sira true sira true $ sira true $ 34567 sira true $ 34567 merhaba true sirasi geldi onden cikti sira $ 34567 merhaba $ sirasi geldi onden cikti sira 34567 merhaba 34567 sirasi geldi onden cikti sira merhaba merhaba sirasi geldi onden cikti Bos sira Queue sınıfı Java'da direk olarak tanımlanmamıştır, ancak üstteki sıra örneğinin bir benzeri Vector sınıfından bizim tarafımızdan rahatlıkla yazılabilir, veya yine LinkedList sınıfının addFirst()/removeLast() metotlarını kullanarak oluşturulabilir. Bilgi gruplandırma işlemini çok daha basit bir şekilde yapabilmek için Tree yapıları öngörülmektedir. Tree temel olarak Vector gibi bir yapıdır. fakat burada her Tree noktası (Nod'u) iki değişik adrese işaret eder bu adreslerden birisi o noktadaki objenin kok değerindekinden daha küçük olduğu bir değeri, diğeri ise daha büyük olduğu bir değeri taşır. hiç bir değer taşımıyorsa da null değeriyle o Tree-ağaç dalı sona erer. Bu yapıyı kullanarak sayıları büyükten küçüğe veya küçükten büyüğe veya daha değişik mantıklarla direk olarak sıralamak mümkündür. Her bir dal kökü kendinden sonra gelen rakamı küçükse sol dala büyükse sağ dala göndermektedir. ve her yeni veri yeni bir dallanma oluşturmaktadır. if(node==null) return System.out.print(node.data+ ) node_soldal_sagdal_siralayici(node.sol) node_soldal_sagdal_siralayici(node.sag) } public void node_sagdal_soldal_siralayici(TreeNode node) { if(node==null) return System.out.print(node.data+ ) node_sagdal_soldal_siralayici(node.sag) node_sagdal_soldal_siralayici(node.sol) } public void soldal_node_sagdal_siralayici(TreeNode node) { if(node==null) return soldal_node_sagdal_siralayici(node.sol) System.out.print(node.data+ ) soldal_node_sagdal_siralayici(node.sag) } public void sagdal_node_soldal_siralayici(TreeNode node) { if(node==null) return sagdal_node_soldal_siralayici(node.sag) System.out.print(node.data+ ) sagdal_node_soldal_siralayici(node.sol) } public void soldal_sagdal_node_siralayici(TreeNode node) { if(node==null) return soldal_node_sagdal_siralayici(node.sol) soldal_node_sagdal_siralayici(node.sag) System.out.print(node.data+ ) } public void sagdal_soldal_node_siralayici(TreeNode node) { if(node==null) return sagdal_node_soldal_siralayici(node.sag) sagdal_node_soldal_siralayici(node.sol) System.out.print(node.data+ ) } } renkli olarak işaretlenen satırların sayı dizisini küçükten büyüğe ve büyükten küçüğe sıraladığına dikkat ediniz. orijinal olarak Tree'ye girilen sayi dizini 13 11 25 34 21 26 14 Sol dal - kok - sag dal siralama 11 13 14 21 25 26 34 kok -Sol dal - sag dal siralama 13 11 25 21 14 34 26 Sol dal - sag dal - kok siralama 11 14 21 25 26 34 13 Sag dal - kok - sol dal siralama 34 26 25 21 14 13 11 kok -Sag dal - sol dal siralama 13 25 34 26 21 14 11 Sag dal - sol dal - kok siralama 34 26 25 21 14 11 13 Bu hafıza açısından yoğun bir işlemdir. Her seferinde hafıza pozisyonunun araştırılmasını gerektirir. Java anahtar referans sağlayan daha değişik bir yapıyı da içerir. Burada her elemanın kendimiz tarafından verilen bir referans değeri mevcuttur ve elemanı bulmak için bu referansı kullanabiliriz. Bu gurubun abstract sınıfı Dictionary sınıfıdır. Dictionary sınıfının altında Hashtable sınıfı yer alır. Dictionary sınıfının tanımı package java.util public abstract class Dictionary { public Dictionary() abstract public int size() abstract public boolean isEmpty() abstract public Enumeration keys() abstract public Enumeration elements() abstract public Object get(Object key) abstract public Object put(Object key, Object value) abstract public Object remove(Object key) } HashTable sınıfının tanımı public class Hashtable extends Dictionary implements Map, Cloneable, java.io.Serializable { private transient Entry table[] private transient int count private int threshold private float loadFactor private transient int modCount = 0 private static final long serialVersionUID = 1421746759512286392L public Hashtable(int initialCapacity, float loadFactor) public Hashtable(int initialCapacity) public Hashtable(Map t) public int size() public boolean isEmpty() public synchronized Enumeration keys() public synchronized Enumeration elements() public synchronized boolean contains(Object value) public boolean containsValue(Object value) public synchronized boolean containsKey(Object key) public synchronized boolean equals(Object key) public synchronized Object get(Object key) protected void rehash() public synchronized Object put(Object key, Object value) public synchronized Object remove(Object key) public synchronized void putAll(Map t) public synchronized void clear() public synchronized Object clone() public synchronized String toString() public Set entySet() public Set keySet() public Collection Values() public synchronized int hashCode() } Hashtables sınıfı temel olarak Dictionary ve Map sınıflarından türetilmiştir. Map sınıfı tanımı package java.util public interface Map { int size() boolean isEmpty() boolean containsKey(Object key) boolean containsValue(Object value) Object get(Object key) Object put(Object key, Object value) Object remove(Object key) void putAll(Map t) void clear() public Set keySet() public Collection values() public Set entrySet() boolean equals(Object o) int hashCode() public interface Entry { Object getKey() Object getValue() Object setValue(Object value) boolean equals(Object o) int hashCode() } } şeklindedir. Hashtable hash = new Hashtable() for (int i=0, n=names.length i < n i++) { hash.put (names[i], new Float (diameters[i])) } Enumeration enum = hash.keys() Object obj String ss= while (enum.hasMoreElements()) { obj = enum.nextElement() ss+=obj + + hash.get(obj)+ \n } JOptionPane.showMessageDialog(null,ss) System.exit(0) } } Hashtable bu tür işlevleri en iyi bir şekilde yerine getirir. Metodları public static List asList(object array[]) b değerinin a değerinin hangi elemanında olduğunu bulan public static int binarySearch(<değişkentürü> a[],<değişkentürü>b) <değişkentürü> char,double,float,int,Object,long,short değerleri alabilir, elbette Object üzerinden Objectin alt sınıfları olan String, Double, Integer gibi sınıfları da kabul eder. İki boyutlu değişkenin birbirine eşit olup olmadığını denetleyen public static boolean equals(<değişkentürü> a[],<değişkentürü>b[]) boyutlu değişkenin tüm değerlerini veya tanımlanan bir bölümünü bir bölümünü aynı tür bir değişken atayan public static void fill(<değişkentürü> a[],<değişkentürü>b) public static void fill(<değişkentürü> a[],int başlangıçindisi,int bitişindisi,<değişkentürü>b) boyutlu değişkeni sıraya sokan public static void sort(<değişkentürü> a[]) public static void sort(Object a[],Comparator comp) listeden de görüldüğü gibi tüm metodlar static metodlardır. * import javax.swing.JOptionPane public class Gezegensirasi { static class InsensitiveComp implements Comparator { public int compare (Object a1, Object a2) { an1 X1 + an2 X2 + an3 X3 + … + ann X3 = bn Şeklinde yazılabilir. Bu denklem matris formunda [A]{X}={B} veya   Ax  B şeklinde yazılabilir. Matris formunu açık yazarsak Bazı kaynaklarda da bu denklem sistemi kısaltılmış formda  a11 a12 ..... a1n  a21 a22 ..... a2 n  .... .... .... ....  an1 an 2 ..... ann b1   a11  a b2  21 veya  ..... ....   bn  an1 a12 a22 ..... an 2 ..... ..... ..... ..... a1n b1  a2 n b2  ..... .....  ann bn  şeklinde de gösterilebilir. Bu denklem sisteminde A ve B değerleri bilinen değerler X değerleri bilinmeyenlerdir. X değerlerinin saptanması problemini doğrusal denklem sistemi çözümü olarak adlandıracağız. Matrislerle ilgili sayısal işlemleri gelecek bölümümüzde inceleyeceğiz, ancak matris işlemlerinin de temelini oluşturan doğrusal denklem sistemi çözümü problemine ilk konu olarak bakmakta yarar görüyoruz. Matrislerin satırlarını değiştirmek, matrisin bir satırını belli bir çarpanla çarpmak veya satırları birbiriyle toplamak(veya çıkarmak) doğrusal denklem sistemindeki bilinmeyenlerin değerini etkilemez. Bu yüzden doğrusal denklem sisteminde (i numaralı satır)- Sabit * (j numaralı satır) gibi bir işlemi denklem sisteminin değerini değiştirmeden oluşturabiliriz. Gauss eleme metodunda bu manipülasyonu yapmaktaki gayemiz üst üçgen matris dediğimiz matrisin diyagonalinin altının tamamen sıfıra eşitlendiği eşdeğer formunu elde etmektir. Örneğin n=5 için a'13 a' 23 a'33 0 0 a'14 a' 24 a'34 a' 44 0 şekline getirmemiz gerekir. Bunu yapabilmek için sistematik bir eleme uygulayabiliriz. İkinci satırın her elemanı için C1 çarpanı kullanılarak yeni değerine çevrilir. a' 25 = a 25 – C1*a15 b'2=b2 – C1*b1 Bu işlemin sonunda a'21 elemanı sıfırlanmış olur. Aynı işlem önce a11 in altındaki tüm satırlara uygulanarak birinci sütundaki 0 değerleri oluşturulur. Daha sonra aynı işlem a22 nin altındaki kolon için yinelenir. Bu işlemi aynı değişkenlerle java döngüsü olarak yazarsak for(k=0 k<(n-1) k++) { for(i=k+1 i<n i++) { C[k]=a[i][k]/a[k][k] a[i][k]=0 for(j=k+1 j<n j++) { a[i][j]-= C[k]*a[k][j] } b[i] =b[i] - C[k]*b[k] } } Lineer denklem sistemi üst üçgen matris şekline dönüştürüldükten sonra tersten itibaren çözme yöntemiyle bilinmeyenler çözülür. Yukarıda verilen beşli sistemin çözüm seti X5 = b'5 / a'55 X4 = (b'4 – a'45*X5)/a'44 X3 = (b'3 – a'34*X4 – a'35*X5)/a'33 X2 = (b'2 – a'23*X3 – a'24*X3 – a'25*X5)/a'22 X1 = (b'1 – a'12*X2 – a'13*X3 – a'14*X4 – a'15*X5)/a'11 Şeklindedir. Doğrusal denklem sisteminin çıktılarını anlaşılır bir şekilde oluşturabilmek için bir String çıktı sınıfı olan matriscikti.java programını oluşturduk. Program kodu aşağıda verilmiştir. Program 2.2-1 matris cikti.java doğrusal denklem sistemi formatlama sınıfı import java.io. * import java.text. * import java.util.Locale public class matriscikti { public static String toString(double left, int w, int d) // double değişkenini verilen boyutta(w) ve noktadan sonra uzaklığında(d) public static String toStringT(double[] left) { // returns a vertical string representation Şimdi Gauss eleme işlemine bir bütün program olarak bakalım Program 2.2-2 Gauss Eleme yöntemi import java.io. System.out.println( çözüm vektörü \n +matriscikti.toStringT(gauss(a,b))) } } Çıktı 2.2-1 Gauss Eleme yöntemi ---------- Capture Output ---------> C \co\java\bin\java.exe SCO10A Orijinal doğrusal denklem sistemi | 1.000000000000000 2.000000000000000 | 2.000000000000000 1.000000000000000 | 3.000000000000000 1.000000000000000 elimine matris k=0 | 1.000000000000000 2.000000000000000 | 0.000000000000000 -3.000000000000000 | 0.000000000000000 -5.000000000000000 elimine matris k=1 | 1.000000000000000 2.000000000000000 | 0.000000000000000 -3.000000000000000 | 0.000000000000000 0.000000000000000 5.000000000000000| 2.000000000000000| 1.000000000000000| 1.000000000000000| 1.000000000000000| 2.000000000000000| 5.000000000000000| -8.000000000000000| -14.000000000000000| 1.000000000000000| -1.000000000000000| -1.000000000000000| 5.000000000000000| -8.000000000000000| -0.666666666666666| 1.000000000000000| -1.000000000000000| 0.666666666666667| çözüm vektörü -0.000000000000001 3.000000000000003 -1.000000000000001 > Terminated with exit code 0. Buradaki örnek doğrusal denklem sistemi Gauss eleme prosesi tek başına kullanıldığında bazı denklem sistemlerinde bu hata büyük boyutlara ulaşabilir. Bu durumun oluşmasındaki temel neden Gauss elimine prosesindeki çarpandaki bölüm teriminin üst tarafta kalan terime göre küçük olması ve bunun sonucunda çarpım teriminin yuvarlatma hatası verecek kadar büyük değerlere ulaşmasıdır. Hatta bölünen sayı sıfıra eşit olursa çarpan sonsuza da gidebilir. Bunu engellemenin bir yolu eleme prosesi yapılan kolon için bölünen değerin en büyük değer olacağı şekilde satırların yerlerinin değiştirilmesidir. Bu işleme kısmi pivotlama adı veriyoruz. Eleme prosesinin yapıdığı satır ve sütunları tarıyarak maksimum olan değerleri diagonal terimin üzerinde de toplayabiliriz, ancak sütunların yer değiştirilmesi durumunda değişkenlerin sıraları da değişeceğinden çok daha kompleks bir indeksleme sistemine ihtiyacımız olacaktır. Bu yüzden tam pivotlama daha seyrek olarak kullanılan bir prosestir. Şimdi kısmi pivotlamayı bir önceki aynı örnekle anlatalım, örnek problemimiz Burada gauss eliminasyonu uygulamadan önce her kolon için eleme elemanını alttaki elemanlarla karşılaştırarak alttakiler arasında daha büyük mutlak değere sahip olan varsa eleme elemanıyla bu satır değiştirilecektir. Bu değer a10 (2) ve a20 (3) ile karşılaştırıldığında a20 değerinin en büyük olduğu görülecektir. Bu yüzden 2. satır ve 0. satır yer değiştirir ve sistem Bu işleme java program parçacığı olarak bakarsak double buyuk, dummy for(k=0 k<(n-1) k++) { //pivotlama p=k buyuk=Math.abs(a[k][k]) for(ii=k+1 ii<n ii++) { dummy=Math.abs(a[ii][k]) if(dummy > buyuk) {buyuk=dummy p=ii } } if(p.=k) { for(jj=k jj<n jj++) { dummy=a[p][jj] a[p][jj]=a[k][jj] a[k][jj]=dummy } dummy=b[p] b[p]=b[k] b[k]=dummy } } Şeklinde gerçekleştirdiğimizi görürüz. Burada satırları değiştirmek için bir ek değişkene ihtiyaç duyulduğunu not etmede yarar görüyoruz. Program 2.3-1 Pivotlu Gauss Eleme yöntemi import java.io. * class SCO10B { public static double[] pivotlugauss(double a[][],double b[]) { //kısmi pivotlu gauss eleme yöntemi int n=b.length double x[]=new double[n] Çıktı 2.3-1 kısmi pivotlu gauss eleme yöntemi ---------- Capture Output ---------> C \co\java\bin\java.exe SCO10B Orijinal Matris | 1.000000000000000 2.000000000000000 | 2.000000000000000 1.000000000000000 | 3.000000000000000 1.000000000000000 pivotlu Matris k=0 | 3.000000000000000 1.000000000000000 | 2.000000000000000 1.000000000000000 | 1.000000000000000 2.000000000000000 pivotlu Matris k=1 | 3.000000000000000 1.000000000000000 | 0.000000000000000 1.666666666666667 | 0.000000000000000 0.333333333333333 elimine prosesi bitmiş matris k=2 | 3.000000000000000 1.000000000000000 | 0.000000000000000 1.666666666666667 | 0.000000000000000 0.000000000000000 5.000000000000000| 2.000000000000000| 1.000000000000000| 1.000000000000000| 1.000000000000000| 2.000000000000000| 1.000000000000000| 2.000000000000000| 5.000000000000000| 2.000000000000000| 1.000000000000000| 1.000000000000000| 1.000000000000000| 4.666666666666667| 1.333333333333334| 2.000000000000000| 0.333333333333333| -0.333333333333333| 1.000000000000000| 4.666666666666667| 0.400000000000000| 2.000000000000000| 0.333333333333333| -0.400000000000000| sonuç vektörü 0.000000000000000 3.000000000000000 -1.000000000000000 Sonuçtan da görüldüğü gibi sonuç vektöründe bir önce görülen hata burada yok olmuştur. Küçük matris sistemlerinin çözümünde gauss eleme yöntemi ideal bir çözümdür, ancak matris boyutu büyüdüğünde toplam hesap miktarı çok fazlalaştığından pratik avantajını yitirir. Temel ayrılığı pivot elemanı dediğimiz elemenin yapılmasında kullanılan temel elemanın bulunduğu satırın elemeden önce pivot elemanına bölünerek normalize edilmesi ve eleme prosesinin sadece pivot elemanının altındaki satırlara değil pivot elemanı satırı haricindeki tüm satırlar için uygulanmasıdır. Program 2.4-1 de Gauss-Jordan elemesi java programı olarak verilmiştir. Burada çıktı olarak java programlama bölümünde detaylarını verdiğimiz Text sınıfı grafik çıktısı kullanılmıştır. Girdinin çeşitli şekillerde girilebilmesi için de public static double[][] C(double a[][],double b[]) ve public static double[][] C(double a[][],double b[][]) metodları tanımlanmıştır. Program 2.4-1 Gauss_Jordan Eleme yöntemi import java.io. Çıktı 2.4-1 Gauss_Jordan Eleme yöntemi çözüm seti ikinci bir örnek olarak Olarak değiştirmemiz kafidir. Çözüm seti Çıktı 2.4-2 Gauss_Jordan Eleme yöntemi çözüm seti Olacaktır. Bu denklem sistemini Gauss-Jordan eleme kullanarak elle çözelim İkinci sütundakipivot elemanı 3.6667 dir. Tüm ikinci satırı bu değere bölerek normalize edelim Doğru çözüme ulaşmamız pivotlama dediğimiz ek işlemi gerektirir. Kısmi pivotlama işleminde satırlar arasında en büyük mutlak değere sahip olan satırla pivot satırı yer değiştirilir. Program 2.5-1 Kısmi Pivotlu Gauss_Jordan Eleme yöntemi import java.io. * class SCO10C3 { public static double[][] C(double a[][],double b[]) {int n=a.length int m=a[0].length double c[][]=new double[n][m+1] for(int i=0 i<n i++){for(int j=0 j<m j++){c[i][j]=a[i][j] } c[i][m]=b[i] } return c } public static double[][] C(double a[][],double b[][]) {int n=a.length int o=b[0].length int m=n+o double c[][]=new double[n][m] for(int i=0 i<n i++) {for(int j=0 j<n j++){c[i][j]=a[i][j] } for(int j=n j<m j++){c[i][j]=b[i][j] } } return c } public static double[][] pivotlugaussjordan(double a[][]) { //pivotlu int n=a.length Çıktı 2.5-1 Kısmi pivotlu Gauss_Jordan Eleme yöntemi çözüm seti Bu durumda yeni bir sol taraf vektörü değerlendirmeye alınacağı zaman sağ tarafın tekrar işleme alınması gerekmektedir. Bunu engellemek için sol taraf matrisinin üst üçgen matrisi(U) ve alt üçgen matrisi(L) olmak üzere iki matrisin çarpımı şekline getirilmesi, sonra bu iki alt matris vektörünün çözülmesine gidilebilir. Örneğin N=5 için u14 u24 u34 u44 0 0 0 0  0 1 u15  u25  u35   u45  u55  şeklindedir. Çözüm için [A]=[L][U] [A]{X}={B} [L][U]{X}={B} [L]{D}={B} [U]{X}={D} Temel matris çarpım işlemleri dizisinden yararlanılır. Buradaki U matrisini Gauss eleme prosesinden sonraki üst üçgen matris olarak hesaplayabiliriz. L matrisi Gauss eleme prosesindeki çarpanlardan oluşur. L matrisinin diagonal elemanları 1 değerine eşit olduğundan L ve U matrisleri giriş A matrisinin aynı yerine yerleştirilebilir, ek bilgisayar alanı kullanılması gerekmez. Pivotlu versiyonumuzda LU ayrıştırma prosesi ve denklem sistemi çözme prosesi ayrı ayrı uygulandığından matris satır değiştirme işlemi bir referans değeri üzerinden taşınmakta ve denklem sistemi çözümünde b matrisi aynı referansa göre yeniden düzenlenmektedir. Program 2.6-1 Gauss (Dolittle) Eleme yöntemi import java.io. * import javax.swing. Program 2.6-2 Kısmi Pivotlu LU Gauss (Dolittle) Eleme yöntemi import java.io. * import javax.swing. Çıktı 2.6-1 Kısmi Pivotlu LU Gauss (Dolittle) Eleme yöntemi Craut ayrıştırmasının temel farkı U matrisinin köşegen elemanlarının 1 olmasıdır. Örneğin N=5 için l11 l  21 [ L]  l31  l41 l51 Çözüm için yine [A]=[L][U] u15  u25  u35   u45  1  [A]{X}={B} [L][U]{X}={B} [L]{D}={B} [U]{X}={D} Temel matris çarpım işlemleri dizisinden yararlanılabilir. Craut algoritması işlemleri yaparken sırası ile kolon ve satır taramaları yaparak hesaplama işlemini gerçekleştirir. İşlem steplerini şu şekilde sıralayabiliriz döngü i=1,2,….,n li,1 = ai,1 u1, j  a1, j döngü i=2,3,….,n l11 ui , j  l jj döngü k=j+1,j+2,….,n döngü sonu n 1 Algoritmayı Alttaki örnek programda verelim Program 2.7-1 LU Craut yöntemi import java.io. İterativ metodlar eleme işlemi yapmadan bir önceki çözüm setini kullanarak, bir sonraki iterativ çözüme ulaşır. Çözüm sabit hale geldiğinde sonuç elde edilmiş olur. İteratif yöntemlerin en basiti Jacobi metodudur. Burada her denklem için bir x değeri seçilerek değerlendirilir. Diğer x değerleri bir önceki iterasyondan alınır. xik 1  1 (bi   Aij x kj ) Aij j i , 1 i  n Bu denklemin daha çabuk bir şekilde çözüme ulaşması için tüm değerleri bir önceki iterasyondan almak yerine hesaplanan tüm değerler formüle koyulur. Bu iteratif yönteme Gauss-Seidel metodu adı verilir. xik 1  1 i  n İterativ yöntemin dönüşmesini biraz daha çabuklaştırmanın yolu eski iterasyonla yeni iterasyon arasında rahatlama katsayısı ismi verilen gibi bir ağırlık katsayısıyla hesaplamaya gitmektir. xik 1  (1   ) xik   Aij i 1 n j 1 j i 1 (bi   Aij x kj 1  Aij x kj ), 1 i  n  birden büyük veya küçük olabilir. Bu yönteme rahatlamalı interpolasyon (relaxation) adı verilir.  bire eşit olduğunda yöntem normal Gauss-Seidel formülüne dönüşür. Aşağıda bu metodun java dilinde yazılmış programı görülmektedir. Program 2.7-1 Gauss_seidel rahatlamalı interpolasyon formülü import java.io. Çıktı 2.7-1 Gauss_seidel rahatlamalı interpolasyon formülü [A]=[L][L]T Ayrıştırma işlemini i 1 lki  aki   lij lkj j 1 lii ve lkk  akk   lkj2 şeklinde gerçekleştirebiliriz. Cholesky programı altta verilmiştir. Program 2.8-1 Cholesky simetrik matris LU formülü import java.io. 0.000000000000000 4.183300132670377 20.916500663351886 0.000000000000000 0.000000000000000 6.110100926607781 L*L(T) = 5.999999999999999 15.000000000000000 15.000000000000000 55.000000000000000 55.000000000000000 225.000000000000000 55.000000000000000 225.000000000000000 979.000000000000000 Cholesky 0.354676861892435 -0.076785714285715 0.026785714285714  f1 e  2          g1 f2 e3 g2 f3 e4 g3 f4 e5 g4 f5 . g5 . en1 . f n1 en   x1   r1   x   r   2   2    x3   r3        x4    r4    x5   r5       .   . şeklide ifade edilebilir. Tüm LU işlemlernde olduğu gibi ayrıştırma, yerine koyma ve geriye doğru yerine koyma proseslerinden oluşur. Ayrıştırma for(int k=1 k<n k++) {e[k]=e[k]/f[k-1] f[k]=f[k]-e[k]*g[k-1] } İleriye doğru yerine koyma for(int k=1 k<n k++) {r[k]=r[k]-e[k]*r[k-1] } Geriye doğru yerine koyma x[n-1]=r[n-1]/f[n-1] for(int k=(n-2) k>=0 k--) {x[k]=(r[k]-g[k]*x[k+1])/f[k] } Tüm işlem java programı olarak alttaki programda tanımlanmıştır. Program 2.9-1 3-lü bant matris için Thomas algoritması import java.io. * class SCO10H { public static double [] thomas(double a[][],double r[]) { // int n=a.length double f[]=new double[n] double e[]=new double[n] double g[]=new double[n] double x[]=new double[n] for(int i=0 i<n i++) {f[i]=a[i][i] } for(int i=0 i<(n-1) i++) {g[i]=a[i][i+1] } for(int i=0 i<(n-1) i++) {e[i+1]=a[i+1][i] } for(int k=1 k<n k++) {e[k]=e[k]/f[k-1] f[k]=f[k]-e[k]*g[k-1] } for(int k=1 k<n k++) Çıktı 2.9-1 3-lü bant matris için Thomas algoritması thomas 65.969834366776620 93.778462108224330 124.538228334001000 159.479523693137740 thomas 65.969834366776620 93.778462108224330 124.538228334001000 159.479523693137740 Beşli köşegen sistem – yani bant genişliği 5 olan sistemi şu şekilde yazarsak  d1 a  1  e1         c1 d2 a2 e2 f1 c2 d3 a3 e3 f2 c3 d4 a4 . f3 c4 d5 . en3 f4 c5 . an 2 en2 f5 . d n1 an1   x1   b1   x   b   2   2    x3   b3        x4    b4    x5   b5      f n2   .   . Program 2.9-2 5-lü bant matris için band algoritması import java.io. * class SCO10J Program 2.9-3 5-lü bant matris için band algoritması örnek problem çözümü ana programı burada örnek problem olarak 3 lü band matriste aldığımız matrisi çözdük, aynı sonucu görmüş olduk. İkinci bir örnekte 5li band matris çözelim matrisini alalım. Programın metodlarında bir değişiklik olmayacağından sadece ana program listesini veriyoruz. Bu örnekte tüm A matrisini vermek yerine bantları verdik. Bu şekilde giriş çok büyük boyuttaki matrisler için oldukça önemli bir hafıza kazanımı sağlar. Program 2.9-4 5-lü bant matris için band algoritması örnek problem çözümü ana programı x vektörünü çözüm x* vektöründen farklı bir vektör olarak tanımlıyalım. Ek olarak 0 dan farklı bir v vektörü ve gerçek bir sayı olan t sayısını tanımlayalım. g(x+tv)=g(x)+2t [vT (Ax-b)] + t2 [vT(Av)] şeklinde yazılabilir. Bu denklem için x ve v vektörleri bilindiğinde t nin hangi değeri için fonksiyonun minimum olacağını irdeleyelim(değişken boyutunu bir boyuta indirgeyelim). Bu fonksiyonun sadece t'nin fonksiyonu olduğunu kabul edersek h(t)=g(x+tv) yazabiliriz ve minimum h fonksiyonunun t'ye göre türevinde oluşacaktır. Bu denklemden t v T ( Ax  b) olduğu görülebilir. Çözüme ulaştığımızda A xk = A(xk-1 + tkvk ) = b olacağını da biliyoruz. Ancak arama yönü vk i hala bilmiyoruz. vk yönü olarak en dik yamaç yönü seçilebilir. Bu yön g ( x)  2( Ax  b)  2r olur. Bu durumda vk 1   g ( xk )  rk olarak seçilebilir. bu yön g(xk) deki en büyük negatif değişimi verir. Bu metoda en dik yamaç metodu adı verilir. Bu tür vektörlere ortogonal vektör adını veriyoruz. Eğer ortagonal v vektörleri bulabilirsek, bu bizim çözümümüzü oldukça basitleştirecektir (sette i ve j nin eşit olmadığı terimler yok olacağından matris çözümleri yerlerini çarpma ve bölme işlemlerine bırakacaktır.). Özet olarak metodu şu şekilde uygulayabiliriz r0= b – A x0 ve v0= r0 (en dik yamaç medodu değeri) alınır. Görüldüğü gibi yöntem uzun bir yöntemdir, ve küçük matrisler için kullanımı Gauss yöntemi gibi direk metodlara göre daha zordur. Ancak denklem sistemi çok büyük boyutlara ulaştığında tercih edilen bir yöntem haline gelir. Program 2.11-1 konjuge gradyen metodu ile matris sistemi çözümü import java.util. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. * import java.io. } Program 2.11-1 konjuge gradyen metodu ile matris sistemi çözümü ---------- Capture Output ---------> C \co\java\bin\java.exe conjugate_gradient1 k = 9 norm(r)=5.161554370481792E-18 Konjuge gradyan metodu 7.859713075445860 0.422926408295008 -0.073592239024046 -0.540643016894627 0.010626162854036 > Terminated with exit code 0. Konunun başında konjuge gradyan yönteminin başarıyle uygulanabilmesi için denklem sisteminin pozitif ve tanımlı olması gerektiğini belirtmiştik. Pozitif ve tanımlı olmıyan denklem sistemlerinin çözümleri normal olarak iteratif yöntemlerle yapılamaz, ancak denklem sistemi ön şartlandırması veya iyileştirmesi diyebileceğimiz bir yöntem kullanarak, matris sistemini pozitif tanımlı şekle dönüştürebiliriz. Pozitif ve tanımlı bir C matrisi alalım. Bu dönüşümden sonra Konjuge gardyan yöntemini kullanarak çözüme ulaşabiliriz. Pozitif ve Tanımlı C matrisi olarak örneğin A matrisinin diagonal elemanlarının kare köklerinin alındığı, diğer elemanların 0 olduğu bir matris seçilebilir. Eğer bu programı kullanarak şartlandırılmamış konjuge gradyan metodu kullanmak istersek C değerini I birim matrise eşit almalıyız.  0   w2j j 1 Adım 2 k=1 Adım 3 while(k<=N) do adım 4-5 Adım 4 u=Avk tk   k 1 n j j xk=xk-1 + tkvk rk=rk-1 + tkuk wk = C-1rk n  k   w2j j 1 Adım 5 sk= kk vk+1 = C-1 wk + skvk k = k k=k+1 ön şartlandırmalı konjuge gradyan programımızın bu şekilde oluşturulmuş bir versiyonu aşağıda verilmiştir. Program 2.11-2 şartlandırılmış konjuge gradyen metodu ile matris sistemi çözümü import java.util. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. * import java.io. Çıktı 2.11-2 şartlandırılmış konjuge gradyen metodu ile matris sistemi çözümü ---------- Capture Output ---------> C \co\java\bin\java.exe conjugate_gradient2 k=5 Konjuge gradyan metodu 7.859713075445862 0.422926408295008 -0.073592239024046 -0.540643016894627 0.010626162854036 > Terminated with exit code 0. 1.1348  0.5301  3.4129  1.2371 3.8326 1.1651 1.7875 2.5330 4.9317 8.7643 4.9998 10.6721  1 1 / 2  1 / 3  1 / 4 1 / 5 denklem sistemini çözünüz. denklem sistemini rahatlamalı gauss seidel veya diğer iteratif yöntemleri kullanarak çözünüz. denklem sistemini çözünüz. denklem sistemini çözünüz. Şekilde görülen sistemdeki yük dengesi şeklinde yazılabilir. Burada c=cos(s=sin(dır.  =60o için yük dağılımını bulunuz. Şekilde görülen devre için Voltaj akım şiddeti denklemleri şeklinde yazılabilir. R=10  için akım şiddeti, i (Amper), değerlerini hesaplayınız. -x1 + 3x2 + 5x3 + x4 = 8 x1 +9x2 + 3x3 + 4x4 = 10 x2 +x4 = 2 3x1 + x2 +x3 - x4 = -4 doğrusal denklem sistemini uygun bir yöntem ile çözümleyiniz. doğrusal denklem sistemini LU çarpanlara ayırma ( Doolittle) yöntemi ile çözünüz. 4 x1  2 x2  2 x3  x4  11 3x1  x2  3x3  2 x4  3 denklem sistemini, a) Gauss yoketme yöntemi ile b) Gauss-seidel yöntemi ile c) Konuge granyan yöntemi ile çözünüz. x1 + x2 – x3 = -3 6x1 +2x2+2x3=2 -3x1+4x2+x3=1 denklem sistemini kısmi pivotlamalı gauss eleme yöntemi ile çözün. Bu kitabın ekinde de bütün olarak listelenecektir. Bu bölümde matrisle ilgilili işlemleri alt bölümler olarak aldığımızdan Matrix kütüphanesinden alınmış temel işlemler küçük program parçacıkları halinde (ilgili bölümün programları şeklinde) verilecektir. Bu alt bölümde matrisin toplanması ve çarpmasını tanımlıyalım. Matris çıktısını almak için formatlı çıktı metodları da programımıza eklenmiştir. Matris toplama işlemi cij = aij + bij şeklinde özetlenebilir matris çarpma işlemi ise şeklinde gerçekleştirilir. Program 3.1-1 matris toplama ve çarpma işlemleri algoritması import javax.swing. * import java.text. * import java.util.Locale public class matris1 { public static String toString(double left, int w, int d) // converts a double to a string with given width and decimals. Çıktı 3.1-1 matris toplama ve çarpma işlemleri algoritması Çeşitli norm tanımları mevcuttur. Genel tanımlamaları burada verelim Sonsuz normu n n i 1 j 1 A    maksimum ( aij ) norm A  n n j 1 i 1  maksimum( a ij ) Öklit normu Ae n n 2 ij m normu n n A m  m  aijm i 1 j 1 aynı tür tanımlar vektörler için de uyarlanabilir. total=0 int n=a.length for(j=0 j<n i++) {for(i=0 i<n j++) {total+=a[i][j]*a[i][j] }} return Math.sqrt(total) } } aii  1 aij , i j  0 örneğin n=4 için 1 0 [I ]   0  0 0 0 0  1 Transpose matris satır ve sütunlarının yer değiştirdiği matristir. Genelde matris işaretinin üzerinde bir T simbolü ile gösterilir. Ters matris matrisin kendi değeri ile çarpıldığında birim matrise eşit olan matristir. Matrisin bölme işlemi olarakta düşünebiliriz. [A][A]-1.= [I] Ters matrisleri bir önceki bölümde gördüğümüz lineer denklem sistemi çözüm yöntemlerini kullanarak elde edebiliriz. Program 3.3-1 Ters matris programı(kısmi pivotlu gauss LU metodu kullanarak hesaplar import java.io. * class SCO10G { public static void pivot(double a[][],int o[],double s[],int k) {// GaussLU için pivot metodu int n=a.length int dummy1=0 double buyuk double dummy=0 //pivotlama int p=k buyuk=Math.abs(a[o[k]][k]) for(int ii=k+1 ii<n ii++) { dummy=Math.abs(a[o[ii]][k]/s[o[ii]]) -0.100000000000000 7.000000000000000 -0.200000000000000 -0.200000000000000 -0.300000000000000 1.10.000000000000000 0.004944070205797 0.142902644602169 0.002709730785869 0.006798096532971 0.004183444020290 0.099879725984417 -0.200000000000000 -0.300000000000000 10.000000000000000 0.006798096532971 0.004183444020290 0.099879725984417 0.004944070205797 0.142902644602169 0.002709730785869 > Terminated with exit code 0. matrisinin ters matrisini bulunuz. Matematiksel olarak bir bilinmiyenli fonksiyonlar için f(x)= 0 denklemini sağlayan x değerinin bulunması olarak özetlenebilir. Eğer denklem çok bilnmiyenli ise fi(x1,x2,x3,….,xn)=0 , i=1..n denklemlerini sağlayan x1,x2,x3,….,xn değerlerini bulmak işlemidir. Bu bölümde kök bulma işlemlerinin bazılarını detaylı olarak inceleyeceğiz. Eğer bu bölgede bir kök mevcutsa f(a)*f(b) < 0 olacaktır. Bu şart gerçekleşmiyor ise bu bölgede bir kök olmadığını varsayabiliriz. Eğer f(a)*f(p) < 0 ise kökün a-p aralığında olduğunu söyleyebiliriz. Eğer f(a)*f(p) > 0 ise kök p-b bölgesindedir. Tesadüfen f(a)*f(p)=0 oluşabilir, bu kök değerinin p ye tam olarak eşit olduğu anlamına gelir ama bu çok küçük bir olasılıktır. Bulduğumuz yeni kök bölgesini bir sonraki iteasyon için kullanırız. İteratif prosesi durdurmak için (b  a)  (b  a) gibi bir durdurma kriterinden yararlanabiliriz. Döngüyü durdurmak için iteratif yöntemde durdurma kriterinin yanında maksimum iterasyon sayısı kriteri uygulanmıştır. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. İkiye bölme yönteminde yaklaşma göreceli olarak yavaş ilerler. Yaklaşma hızını arttırmanın bir yolu a ve b noktalarını bir doğru ile birleştirmek ve doğrunun x eksenini kesim noktasını bir sonraki kök olarak kullanmaktır. p noktasını p  b  f (b) ( a  b) ( f (a)  f (b) formülüyle bulabiliriz. Kök testi için ikiye bölme yönteminde kullandığımız aynı yöntemi kullanırız. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. Çıktı 4.2-1 Yer değiştirme yöntemi ile kök bulma Aynı kavramı ikinci dereceden polinom kullanarakta yapabiliriz, ancak ikinci dereceden polinom tanımlamak için üç noktaya ihtiyacımız olacaktır. x0, x1, x2 noktalarının giriş değerleri olarak verildiğini varsayalım (x3 değeri x0 ve x1 değeri arasında olsun). Fonksiyonumuz f(x) olsun. Bu üç noktanın y değerleri olarak f(x0), f(x1) ve f(x2) değerlerini alalım bu üç noktadan ikinci derece bir polinom geçirir isek bu polinomun kökü f(x0)-f(x2)=a(x0-x2)2+b(x0-x2) f(x1)-f(x2)=a(x1-x2)2+b(x1-x2) h0= x1 – x0 h1= x2 – x1 d0  d1  f ( x1 )  f ( x0 ) h0 f ( x2 )  f ( x1 ) h1 Şekil 4.3-1 Müller yönteminin grafik olarak gösterilmesi bu ifadeler ana denklemlerde yerine konulursa (h0+h1)b - (h0+h1)2a = h0d0 + h1d1 h1 b h12 a = h1d1 elde edilir buradan da a ve b çözülebilir. d  d0 a 1 h1  h0 b = a*h1 + d1 c=f(x2) kökü bulmak için b b eb b b eb xr  x2  2c e x2 değerinin yerine xr değerini koyarak yeni iterasyonumuza başlayabiliriz. Program 4.3-1 de müler yöntemi gerçek köklerin değerini bulma yöntemi olarak verilmiştir. Bu yöntem sanal köklerin bulunması için de kullanılabilir. Program 4.3-1 Müller yöntemi ile kök bulma programı ///Bilgisayar programlama II ve Sayısal Çözümleme // Muller yöntemi ile kök bulma import java.util. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. int maxit=50 Çıktı 4.3-1 Müller yöntemi ile kök bulma Taylor formülü Şeklindedir. 0 = f(xn) + f'(xn)( xn+1- xn) olur bu denklemden xn+1 çekilirse xn+1 = xn - f(xn) /f'(xn) denklemi elde edilir Bu denkleme Newton-Raphson kök bulma denklemi ismi verilir. x0 ilk tahmininden (tek değer) başlayarak kök değerine iteratif olarak ulaşabiliriz. Newton formülü ilk tahmin gerçek köke göreceli olarak yakınsadığında çok hızlı yaklaşım verir, ancak ilk tahmin kökten uzak ise köke ulaşması uzun sürebilir veya hiç ulaşamayabilir. Newton raphson denkleminin tek zorluğu türevleri bilme zorunluluğudur. Şekil 4.4-1 newton yönteminin yakınsaması Program 4.4-1 Newton-Raphson kök bulma programı // // // Newton-Raphson yöntemi ile kök bulmak // // import java.util. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. Çıktı 4.4-1 Newton-Raphson kök bulma Newton- Raphson yöntemi aynı zamanda kompleks köklerin bulunmasında da kullanılabilir. Kompleks Newtonraphson metodu program 4.4-2 de verilmiştir. Bu programda kullanılan kompleks değişken hesabını yapan complex sınıfı da program 4.4-3 de verilmiştir. Program 4.4-2 Newton-Raphson metoduyla kompleks kök bulma programı // // // kompleks Newton-Raphson yöntemi ile kök bulmak // // import java.util. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. Çıktı 4.4-2 Newton-Raphson metoduyla kompleks kök bulma örnek fonksiyon f(x)=x*x+1 Kompleks kök bulma prosesinde gerekli olan kompleks değişken yapısını kendi geliştirdiğimiz bir java sınıfı olan complex sınıfı üzerinden oluşturduk. Bu sınıfın listesi aşağıda verilmiştir. Bu sınıf genel kullanım için hazırlandığından kod oldukça detaylı olarak hazırlanmıştır. Program 4.4-3 kompleks Newton-Raphson programında kullanılan complex sınıfı import java.io. * import java.text. * import java.util.Locale import java.util. * import javax.swing. * // giriş çıkış // class complex // complex number abstraction // class complex { // constructors public complex() { nreal=0 nimag=0 } public complex(double nre,double nim) { nreal=nre nimag=nim } public complex(int nre,int nim) { nreal=(double)nre nimag=(double)nim } public complex(double numer) { nreal=numer nimag=0 } public complex(complex value ) { nreal=value.real() nimag=value.imaginary() } // accessor functions public double real() { //return real part of the complex number return nreal } public double imaginary() { //return imaginary part of the complex number return nimag } public double R() { } public static complex multiply(complex left, complex right) { // return multiplication of two complex numbers complex result result=new complex ((left.real()*right.real() - left.imaginary()*right.imaginary()), (left.real()*right.imaginary() + left.imaginary()*right.real())) return result } public static complex multiply(complex left, double right) {complex result result=new complex((left.real()*right),(left.imaginary()*right)) return result } public static complex divide(complex left, complex right) { // return division of two complex numbers double a=right.real()*right.real()+right.imaginary()*right.imaginary() complex result result=new complex ((left.real()*right.real() + left.imaginary()*right.imaginary())/a, (-left.real()*right.imaginary() + left.imaginary()*right.real())/a) return result } public static complex divide(complex left, double right) { // return division of a complex number to a real number complex result result=new complex((left.real()/right),(left.imaginary()/right)) return result } public static complex pow(complex left, double right) { // return sum of two complex numbers double Rad,th Rad=Math.pow(left.R(),right) th=right*left.theta() complex result result =new complex((Rad*Math.cos(th) ), (Rad*Math.sin(th) ) ) return result } public static complex exp(complex left) { // exp(x+i*y) complex result result =new complex((Math.exp(left.real())*Math.cos(left.imaginary()) ), (Math.exp(left.real())*Math.sin(left.imaginary()) )) return result } public static complex exp(double left) { // exp(i*left) imaginary exponent complex result result =new complex(Math.cos(left), Math.sin(left) ) return result } public static complex sqrt(complex left) { return pow(left,0.5) } public static double abs(complex left) { return left.R() } public boolean smaller(complex left,complex right) { // less then comparison of two complex numbers return (left.R() < right.R()) } public boolean smaller_equal(complex left,complex right) { // less then and equal comparison of two complex numbers return (left.R() <= right.R()) } public boolean greater(complex left,complex right) { // greater then comparison of two complex numbers return left.R() > right.R() } public boolean greater_equal(complex left,complex right) { // greater then and equal comparison of two complex numbers return left.R() >= right.R() } public boolean equal(complex left,complex right) { // equal comparison of two complex numbers return left.R() == right.R() } public boolean not_equal(complex left,complex right) { // not equal comparison of two complex numbers return left.R() .= right.R() } public static String toString(double left, int w, int d) // converts a double to a string with given width and decimals. { NumberFormat df=NumberFormat.getInstance(Locale.US) df.setMaximumFractionDigits(d) df.setMinimumFractionDigits(d) df.setGroupingUsed(false) String s = df.format(left) while (s.length() < w) s = + s if (s.length() > w) { s = for (int i=0 i<w i++) s = s + - } return s } public static String toString(double left) {// converts a double to a string with a constant width and constant decimals. return toString(left,15,10) } public static String toString(complex value) { String b= if(Math.abs(value.imaginary()).=1) { if(value.imaginary() >= 0) b=b+ ( +toString(value.real())+ + +toString(value.imaginary())+ i ) else b=b+ ( +toString(value.real())+ - +toString(-value.imaginary())+ i ) } else { if(value.imaginary() >= 0) b=b+ ( +toString(value.real())+ + i ) else b=b+ ( +toString(value.real())+ - i ) } return b } public String toString() { String b= if(Math.abs(imaginary()).=1) { if(imaginary() >= 0) b=b+ ( +toString(real())+ + +toString(imaginary())+ i ) else b=b+ ( +toString(real())+ - +toString(-imaginary())+ i ) } else { if(imaginary() >= 0) b=b+ ( +toString(real())+ + i ) else b=b+ ( +toString(real())+ - i ) } return b } public static complex toComplex(String s) { //bu metod compleks sayıyı ekrandan okur. //StringTokanizer kütüphane sınıfı bir stringi cümlelere ayırır String s1=JOptionPane.showInputDialog(s) StringTokenizer token=new StringTokenizer(s1) int n=token.countTokens()-1 int m=n+1 double a[]=new double[m] int j=0 while(token.hasMoreTokens()) { Double ax=new Double(token.nextToken()) a[j++]=ax.doubleValue() } complex b=new complex(a[0],a[1]) return b } // data areas public double nreal public double nimag } Bu türev fonksiyonunu fark denklemiyle değiştirirsek (türevdeki teğet yerine teğete yakın bir kiriş kullanırsak) kiriş yöntemi oluşur Eğer fark denklemi olarak xn1  xn  f ' ( xn )  f ( xn )  f ( xn1 ) formülü kullanılırsa ( xn  xn1 ) f ( xn )( xn  xn1 ) f ( xn )  f ( xn1 ) Bu yöntemde iterasyona başlamak için iki noktanın verilmiş olması gerekmektedir. İlk tahmin olarak f ( x0 ) ve f ( x1 ) olmak üzere iki başlangıç değerinin verilmesi gerekir. Bunun yerine tek bir başlangıç noktası için de decant yöntemi denklemini oluşturabiliriz. Çok küçük bir x aralığı üzerinden fark denklemi f ' ( xn )  f ( xn  x)  f ( xn  x) 2x şeklinde tanımlanacak olursa (merkezi fark denklemini kullanacak olursak), kiriş denklemi xn1  xn  2 f ( xn )x f ( xn  x)  f ( xn  x) şeklini alır. Hatanın az olması için x değerinin göreceli olarak küçük olması gereklidir. Hata (x)2 ile orantılı olacaktır. Şekil 4.5-1 Kiriş yöntemi yakınsamasının grafiksel gösterimi Program 4.5-1 Kiriş yöntemi(iki nokta verilmiş) ///Bilgisayar programlama II ve Sayısal Çözümleme // // // Sekant yöntemi ile kök bulmak // // import java.util. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. Çıktı 4.5-1 Kiriş yöntemi Program 4.5-2 Kiriş yöntemi(tek nokta verilmiş) // Bilgisayar programlama II ve Sayısal Çözümleme // // // Sekant yöntemi ile kök bulmak // // import java.util. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. Çıktı 4.5-2 Kiriş yöntemi (Tek nokta verilmiş) Türev denklemi yerine fark denklemi kullanmayı bir adım daha ileri götürebiliriz. Gerçek türeve yaklaşımı çok daha fazla olacak bir fark denklemini kullanabiliriz. Örneğin fark denklemi olarak f ' ( xn )  formülünü kullanarak hata miktarını (x)2 den (x)4 seviyesine düşürebiliriz. // // // Newton-Raphson yöntemi ile kök bulmak // // import java.util. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. System.exit(0) } } Temel olarak k çok büyük bir değer olduğunda xk 2  a xk 1  a  xk 1  a xk  a k  1 bu bağıntıdan dördüncü bir noktanın değerini bulmak istersek xe  xk xk 2  xk21 xk  2 xk 1  xk 2 3 önceki nokta bilindiğinde 4üncü noktayı tahmin edebiliriz.  xk = xk+1 - xk  xk = xk+2 - 2xk+1 + xk xe  xk  (xk ) 2 2 xk Şimdi bu formülü Newton metodundan elde ettiğimiz ilk yaklaşımları daha iyileştirmek için kullanabiliriz. Program 4.6-1 Aitken ekstrapolasyonlu Newton yöntemi ///Optimizasyon // // // Newton-Raphson_Aitken yöntemi ile kök bulmak // // import java.util. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. Program 4.6-2 Aitken ekstrapolasyonlu Newton yöntemi, türev yerine fark denklemi kullanılmış hali ///Optimizasyon // // // Newton-Raphson_Aitken yöntemi ile kök bulmak // // import java.util. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. * //============= Tanımı gereken fonksiyon ================ class fb extends f_x { public double func (double x) { return Math.log(x*x)-0.7 } } Bu metodda f(x) fonksiyonundan bir x değeri çekilerek f(x)=0 fonksiyonu, x=g(x) fonksiyonuna dönüştürülür. Buna sabit nokta iterasyonu veya direk yerine koyma iterasyonu ismi verilir. Şekil 4.7-1 direk yerine koyma metodunun grafik gösterimi Aitken interpolasyon prosesinden yararlanarak direk yerine koyma metodu iyileştirilebilir. Metod ilk olarak Steffensen tarafından önerilmiştir. p0(0) ilk tahmin değeri verildiğinde, p1(0)=g(p0(0)) ve , p2(0)=g(p1(0)) normal direk yerine koyma adımı olarak hesaplanır, sonra bir Aitken interpolasyon stepi kullanılır. Program 4.7-1 Stephensen kök bulma metodu (Aitken ekstrapolasyonlu direk yerine koyma metodu) ///Bilgisayar programlama II ve Sayısal Çözümleme // Stephensen metodu x=g(x) verildiğinde x değerini bulur. import java.util. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. Çıktı 4.7-1 Stephensen kök bulma metodu (Aitken ekstrapolasyonlu direk yerine koyma metodu) İkinci türevler genelde birinci türev ve fonksiyondan sayısal olarak hesaplanabilir. İkinci türevi Newton-Raphson interpolasyon formülü xn1  xn  f ( xn ) * f ' ( xn ) f ' ( xn ) * f ' ( xn )  f ( xn ) * f ( xn ) şeklindedir. Bu formül katlı kökler dediğimiz aynı noktada birden fazla kök olması durumunda da bize iyi bir dönüşüm hızı sağlayacaktır. Program 4.8-1 İkinci türev düzeltmeli newton-raphson formülü, birinci türev tanımlanmış // // ikinci türev düzeltmeli Newton-Raphson yöntemi // fonksiyon ve birinci türev tanımlanması gereklidir // import java.util. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. Çıktı 4.8-1 İkinci türev düzeltmeli Newton-Raphson formülü, birinci türev tanımlanmış Program 4.8-2 İkinci türev düzeltmeli Newton-Raphson formülü, birinci türev sayısal olarak hesaplanmış // // // ikinci türev düzeltmeli Newton-Raphson yöntemi // fonksiyon tanımlanması gereklidir // // import java.util. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. Öte yandan Newton-raphson metodu eğer köke yakın olduğunda az bir iterasyon sayısıyla köke ulaşırke, kökten uzak bir ilk tahmin verildiğinde kökü hiç bulamayabilir veya çok uzun step sayısıyla köke doğru hareket eder. Bu ikimetodu birleştirerek her metodun avantajlı kısmını bir arada kullanabiliriz, İkiye bölme stepleriyle iterasyona başlayıp, kök değerine yaklaştığımızda Newton-Raphson steplerine geçebiliriz. Alttaki örnek programda Newton metodundaki türev değerleri de sayısal şekle dönüştürülerek sadece fonksiyonun girdi olarak alındığı bir formata dönüştürülmüştür. Bu şekilde oldukça etkin çalışabilen bir kök bulma sistemi oluşmuştur. Program 4.9-1 Newton-Raphson-İkiye bölme kombine formülü, birinci türev sayısal olarak hesaplanmış // // // Newton-Raphson-ikiye bölme kombine yöntemi ile kök bulmak // // import java.util. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. Çıktı 4.9-1 Newton-Raphson-İkiye bölme kombine formülü, birinci türev sayısal olarak hesaplanmış İkinci bir örnek problemi ısı transferinden tanımlayalım. Düz bir duvarın sıcaklığı denklemiyle verilmektedir. Bu denklem zamana bağlı bir boyutlu taşınım ısı transferini tanımlar. Buradaki T sıcaklık(derece Kelvin), x mesafe, t zaman (saniye) değişkenidir. ısıl yayılım olarak tanımlanır ve formüldeki k ısıl iletim katsayısı (W/mK), yoğunluk (kg/m3), C ısıl iletim katsayısıdır (W/kgK). h ısı taşınım katsayısı adını alır. (W/m2K). Diferansiyel denklemin çözüm seti şeklinde yazılabilir. Bu denklemi boyutsuz formda yazarsak sınır şartları bu diferansiyel denklemi çözersek formunda bir çözüme ulaşırız. Buradaki Bi Biot sayısıdır. olarak tanımlanır. Bu denklemin çözümü şeklindedir. Burada ve şeklinde verilebilir. Bu denklemin çözülebilmesi denklemin kökünü bulma anlamına gelir. Denklemi çözmek için önce kökü buluruz, sonra Cn katsayılarını çözdükten sonra denklem çözülür. Bu işlemleri yapan ve çözümü veren program altta verilmiştir. Program 4.9-2 Newton-Raphson-İkiye bölme kombine formülü, ile zamana bağlı duvar probleminin çözümü import java.util. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. silindir için benzer denklem silindirik koordinat sisteminde çözülürse sonuç denklemleriyle verilebilir. Buradaki J0(n), J1(n) birinci tip Bessel fonksiyonlarıdır. Program 4.9-3 Newton-Raphson-İkiye bölme kombine formülü, ile zamana bağlı silindir probleminin çözümü import java.util. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. Buradaki Bessel fonksiyonu ayrıca düzenlenmiş olan Mathd sınıfında hesaplanmıştır bu sınıfın listesi de ayrıca veriyoruz. Program 4.9-3A Mathd sınıfı listesi import static java.lang.Math. * public class Mathd { public static double PI=Math.PI public static double E=Math.E public static double C=0.577215664901532860606512090082402431 ans 2.0-ans } İkinci dereceden Lagrange interpolasyonu x=f(y) şeklinde (ters interpolasyon olarak) yazılırsa x [ y  f ( x1 )][ y  f ( x2 )] x3 [ y  f ( x2 )][ y  f ( x3 )] x1 [ y  f ( x3 )][ y  f ( x1 )] x2   [ f ( x3 )  f ( x1 )][ f ( x3 )  f ( x2 )] [ f ( x1 )  f ( x2 )][ f ( x1 )  f ( x3 )] [ f ( x2 )  f ( x3 )][ f ( x2 )  f ( x1 )] bu intrepolasyon denkleminde y=0 alındığında x değeri bize y=f(x)=0 denkleminin köklerini verecektir. x f ( x1 ) f ( x2 ) x3 f ( x2 ) f ( x3 ) x1 f ( x3 ) f ( x1 ) x2   [ f ( x3 )  f ( x1 )][ f ( x3 )  f ( x2 )] [ f ( x1 )  f ( x2 )][ f ( x1 )  f ( x3 )] [ f ( x2 )  f ( x3 )][ f ( x2 )  f ( x1 )] [ f ( x1 )  f ( x2 )] f ( x1 ) f ( x2 ) x3  [ f ( x3 )  f ( x2 )] f ( x2 ) f ( x3 ) x  [ f ( x3 )  f ( x1 )] f ( x3 ) f ( x1 ) x2 [ f ( x3 )  f ( x1 )][ f ( x3 )  f ( x2 )][ f ( x1 )  f ( x3 )] Denklemimiz hesap kolaylığı açısından x R f ( x2 ) f ( x3 ) S f ( x2 ) f ( x1 ) T f ( x1 ) f ( x3 ) P = S[T(R-T)(x3 – x2) – (1-R)(x2 – x1)] Q = (T - 1)(R – 1)(S – 1) Formunda da yazılabilir. Kök değeri x = x2 + P Q olacaktır. Yeni kök bulunduktan sonra bulunan köke komşu olan bölgeler bırakılır ve bu bölgenin dışında olan bölge elimine edilir. Şekil 4.10-1 İkinci derece ters lagrange interpolasyon yönteminde bölge seçimi Şekil 4.10-1 de bu seçim işlemi görülmektedir. Bu mtodun uygulaması Program 4.10-1 de verilmiştir. Program 4.10.1 ikinci derece ters Lagrange interpolasyon formülü kullanarak kök bulma programı import java.util. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. Çıktı 4.10.1 ikinci derece ters Lagrange interpolasyon formülü kullanarak kök bulma programı çıktısı Aynı şekilde ikinci dereceden ters Lagrange interpolasyon kök bulma yöntemi de ikiye bölme yöntemi ile integre edilerek oldukça yararlı bir yöntem oluşturulabilir. Bu yöntem Brent yöntemi adını alır. Bu yöntemde ikinci dereceden ters Lagrange interpolasyon kök bulma yönteminden farklı olarak sadece iki sınır değeri tanımlanır. Birinci step olarak ikiye böme formülü uygulanır ve ikinci dereceden interpolasyonun üçüncü noktası olarak bu noktadan yararlanılır. İkinci dereceden ters Lagrange interpolasyon kök formülü kullanılarak yeni bir çözüm noktası saptanır ve bu çözüm bölgesine göre bölge küçültülür. Eğer çözüm seçilen değer x1 – x2 bölgesine düşmüyorsa yeni bir ikiye bölme stebi uygulanır. Denklemin bölündüğü değerinin çok küçük olduğu sıfıra yaklaştığı değerlerde metod yine yanlış değer verebilir. Bu durumda yine ikiye bölme yöntemine dönülür. Bu bölümde Brent yönteminin iki versiyonu örnek program olarak düzenlenmiştir. Birinci program üstteki bölümde oluşturduğumuz programı değiştirerek oluşturulmuştur. Program 4.11-1 Brent yöntemi ile kök bulma import java.util. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. Çıktı 4.11-1 Brent yöntemi ile kök bulma Program 4.11-2 Brent yöntemi ile kök bulma (ikinci versiyon) ///Bilgisayar programlama II ve Sayısal Çözümleme // // // Brent yöntemi ile kök bulmak // // import java.util. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. * Çıktı 4.11-2 Brent yöntemi ile kök bulma Bu kural üniversal olarak her tür fonksiyon için geçerli olmasa da sürekli fonsiyon ailesinin çoğu üyesi için geçerlidir. O zaman verilen bir alanı daha küçük steplerle tarayarak kök sınırlarının bulunduğu bölgeyi daraltabiliriz, veya belli bir noktadan veya birbirine yakın iki noktadan başlayarak ve her seferinde bölgeyi birden büyük bir  katsayısıyla kökün bulunduğunu tahmin ettiğimiz tarafa doğru genişleterek kökün olduğu bir bölge sapayabiliriz. Bu amaçla genişlet ve koksınırınısapta metodları geliştirilmiş ve alttaki programda brent metoduyla birlikte kullanılmıştır. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. * Ridder metodu bu metodun değiştirilmiş bir versiyonu olarak kabul edilebilir. x1 ve x2 noktaları arasında bir kök mevcut ise Ridder metodu önce orta noktada fonksiyonu değerlendirir. daha sonra fonksiyonu lineer fonksiyona dönüştüren özel bir faktörü eQ faktörünü çözer. Daha açık yazacak olur isek f(x1)-2f(x3) eQ + f(x2) e2Q = 0 fonksiyonundan eQ faktörünü çözer. İkinci dereceden bir fonksiyon olan bu fonksiyonun kökleri f ( x3 )  sign[ f ( x2 )] f ( x3 ) 2  f ( x1 ) f ( x2 ) e  f ( x2 ) Q şeklinde hesaplanır. Buradaki sign(x) fonksiyonu x in işaretini verecektir. Eğer x sıfırdan büyükse +1, eğer sıfırdan küçükse -1 değerini verecektir. Şimdi yer değiştirme metodu f(x1), f(x3) ve f(x2) fonksiyonlarını kullanarak değil f(x1), f(x3) eQ ve f(x2) e2Q fonksiyonlarına uygulanarak x4 kök değeri bulunur. sign[ f ( x1 )  f ( x2 )] f ( x3 ) x4 x3  ( x3  x1 ) f ( x3 ) 2  f ( x1 ) f ( x2 ) Denklem ikinci dereceden olduğundan ikinci derece yaklaşım sağlar . Aynı zamanda bulunan kök her zaman x1 ve x2 arasında yer alacaktır. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. fm=f.func(xm) s=Math.sqrt(fm*fm-fl*fh) if (s == 0.0) return ans xnew=xm+(xm-xl)*((fl >= fh . 1.0 -1.0)*fm/s) if (Math.abs(xnew-ans) <= xacc) return ans ans=xnew fnew=f.func(ans) if (fnew == 0.0) return ans if (SIGN(fm,fnew) .= fm) { xl=xm fl=fm xh=ans fh=fnew } else if (SIGN(fl,fnew) .= fl) { xh=ans fh=fnew } else if (SIGN(fh,fnew) .= fh) { xl=ans fl=fnew } else System.out.println( bu noktaya asla ulaşamayız. ) Üçüncü dereceden polinomun köklerini paralel, fakat biraz daha karışık olan bir denklem sistemi kullanarak bulabiliriz. Sınır değer problemi çözümünde ninci dereceden polinomun köklerini bulmayı da irdeleyeceğiz. Program 4.14-1 Üçüncü dereceden polinomun köklerini bulan program import java.util. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. * import java.io. * import java.text. * import java.util.Locale //import Numeric public static complex[] cubic_rootsC(double c[]) { // roots of a degree 3 polynomial //return 3 complex roots double a[][]=new double[2][3] a=cubic_roots(c) complex e[]=new complex[3] for(int i=0 i<3 i++) e[i]=new complex(a[0][i],a[1][i]) return e } public static double[] verigir(String s) { String s1=JOptionPane.showInputDialog(s) StringTokenizer token=new StringTokenizer(s1) int n=token.countTokens()-1 int m=n+1 double a[]=new double[m] int j=0 while(token.hasMoreTokens()) { Double ax=new Double(token.nextToken()) a[j++]=ax.doubleValue() Bu programda kullanılan kompleks değişken hesabını yapan complex sınıfı da program 4.4-3 de verilmiştir. Çıktı 4.14-1 Üçüncü dereceden polinomun köklerini bulan program g ( x)  [ f ' ( x)]2  xk 1  xk  buradaki n f ( x) f ( x) n 1 n f ( xk ) f ( xk )  (n  1) g ( xk ) ' g ( xk ) terimi kompleks olabilir.dolayısıyla bu metodu kompleks olarak yazmak daha doğrudur. Program 4.15-1 Leguerre yöntemi ile polinom köklerinin hesaplanması // // // kompleks Lequerre yöntemi ile polinomun kökünü bulmak // // import java.util. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. public static complex Leguerre(double a[],complex x) { int n=a.length-1 double eps=1.0e-8 int m=50 int k=0 complex f0=func(a,x) complex f1=new complex() complex f2=new complex() complex g=new complex() complex d1=new complex() complex d2=new complex() complex x0=x complex x1=new complex((-a[0]/a[1]),0.0) do{ f1=dfunc(a,x0) f2=d2func(a,x0) g=complex.add(complex.multiply(f1,f1),complex.multiply(complex.multiply(f0,f2),(-(double)n/(double)(n-1)))) d1=complex.add(f1,complex.multiply(complex.pow(g,0.5),(double)(n-1))) d2=complex.add(f1,complex.multiply(complex.pow(g,0.5),(double)(1-n))) if(complex.abs(d1)>=complex.abs(d2)) x1=complex.add(x0,complex.multiply(complex.divide(f0,d1),(double)(-n))) else x1=complex.add(x0,complex.multiply(complex.divide(f0,d2),(double)(-n))) x0=complex.add(x1,0.0) f0=func(a,x0) k++ }while(complex.abs(f0)>eps && k<m) if(complex.abs(f0)<eps) { return x1 } Çıktı 4.15-1 Leguerre yöntemi ile polinom köklerinin hesaplanması Programda kullanılan complex sınıfı Program 4.4-3 olarak tanımlanmıştır. Bu bölüme kadar lineer olmıyan bir bilinmiyenli f(x) denkleminin çeşitli çözüm yöntemlerini irdeledik. Eğer birden fazla bilinmiyen varsa, bu bilinmeyenlerin köklerini bulmak için kök sayısı kadar denkleme ihtiyacımız vardır. Bu durumda lineer olmıyan bir denklem sisyeminin çözmekten veya köklerini bulmaktan bahsedebiliriz. Bölümümüzün bundan sonraki alt konularında çeşitli lineer olmayan denklem sistemi çözüm yöntemleri irdelenecektir. xn+1 = xn - f(xn) /f'(xn) formülüne ulaşmıştık. Bu formülü biraz değiştirirsek aynı formül  xn+1 = xn+1 - xn = - f(xn) /f'(xn) f'(xn)*xn+1 = - f(xn) formunda yazılabilir. Şimdi aynı işlemi çok boyutlu bir denklem sisteminin köklerini bulma problemi olarak düşününelim. Türev denklemi  f1  x  1  f 2  x1 [f ]   f 3   x1  ...  f n  x  1 f1 x2 f 2 x2 f 3 x2 ... f n x2 f1 x3 f 2 x3 f 3 x3 ... f n x3 ... ... ... ... ... f1  xn   f 2  xn  f 3   xn  ...  f n  xn  şeklinde verilebilir. Bu durumda Newton-raphson denklemi [f ] {x} = - { f } şeklini alır. Görüldüğü gibi denklemimiz bir lineer denklem sistemidir ve bir önceki bölümde gördüğümüz tekniklerle çözülebilir. Her çözümde {x} in yeni değerlerini elde edeceğimizden, bunlardan da yeni x değerlerini buluruz. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. Çıktı 4.16-1 Çok boyutlu lineer olmayan denklem çözümü(köklerini bulma) Newton-Raphson denkleminde en önemli problemlerden biri türevlerin değerlerinin gerekmesidir. Bu zorluğu türevleri sayısal yöntemlerle (fark denklemleri olarak) hesaplamaktır. * import java.awt. * import java.applet.Applet import java.awt.event. * import javax.swing. public static double[] newtond( fi_xi f,double x[]) { // lineer olmayan denklem siteminin kökleri // fj(xi)=0 lineer olmayan denklem sistemi için çözüm matrisi // türev matrisi dfj/dxi turev alt programıyla hesaplanır. // Newton-Raphson metodu ile lineer olmayan denklem sistemi çözümü //ti önem katsayısı //x bağımsız değişken vektörü //y bağımlı değişken vektörü //dy bağımlı değişkenin türev fonksiyonları vektörü double ti=1.0 Burada x={x1, x1,…, xn-1, xn} çok boyutlu değişken setidir. Bu durumda kiriş metodunu uygulayarak türev fonksiyonunu yaklaşık değerini oluşturabiliriz. Hatırlanacağı gibi, Newton-Raphson denkleminde  f1  x  1  f 2  x1 [f ]   f 3   x1  ...  f n  x  1 f1 x2 f 2 x2 f 3 x2 ... f n x2 f1 x3 f 2 x3 f 3 x3 ... f n x3 ... ... ... ... ... f1  xn   f 2  xn  f 3   xn  ...  f n  xn  şeklinde verilebilir. Bu durumda Newton-raphson denklemi [f ] {x} = - { f } şeklini alır. Burada [f ] yerine yaklaşık türev formülünden yararlanmak istersek f j xk ( x (i ) )  gibi bir formülle hesaplayabiliriz. Formüldeki h küçük bir sonlu değişim miktarı, ek ise k inci bileşeni 1 diğer bileşenleri 0 olan bir vektördür. Buradaki (i) iterasyon sayısını belirtir. Kiriş yöntemi uygulandığında Newton-raphson formülünün kök civarındaki hızlı yakınsaması yerini daha yavaş bir yakınsama hızına bırakır. Bu yüzden burada standart kiriş yöntemi yerine yakınsama hızı birim hesaplama başına daha etkin olan Broyden yöntemini inceleyeceğiz. Broyden yönteminde x(0) ilk iterasyonu verilmiş ise x(1) iterasyonunuNewton metodunu kullanarak hesaplayabiliriz. Bundan sonraki stepler için şu yaklaşımı kullanırız [f ( x(0) )] {x(1)  x( 0) } = - { f ( x( 0) } denklemi [ A1 ] {x(1)  x( 0) } = { f ( x(1)  f ( x(0) } şeklini alabilir. Bu denklemin geçerli olabilmesi için [ A1 ] vektörünün her z vektörü için [ A1 ] {z} = [f ( x( 0) )]z [ A1 ] formülünü oluşturabiliriz. [ A1 ]  f ( x )  (0) buradaki {x(1)  x( 0) }t z  0 tanımlarını gerçekleştirmesi gerekir. Bu temel tanımdan [{ f ( x (1) )  f ( x ( 0) )}  f ( x ( 0) )( x (1)  x ( 0) )] * ( x (1)  x ( 0) )t x (1)  x ( 0) x (1)  x ( 0) 2 2 2 2 ifadesi 2 normudur. Norm tanımları 3. bölümümüzde verilmişdi. [ A1 ] değerini bulduktan sonra x vektörünün yeni değerini oluşturabiliriz. 1 x ( 2) bulunduktan sonra bu değeri aynı yolla x (3) ü hesaplamak için kullanırız. Genel olarak formülümüz [ Ai ]  [ Ai 1 ]  x ( i 1) [{ f ( x (1) )  f ( x ( 0) )}  [ Ai 1 ]( x (1)  x ( 0) )] * ( x (1)  x ( 0) )t x (1)  x ( 0) 1 2 2 (i ) formunu alır. Bu formülde her seferinde A matrisinin ters matrisini çözme zorunluluğumuz mevcuttur. Bu işlemi Gauss eleme yöntemi gibi bir yöntem kullanarak gerçekleştirebiliriz. Ancak Gauss yöntemide oldukça yüksek hesaplama zamanına ihtiyaç gösterir. Daha iyi bir alternatif iteratif Sherman-Morrison formülünü kullanmaktır. Sherman_Morrison formülü Ai-1 değerini direk olarak Ai-1-1 değerinden hesaplıyabilmemizi sağlar. Bu formülü şu stepleri kullanarak oluştururuz si  {x(1)  x(i 1) } yi  { f ( x(i ) )  f ( x(i 1) )} ( A  xy t )1  A1     1 yi  Ai 1si t  1 Ai   A  si  2   si 2   1 bu denklem sadece matris çarpımlarını kapsadığından toplam işlem olarak yapılması çok daha kolaydır. Bu denklemleri kullanarak oluşturulmuş Broyden algoritması Program 4.16-1 de verilmiştir. * import